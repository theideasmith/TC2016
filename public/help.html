<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
<link href="assets/logos/favicon-q-9ba6cb893a620560ab734fe26a5bef5f.png" rel="shortcut icon" type="image/vnd.microsoft.icon" />
<title>
Quantopian Help
</title>
<link href="assets/help_bundle-543a0900811dda5717df2c8582e7012a.css" media="all" rel="stylesheet" type="text/css" />
<link href="assets/application-d001ce6de06ac687a73896481c43ddda.css" media="all" rel="stylesheet" type="text/css" />
<script src="assets/application-269bf65687954fcb4ed430e74a738c6f.js" type="text/javascript"></script>
<script src="https://use.typekit.com/uvj7txo.js" type="text/javascript"></script>
<script type="text/javascript">
//<![CDATA[
try{Typekit.load()}catch(e){}
//]]>
</script>
<script src="https://js.stripe.com/v2/" type="text/javascript"></script>
<meta content='pk_live_qyEzgiIO9PIT9AEbwiX8qw6g' name='stripe-key'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Titillium+Web:300,400,' rel='stylesheet' type='text/css'>
<meta content="authenticity_token" name="csrf-param" />
<meta content="XIZmvJvBSDp8R371BFoxbTfU5NJRO3ZTtXciYR83l3c=" name="csrf-token" />
<meta content='width=device-width, initial-scale=1.0' name='viewport'>

<input id="current_user_id" name="user_id" type="hidden" value="572d6deed42b61f8d200072f" />
<input id="current_user_type" name="user_type" type="hidden" value="1" />
<input id="quanto-env" name="env" type="hidden" value="production" />
</head>
<body class='' ontouchstart=''>
<div id='fb-root'></div>
<div class='wrapper' id='help-index'>
<div class='app-navbar navbar navbar-default old-style'>
<div class='app-header navbar-inner'>
<div class='navbar-brand inline-block'>
<a class='logo-image' href='home.html'></a>
</div>
<div class='navbar-mobile navbar-mobile-trigger'>
<div class='pull-right'>
<a class='navbar-menu-anchor' id='navbar-menu-anchor'></a>
</div>
</div>
<div class='navbar-fullscreen navbar-right'>
<ul class='nav navbar-nav'>
<li class='dropdown hidden unconfirmed-user-header'>
<a class='header' data-toggle='dropdown' href='help.html#'>
<span class='icon icon-warning'></span>
Unconfirmed Account
</a>
<ul class='dropdown-menu no-close-on-click'>
<div class='confirm-dropdown'>
<div>
Click on the confirmation link in the email that Quantopian sent to <strong class="confirm-email-address">
</strong>.
</div>
<div class='margin_10t'>
<button class='btn resend-confirmation' id='resend-confirmation-email-button'>Resend Confirmation Email</button>
</div>
</div>
</ul>
</li>
<li>
<a class='header' href='fund.html'>Capital</a>
</li>
<li>
<a class='header' href='data.html'>Data</a>
</li>
<li class='dropdown quanto-dropdown-new'>
<a class='header' data-toggle='dropdown' href='help.html#'>
My Code
</a>
<ul class='dropdown-menu quanto-dropdown-new'>
<li>
<a href='research/survey.html'>Notebooks</a>
</li>
<li>
<a href='algorithms.html'>Algorithms</a>
</li>
</ul>
</li>
<li class='dropdown quanto-dropdown-new'>
<a class='header' data-toggle='dropdown' href='help.html#'>
Community
</a>
<ul class='dropdown-menu'>
<li>
<a class='' href='posts.html' id='community-header-link'>Forums</a>
</li>
<li>
<a href='open.html'>Contest</a>
</li>
<li>
<a href='http://www.quantcon.com'>QuantCon</a>
</li>
</ul>
</li>
<li class='dropdown quanto-dropdown-new'>
<a class='header' data-toggle='dropdown' href='help.html#'>
Learn & Support
</a>
<ul class='dropdown-menu'>
<li>
<a href='learn.html'>Learn</a>
</li>
<li>
<a class='open-feedback-link' href='help.html#'>Contact Support</a>
</li>
</ul>
</li>
<li>
<a href="signin.html" class="header unregistered-user-action">Log In</a>
</li>
<li>
<a href="users/sign_up.html" class="header unregistered-user-action">Sign Up</a>
</li>

</ul>
</div>
<div class='clear-fix'></div>
</div>
<div id='mobile-navbar-menu'>
<div class='mobile-nav-category-title no-arrow'>
<a href='fund.html'>Capital</a>
</div>
<div class='mobile-nav-category-title no-arrow'>
<a href='data.html'>Data</a>
</div>
<div class='mobile-nav-category'>
<div class='mobile-nav-category-title'>My Code</div>
<div class='mobile-nav-rows'>
<div class='mobile-nav-row'>
<a href='research/survey.html'>Notebooks</a>
<a href='algorithms.html'>Algorithms</a>
</div>
</div>
</div>
<div class='mobile-nav-category'>
<div class='mobile-nav-category-title'>Community</div>
<div class='mobile-nav-rows'>
<div class='mobile-nav-row'>
<a class='' href='posts.html' id='community-header-link'>Forums</a>
<a href='open.html'>Contest</a>
<a href='http://www.quantcon.com'>QuantCon</a>
</div>
</div>
</div>
<div class='mobile-nav-category'>
<div class='mobile-nav-category-title'>Learn &amp; Support</div>
<div class='mobile-nav-rows'>
<div class='mobile-nav-row'>
<a href='learn.html'>Learn</a>
<a class='open-feedback-link' href='help.html#'>Contact Support</a>
</div>
</div>
</div>
<div class='mobile-nav-category-title no-arrow'>
<a href='users/sign_in.html'>Log In</a>
</div>
<div class='mobile-nav-category-title no-arrow sign-up-btn'>
<a href='users/sign_up.html'>Sign Up</a>
</div>
</div>
</div>
<script>
  //<![CDATA[
    $(document).ready(function () {
      quanto.instances.fm = new quanto.FeedbackManager();
      quanto.instances.hm = new quanto.headerManager();
    })
  //]]>
</script>


<div class='content content-area old-style'>
<div class='mainpage-container'>
<div class='help-container row-fluid'>
<div class='help-outline span3' id='help-outline'>
<ol class='nav help-toc' data-offset-top='50' data-spy='affix'>
<li>
<a href='help.html#overview'>Quantopian Overview</a>
</li>
<li>
<a href='help.html#important-concepts'>Important Concepts</a>
<li class='indent1'>
<a href='help.html#overview-datasources'>Data sources</a>
</li>
<li class='indent1'>
<a href='help.html#overview-research'>Research</a>
</li>
<li class='indent1'>
<a href='help.html#overview-ide'>IDE and Backtest</a>
</li>
<li class='indent1'>
<a href='help.html#overview-papertrading'>Paper Trading</a>
</li>
<li class='indent1'>
<a href='help.html#overview-livetrading'>Live Trading</a>
</li>
</li>
<li>
<a href='help.html#security'>Privacy and Security</a>
</li>
<li class='indent1'>
<a href='help.html#twofactor'>Two-Factor Authentication</a>
</li>
<li>
<a href='help.html#ide'>Developing in the IDE</a>
</li>
<li class='indent1'>
<a href='help.html#ide-api'>API Overview</a>
</li>
<li class='indent1'>
<a href='help.html#data-object'>The data object</a>
</li>
<li class='indent1'>
<a href='help.html#ide-schedulefunction'>Scheduling functions</a>
</li>
<li class='indent1'>
<a href='help.html#overview-gettingdata'>Getting price data</a>
</li>
<li class='indent1'>
<a href='help.html#ide-history'>History</a>
</li>
<li class='indent1'>
<a href='help.html#ide-ordering'>Ordering</a>
</li>
<li class='indent1'>
<a href='help.html#ide-portfolio'>Viewing portfolio state</a>
</li>
<li class='indent1'>
<a href='help.html#pipeline-title'>Pipeline</a>
</li>
<li class='indent2'>
<a href='help.html#basic-usage'>Basic Usage</a>
</li>
<li class='indent3'>
<a href='help.html#initializing-a-pipeline'>Initializing a Pipeline</a>
</li>
<li class='indent3'>
<a href='help.html#importing-datasets'>Importing Datasets</a>
</li>
<li class='indent3'>
<a href='help.html#building-computations'>Building Computations</a>
</li>
<li class='indent3'>
<a href='help.html#adding-computations-to-a-pipeline'>Adding Computations</a>
</li>
<li class='indent3'>
<a href='help.html#using-results'>Using Results</a>
</li>
<li class='indent2'>
<a href='help.html#next-steps'>Next Steps</a>
</li>
<li class='indent3'>
<a href='help.html#custom-factors'>Custom Factors</a>
</li>
<li class='indent3'>
<a href='help.html#default-inputs'>Default Inputs</a>
</li>
<li class='indent3'>
<a href='help.html#fundamental-data'>Fundamental Data</a>
</li>
<li class='indent3'>
<a href='help.html#masking-factors'>Masking Factors</a>
</li>
<li class='indent3'>
<a href='help.html#normalizing-results'>Normalizing Results</a>
</li>
<li class='indent3'>
<a href='help.html#working-with-dates'>Working with Dates</a>
</li>
<li class='indent1'>
<a href='help.html#ide-dollar-volume'>Dollar Volume</a>
</li>
<li class='indent1'>
<a href='help.html#ide-algospeed'>Algorithm Speed</a>
</li>
<li class='indent1'>
<a href='help.html#ide-manual-lookup'>Manual Security Lookup</a>
</li>
<li class='indent1'>
<a href='help.html#ide-logging'>Logging</a>
</li>
<li class='indent1'>
<a href='help.html#ide-record'>Recording &amp; plotting variables</a>
</li>
<li class='indent1'>
<a href='help.html#ide-dividends'>Dividends</a>
</li>
<li class='indent1'>
<a href='help.html#ide-fundamentals'>Fundamental Data</a>
</li>
<li class='indent1'>
<a href='help.html#overview-setbenchmark'>Setting a custom benchmark</a>
</li>
<li class='indent1'>
<a href='help.html#ide-slippage'>Slippage models</a>
</li>
<li class='indent1'>
<a href='help.html#ide-commission'>Commission models</a>
</li>
<li class='indent1'>
<a href='help.html#overview-fetcher'>Fetcher</a>
</li>
<li class='indent1'>
<a href='help.html#ide-validation'>Validation</a>
</li>
<li class='indent1'>
<a href='help.html#ide-module-import'>Module Import</a>
</li>
<li class='indent1'>
<a href='help.html#ide-collaboration'>Collaboration</a>
</li>
<li>
<a href='help.html#backtests'>Backtesting</a>
</li>
<li class='indent1'>
<a href='help.html#debugger'>Debugger</a>
</li>
<li class='indent1'>
<a href='help.html#backtests-results'>Backtest results</a>
</li>
<li>
<a href='help.html#live-trading'>Live Trading</a>
</li>
<li class='indent1'>
<a href='help.html#broker-fields'>Broker Account Fields</a>
</li>
<li class='indent1'>
<a href='help.html#ide-trading-guards'>Trading Guards</a>
</li>
<li>
<a href='help.html#zipline'>Zipline</a>
</li>
<li class='divider no-highlight'></li>
<li>
<a href='help.html#api-doco'>API Documentation</a>
</li>
<li class='indent1'>
<a href='help.html#api-toplevel'>Methods to implement</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-initialize'>initialize</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-handle_data'>handle_data</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-before_trading_start'>before_trading_start</a>
</li>
<li class='indent1'>
<a href='help.html#api-data-methods'>Data methods</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-data-current'>current</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-data-history'>history</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-data-can_trade'>can_trade</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-data-is_stale'>is_stale</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-data-fetcher_assets'>fetcher_assets</a>
</li>
<li class='indent1'>
<a href='help.html#api-order-methods'>Order methods</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order'>order</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order-value'>order_value</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order-percent'>order_percent</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order-target'>order_target</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order-target-value'>order_target_value</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-order-target-percent'>order_target_percent</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-cancel-order'>cancel_order</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-get-open-orders'>get_open_orders</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-get-order'>get_order</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-get-fundamentals'>get_fundamentals</a>
</li>
<li class='indent1'>
<a href='help.html#api-order-execution'>Order Execution in IB</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-relative-order'>RelativeOrder</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-VWAPBestEffort'>VWAPBestEffort</a>
</li>
<li class='indent1'>
<a href='help.html#pipeline-api'>Pipeline</a>
</li>
<li class='indent2'>
<a href='help.html#core-api'>Core API</a>
</li>
<li class='indent3 code'>
<a href='help.html#quantopian_pipeline_Pipeline'>Pipeline</a>
</li>
<li class='indent3 code'>
<a href='help.html#quantopian_pipeline_CustomFactor'>CustomFactor</a>
</li>
<li class='indent2'>
<a href='help.html#base-classes'>Base Classes</a>
</li>
<li class='indent3 code'>
<a href='help.html#zipline_pipeline_data_dataset_BoundColumn'>BoundColumn</a>
</li>
<li class='indent3 code'>
<a href='help.html#quantopian_pipeline_factors_Factor'>Factor</a>
</li>
<li class='indent3 code'>
<a href='help.html#quantopian_pipeline_filters_Filter'>Filter</a>
</li>
<li class='indent3 code'>
<a href='help.html#quantopian_pipeline_classifiers_Classifier'>Classifier</a>
</li>
<li class='indent2'>
<a href='help.html#built-in-factors'>Built-in Factors</a>
</li>
<li class='indent2'>
<a href='help.html#built-in-filters'>Built-in Filters</a>
</li>
<li class='indent2'>
<a href='help.html#built-in-classifiers'>Built-in Classifiers</a>
</li>
<li class='indent2'>
<a href='help.html#earnings-calendars'>Earnings Calendars</a>
</li>
<li class='indent1'>
<a href='help.html#api-other'>Other methods</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-fetchcsv'>fetch_csv</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-get-datetime'>get_datetime</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-get-environment'>get_environment</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-log'>log</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-record'>record</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-schedulefunction'>schedule_function</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-symbollookupdate'>set_symbol_lookup_date</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-sid'>sid</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-symbol'>symbol</a>
</li>
<li class='indent2 code'>
<a href='help.html#api-symbols'>symbols</a>
</li>
<li class='indent1'>
<a href='help.html#api-orderobj'>Order object</a>
</li>
<li class='indent1'>
<a href='help.html#api-portfolio'>Portfolio object</a>
</li>
<li class='indent1'>
<a href='help.html#api-position'>Position object</a>
</li>
<li class='indent1'>
<a href='help.html#api-sidinfo'>Equity object</a>
</li>
<li class='indent1'>
<a href='help.html#api-account'>Account object</a>
</li>
<li class='indent1'>
<a href='help.html#api-talib'>TA-Lib methods</a>
</li>
<li class='indent1'>
<a href='help.html#api-common-errors'>Common Error Messages</a>
</li>
<li class='indent1'>
<a href='help.html#api-ide-tips'>IDE Tips and Shortcuts</a>
</li>
<li class='divider no-highlight'></li>
<li>
<a href='help.html#research-env'>Research Environment API</a>
<li class='indent1'>
<a href='help.html#quantopian_research_get_pricing'>get_pricing</a>
</li>
<li class='indent1'>
<a href='help.html#quantopian_research_symbols'>symbols</a>
</li>
<li class='indent1 code'>
<a href='help.html#quantopian_research_local_csv'>local_csv</a>
</li>
<li class='indent1 code'>
<a href='help.html#quantopian_research_get_backtest'>get_backtest</a>
</li>
<li class='indent1 code'>
<a href='help.html#quantopian_research_get_live_results'>get_live_results</a>
</li>
<li class='indent1 code'>
<a href='help.html#quantopian_research_get_fundamentals'>get_fundamentals</a>
</li>
<li class='indent1 code'>
<a href='help.html#quantopian_research_run_pipeline'>run_pipeline</a>
</li>
<li class='indent1 code'>
<a href='help.html#qexec_research_results_AlgorithmResult'>create_full_tear_sheet</a>
</li>
</li>
<li class='divider no-highlight'></li>
<li>
<a href='help.html#sample-algos'>Sample Algorithms</a>
<li class='indent1'>
<a href='help.html#sample-basic'>Basic Algorithm</a>
</li>
<li class='indent1'>
<a href='help.html#sample-schedule-function'>Schedule Function</a>
</li>
<li class='indent1'>
<a href='help.html#sample-pipeline-api'>Pipeline</a>
</li>
<li class='indent2'>
<a href='help.html#using-pipelines'>Using Pipelines</a>
</li>
<li class='indent2'>
<a href='help.html#combining-and-ranking'>Combining and Ranking</a>
</li>
<li class='indent2'>
<a href='help.html#creating-custom-factors'>Creating Custom Factors</a>
</li>
<li class='indent1'>
<a href='help.html#sample-earnings-risk'>Earnings Risk Framework</a>
</li>
<li class='indent1'>
<a href='help.html#sample-fundamentals'>Fundamental Data Algorithm</a>
</li>
<li class='indent1'>
<a href='help.html#sample-meanreversion'>Mean Reversion Algorithm</a>
</li>
<li class='indent1'>
<a href='help.html#sample-multiple'>Multiple Securities</a>
</li>
<li class='indent1'>
<a href='help.html#sample-record'>Record Variables</a>
</li>
<li class='indent1'>
<a href='help.html#sample-csv-1'>Fetcher</a>
</li>
<li class='indent1'>
<a href='help.html#sample-custom-slippage'>Custom Slippage</a>
</li>
<li class='indent1'>
<a href='help.html#sample-talib'>TA-Lib usage</a>
</li>
<li class='indent1'>
<a href='help.html#sample-history'>History</a>
</li>
<li class='indent1'>
<a href='help.html#sample-robinhood'>Robinhood Framework</a>
</li>
</li>
<li class='contact-us no-highlight'>
<a href='cdn-cgi/l/email-protection.html#e88e8d8d8c8a898b83a8999d89869c8798818986c68b8785' target='_blank'>
<button class='btn-primary'>Contact Us</button>
</a>
</li>
</ol>
</div>
<div class='help-content span8'>
<h2 class='first' id='overview'>Quantopian Overview</h2>
<p>Quantopian provides you with everything you need to write a high-quality algorithmic trading strategy. Here, you can do your research using a variety of data sources, test your strategy over historical data, and then test it going forward with live data. Top-performing algorithms will be offered investment allocations, and those algorithm authors will share in the profits.</p>
<h2 id='important-concepts'>Important Concepts</h2>
<p>The Quantopian platform consists of several linked components. The Quantopian Research platform is an IPython notebook environment that is used for research and data analysis during algorithm creation. It is also used for analyzing the past performance of algorithms. The IDE (interactive development environment) is used for writing algorithms and kicking off backtests using historical data. Algorithms can also be executed using live data - either paper trading on Quantopian, or real-money trading through a broker integration. All of these tools use the data provided by Quantopian: US equity price and volumes on a minute basis, US equity corporate fundamentals, and dozens of other integrated data sources.</p>
<p>This section covers each of these components and concepts in greater detail.</p>
<h3 id='overview-datasources'>Data sources</h3>
<p>We have minute-bar historical data for US equities since 2002 up to the most recently completed trading day (data uploaded nightly).</p>
<p>A minute bar is a summary of a security's trading activity for a one-minute period, and gives you the opening price, closing price, high price, low price, and trading volume during that minute. Our US equity set is point-in-time, which is important for backtest accuracy.  Since our event-based system sends trading events to you serially, your algorithm receives accurate historical data without any bias towards the present.</p>
<p>During algorithm simulation, Quantopian uses as-traded prices. That means that when your algorithm asks for a price of a specific asset, it gets the price of that asset at the time of the simulation.</p>
<p>When your algorithm calls for historical price or volume data, it is adjusted for splits, mergers, and dividends as of the current simulation date. In other words, if your algorithm asks for a historical window of prices, and there is a split in the middle of that window, the first part of that window will be adjusted for the split. This adustment is done so that your algorithm can do meaningful calculations using the values in the window.</p>
<p>Quantopian also provides access to <a href='help.html#ide-fundamentals'>fundamental data</a>, free of charge. The data, from Morningstar, consists of over 600 metrics measuring the financial performance of companies and is derived from their public filings. The most common use of this data is to filter down to a sub-set of securities for use in an algorithm. It is common to use the fundamentals metrics within the trading logic of the algorithm.</p>
<p>In addition to pricing and fundamental data, we offer a host of <a href="data.html">3rd party datasets</a>. Combining signals found in a wide variety of datasets is a powerful way to create a high-quality algorithm. The datasets available include market-wide indicators like sentiment analysis, as well as industry-specific indicators like clinical trial data.</p>
<p>Each dataset has a limited set of data available for free; full datasets available for purchase, a la carte, for a monthly fee. The complete list of datasets is available <a href="data.html">here.</a></p>
<p>Our database includes all stocks and ETFs that traded since 2002, even ones that are no longer traded. This is very important because it helps you avoid survivorship bias in your algorithm. Databases that omit securities that are no longer traded ignore bankruptcies and other important events, and lead to false optimism about an algorithm. For example, LEH (Lehman Brothers) is a security in which your algorithm can trade in 2008, even though the company no longer exists today; Lehman's bankruptcy was a major event that affected many algorithms at the time.</p>
<p>Work is under way to incorporate US futures data.  There are many other financial data sources we'd like to incorporate, such as options and non-US markets.  What kind of data sources would you like us to have?  <a href='cdn-cgi/l/email-protection.html#8ceae9e9e8eeedefe7ccfdf9ede2f8e3fce5ede2a2efe3e1'>Let us know.</a></p>
<h3 id='overview-research'>Research Environment</h3>
<p>The research environment is a customized IPython server. With this open-ended platform, you are free to explore new investing ideas. For most people, the hardest part of writing a good algorithm is finding the idea or pricing &quot;edge.&quot; The research environment is the place to do that kind of research and analysis. In the research environment you have access to all of Quantopian's data - price, volume, corporate fundamentals, and third-party integrations.</p>
<p>The research environment is also useful for analyzing the performance of backtests and live trading algorithms. You can load the performance data into research, analyze results, and compare to other algorithms' performances.</p>
<h3 id='overview-ide'>IDE and Backtesting</h3>
<p>The IDE (interactive development environment) is where you write your algorithm. It's also where you kick off backtests. Pressing &quot;Build&quot; will check your code for syntax errors and run a backtest right there in the IDE.  Pressing &quot;Full Backtest&quot; runs a backtest that is saved and accessible for future analysis.</p>
<p>The IDE is covered in more detail <a href='help.html#ide-api'>later in this help document</a>.</p>
<h3 id='overview-papertrading'>Paper Trading</h3>
<p>Paper trading is also sometimes known as walk-forward, or out-of-sample testing.  In paper trading, your algorithm gets live market data (actually, 15-minute delayed data) and 'trades' against the live data with a simulated portfolio. This is a good test for any algorithm. If you inadvertently overfit during your algorithm development process, paper trading will often reveal the problem. You can simulate trades for free, with no risks, against the current market on Quantopian.</p>
<p>Quantopian paper trading uses the same order-fulfillment logic as a regular backtest, including the <a href='help.html#ide-slippage'>slippage model</a>.</p>
<p>Before you can paper trade your algorithm, you must run a full backtest. Go to your algorithm and click the 'Full Backtest' button. Once that backtest is complete, you will see a 'Live Trade Algorithm' button. When you start paper trading, you will be prompted to specify the amount of money used in the strategy. Note that this cash amount is not enforced - it is used solely to calculate your algorithm's returns.</p>
<h3 id='overview-livetrading'>Live Trading</h3>
<p>When you click the Start Trading button, you will have the option to choose 'Broker'.</p>
<p id='broker-overview'>You will need to authenticate to your Interactive Brokers<a href='help.html#ib-disclaimer'>*</a> or Robinhood account. (Note: Quantopian does not store your brokerage password.) For more information about live trading and how to create an IB or Robinhood account, see our <a href="faq.html#live-trading">live trading FAQ</a>.</p>
<p>For IB accounts, we strongly recommend that you run your algorithm against IB's paper trading mode before running it against a real money account. For Robinhood accounts, we recommend that you run your algorithm against <a href='help.html#overview-papertrading'>Quantopian's paper trading</a> mode before running it against a real money account.</p>
<p>Paper trading is a good test to help find lingering bugs. Once you're satisfied with the paper trading performance, you should stop the live algorithm and re-launch it against your real money account.</p>
<p>While your algorithm is live trading, you can continue to make changes in the IDE to experiment with the code and run additional backtests. This will not interfere with the live algorithm. These changes will not apply to your live algo unless you stop the algorithm, run a full backtest with the new code, and redeploy.</p>
<p>If you manually stop a live trading algorithm, this will shutdown the algorithm and prevent it from placing additional orders. This will not liquidate your portfolio and any open orders will be handled by your broker, as usual.</p>
<p>Quantopian's live trading program is still in open beta, and the live trading platform has a number of limitations including different rules for each brokerage. These limitations will be reduced and removed as we keep improving the live trading platform.</p>
<p><strong>General Guidelines & Limitations</strong></p>
<ul>
<li>The live trading platform does not have the capability to do a mid-day recovery from an outage.  If your algo goes down mid-day (whether it's because of our bug, or your bug, or a third party issue) the algorithm won't automatically restart mid-day. If the bug was temporary, the algorithm will start the next day at market open.  On restart, the data windows (in <code>history()</code> and <code>Pipeline</code>) will be filled with the "missing" data that passed during the previous day's outage.</li>
<li>There is no automatic liquidation on algorithm exit.  If you need to liquidate your holdings, you need to do that programatically in your algorithm or in the Interactive Brokers interface.</li>
<li>Like in backtesting, all open orders are cancelled at end of day.  Orders made in the last minute of the trading day will be automatically cancelled.</li>
<li>If your algorithm uses <code>fetch_csv()</code>, it is important that all historical data in your fetched data be accessible and unchanged.  We do not keep a copy of fetched data; it is reloaded at the start of every trading day. If historical data in the fetched file is altered or removed, the algorithm will not run properly. Providing additional, new data in the file for dates in the future is fine. If you are updating the CSV, add new data before midnight Eastern Time so the file is ready for the next trading day.</li>
<li>The use of random() isn't supported because of technical limitations with our start-of-day initialization.</li>
<li>Live trading is limited to accounts based in US dollars. The account can be funded by other currencies, but the base must be US dollars.</li>
<li>Fundamentals data is typically updated on a daily basis. Occasionally data loads fail prior to the start of trading due to technical problems. In these cases, the data forward fills with the last known data point. If your algorithm requires the most recent value, be sure to include a data freshness check. All metrics have an associated as-of date available through the fundamentals API.</li>
<li>New IPO listings often arrive too late for incorporation in the daily trading data feed. IPOs may not be tradeable on their first day, but are generally available for trading on subsequent trading days.</li>
<li>Live trading is initially limited to accounts with a portfolio value of less than $1,000,000.  <a href='cdn-cgi/l/email-protection.html#bfd9dadadbdddedcd4ffcecaded1cbd0cfd6ded191dcd0d2'>Contact us</a> if you would like to trade more than $1,000,000.</li>
</ul>
<p><strong>IB Guidelines & Limitations</strong></p>
<ul>
<li>IB only allows one login at a time per account.  If you try to log into IB during market hours using the same account as Quantopian, Quantopian will automatically try to force you out so that we can keep trading on your behalf.  In general, we recommend that you maintain two logins, one for Quantopian and one for your use.  If you need to log in to IB using the Quantopian login during market hours, you should first stop the algorithm in Quantopian.</li>
<li>If your IB login is terminated, you will need to log back in before trading continues.  This could happen unexpectedly because of a server error, or it could be a planned code upgrade on our part.  If a login is necessary we will contact you.</li>
<li>By default, orders placed through Quantopian use IB's <a href='https://www.interactivebrokers.com/en/index.php?f=1685'>Smart Router</a> algorithm for order execution. You can also specify to route your order to <a href='help.html#exchange-routing'>IEX</a>.</li>
</ul>
<p><strong>Robinhood Guidelines & Limitations</strong></p>
<ul>
<li>Robinhood automatically handles order exchange routing; you will not be able to specify an exchange.</li>
<li>Importing <a href='help.html#api-order-execution'>IB specific modules</a> or IBExchange is not supported. Similar modules for Robinhood do not exist.</li>
<li>The following <a href='help.html#api-account'>account</a> fields are not available and will default to the backtest value: regt_equity, regt_margin, day_trades_remaining, cushion, accrued_interest, excess_liquidity, equity_with_loan, maintenance_margin_requirement, initial_margin_requirement, available_funds, accrued_interest</li>
<li>We recommend that algorithms trading with Robinhood follow a <a href='help.html#sample-robinhood'>framework based off the two guidelines below</a></li>
<ul>
<li>Robinhood only allows long. Orders that attempt to enter into a short position will be rejected by Robinhood. We strongly suggest you run your algorithms with the set_long_only trading guard to prevent you from accidentally running a strategy that depends on short positions.</li>
<li>Cash value is equal to your settled funds plus your unsettled funds - your unsettled funds cannot be used to purchase securities. This means that methods like 'order_target_percent' will attempt to order on the value of your current positions as well as your total cash value (unsettled + settled). In some cases, this will result in unexpected and unwanted behavior. We recommend checking that all your funds have settled before placing any orders in order to prevent any confusion. The best way to do that is to check your buying power against your cash as seen in the <a href='help.html#sample-robinhood'>algorithm framework for Robinhood</a></li>
</ul>
<li>Robinhood margin accounts are currently in beta and are not supported in live trading. Please refer <a href='https://support.robinhood.com/hc/en-us/articles/203640049-Account-types'>to Robinhood's documentation</a> for more information about margin accounts.</li>
<li>For IPOs, please refer to <a href='https://www.quantopian.com/support.robinhood.com'>Robinhood's documentation</a> on trade availability.</li>
</ul>
<p>We are working very hard at testing and improving our software; however, we certainly have software bugs. As members of the open beta, in particular, you need to be alert to any bugs that might affect your trading.  Bug reports are greatly appreciated and we will try to fix them as quickly as possible.</p>
<p>
<i id='ib-disclaimer'><a href='help.html#broker-overview'>*</a> Interactive Brokers LLC is not affiliated with and does not endorse or recommend Quantopian, Inc. Interactive Brokers provides execution and clearing services to customers who integrate their Interactive Brokers account with their Quantopian account. For more information regarding Interactive Brokers LLC, please visit www.interactivebrokers.com.</i>
</p>
<h2 id='security'>Privacy and Security</h2>
<p>We take privacy and security extremely seriously. All trading algorithms and backtest results you generate inside Quantopian are owned by you. You can, of course, choose to share your intellectual property with the community, or choose to grant Quantopian permission to see your code for troubleshooting. We will not access your algorithm without your permission except for unusual cases, such as protecting the platform's security.</p>
<p>Our platform is run on a cloud infrastructure.</p>
<p>Specifically, our security layers include:</p>
<ul>
<li>Never storing your password in plaintext in our database</li>
<li>SSL encryption for the Quantopian application</li>
<li>Secure websocket communication for the backtest data</li>
<li>Encrypting all trading algorithms and other proprietary information before writing them to our database</li>
</ul>
<p>We want to be very transparent about our security measures.  Don't hesitate to <a href='cdn-cgi/l/email-protection.html#ccaaa9a9a8aeadafa78cbdb9ada2b8a3bca5ada2e2afa3a1'>email us</a> with any questions or concerns.</p>
<h3 id='twofactor'>Two-Factor Authentication</h3>
<p>Two-factor authentication (2FA) is a security mechanism to protect your account. When 2FA is enabled, your account requires both a password and an authentication code you generate on your smart phone.</p>
<p>With 2FA enabled, the only way someone can sign into your account is if they know both your password and have access to your phone (or backup codes). We <strong>strongly</strong> urge you to turn on 2FA to protect the safety of your account, especially for live trading.</p>
<p class='bold'>How does it work?</p>
<p>Once you enable 2FA, you will still enter your password as you normally do when logging into Quantopian.  Then you will be asked to enter an authentication code.  This code can be either generated by the Google Authenticator app on your smartphone, or sent as a text message (SMS).</p>
<p>If you lose your phone, you will need to use a backup code to log into your account. It's very important that you get your backup code as soon as you enable 2FA.  If you don't have your phone, and you don't have your backup code, you won't be able to log in.  Make sure to save your backup code in a safe place!</p>
<p>You can setup 2FA via SMS or Google Authenticator, or both. These methods require a smartphone and you can switch between them at any time.  To use the SMS option you need a US-based phone number, beginning with the country code +1.</p>
<p>To configure 2FA via SMS:</p>
<ol>
<li>Go to <a href='https://www.quantopian.com/account?page=twofactor'>Account Settings</a> and click 'Configure via SMS'.</li>
<li>Enter your phone number. Note: Only US-based phone numbers are allowed for the SMS option. Standard messaging rates apply.</li>
<li>You'll receive a 5 or 6 digit security token on your mobile. Enter this code in the pop-on screen to verify your device.  Once verified, you'll need to provide the security token sent via SMS every time you login to Quantopian.</li>
<li>Download your backup login code in case you lose your mobile device. Without your phone and backup code, you will not be able to access your Quantopian account.</li>
</ol>
<p>To configure 2FA via Google Authenticator:</p>
<ol>
<li>Go to <a href='https://www.quantopian.com/account?page=twofactor'>Two-Factor Auth</a> and click 'Configure Google Authenticator'.</li>
<li>If you don’t have Google Authenticator, go to your App Store and download the free app.  Once installed, open the app, click 'Add an Account', then 'Scan a barcode'.</li>
<li>Hold the app up to your computer screen and scan the QR code.  Enter the Quantopian security token from the Google Authenticator app.</li>
<li>Copy your backup login code in case you lose your mobile device. Without your phone and backup code, you will not be able to access your Quantopian account.</li>
</ol>
<p class='bold'>Backup login code</p>
<p>If you lose your phone and can’t login via SMS or Google Authenticator, your last resort is to login using your backup login code. Without your phone and this code, you will not be able to login to your Quantopian account.</p>
<p>To save your backup code:</p>
<ol>
<li>Go to https://www.quantopian.com/account?page=twofactor</li>
<li>Click 'View backup login code'.</li>
<li>Enter your security token received via SMS or on your Google Authenticator app.</li>
<li>Copy your backup code to a safe location.</li>
</ol>
<h2 id='ide'>Developing in the IDE</h2>
<p>Quantopian's Python IDE is where you develop your trading ideas. The standard features (autosave, fullscreen, font size, color theme) help make your experience as smooth as possible.</p>
<p>Your work is automatically saved every 10 seconds, and you can click Save to manually save at any time.  We'll also warn you if you navigate away from the IDE page while there's unsaved content.</p>
<h3 id='ide-api'>Overview</h3>
<p>We have a simple but powerful API for you to use:</p>
<p><code>initialize(context)</code> is a required setup method for initializing state or other bookkeeping. This method is called only once at the beginning of your algorithm. <code>context</code> is an augmented Python dictionary used for maintaining state during your backtest or live trading session. <code>context</code> should be used instead of global variables in the algorithm. Properties can be accessed using dot notation (<code>context.some_property</code>).</p>
<p><code>handle_data(context, data)</code> is an optional method that is called every minute.  Your algorithm uses <code>data</code> to get individual prices and windows of prices for one or more assets. <code>handle_data(context, data)</code> should be rarely used; most algorithm functions should be run in <a href='help.html#ide-schedulefunction'>scheduled functions</a>.</p>
<p><code>before_trading_start(context, data)</code> is an optional method called once a day, before the market opens.  Your algorithm can select securities to trade using <a href='help.html#pipeline-title'>Pipeline</a>, or do other once-per-day calculations.</p>
<p>Your algorithm can have other Python methods. For example, you might have a scheduled function call a utility method to do some calculations.</p>
<p>For more information, jump to the <a href='help.html#api-data-methods'>API Documentation</a> section below.</p>
<h3 id='data-object'>The data object</h3>
<p>The <code>data</code> object gives your algorithm a way to fetch specific open/high/low/close/volume (OHLCV) values, and to fetch historical windows of OHLCV values. It also gives you a way to check if an asset can be traded and/or whether its price data is stale.</p>
<p>The <code>data</code> object knows your algorithm's current time and uses that time for all its internal calculations.</p>
<p>All the methods on <code>data</code> accept a single asset or a list of assets, and the price fetching methods also accept an OHLCV field or a list of OHLCV fields.  The more that your algorithm can batch up queries by passing multiple assets or multiple fields, the faster we can get that data to your algorithm.</p>
<p>Learn about the various methods on the <code>data</code> object in the <a href='help.html#api-data-methods'>API documentation</a> below.</p>
<h3 id='ide-schedulefunction'>Scheduling Functions</h3>
<p>Your algorithm will run much faster if it doesn't have to do work every single minute.  We provide the <code>schedule_function</code> method that lets your algorithm specify when methods are run by using date and/or time rules.  All scheduling must be done from within the <code>initialize</code> method.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  schedule_function(&#x000A;    func=myfunc,&#x000A;    date_rule=date_rules.every_day(),&#x000A;    time_rule=time_rules.market_close(minutes=1),&#x000A;    half_days=True&#x000A;  )</pre>
<p>Monthly modes (<code>month_start</code> and <code>month_end</code>) accept a <code>days_offset</code> parameter to offset the function execution by a specific number of trading days from the beginning and end of the month, respectively.  <strong>In monthly mode, all day calculations are done using trading days.</strong>  If the offset exceeds the number of trading days in a month, the function isn't run during that month.</p>
<p>Weekly modes (<code>week_start</code> and <code>week_end</code>) also accept a <code>days_offset</code> parameter.  If the function execution is scheduled for a market holiday and there is at least one more trading day in the week, the function will run on the next trading day.  <strong>If there are no more trading days in the week, the function is not run during that week.</strong></p>
<p>To schedule a function more frequently, you can use multiple <code>schedule_function</code> calls. For instance,  you can schedule a function to run every 30 minutes, every three days, or at the beginning of the day and the middle of the day.</p>
<p>Scheduled functions are not asynchronous. If two scheduled functions are supposed to run at the same time, they will happen sequentially, in the order in which they were created.</p>
<p><b>Note:</b> The <code>handle_data</code> function runs before any functions scheduled to run in the same minute. Also, scheduled functions have the same timeout restrictions as <code>handle_data</code>, i.e., the total amount of time taken up by <code>handle_data</code> and any scheduled functions for the same minute can't exceed 50 seconds.</p>
<p>Below are the options for date rules and time rules for a function. For more details, go to the <a href='help.html#api-schedulefunction'>API overview</a>.</p>
<img alt="Help-schedulefunction-date" class="help-image" height="213px" src="assets/help-schedulefunction-date-f14d82cc2bb54760be81e32c90a11a45.png" />
<img alt="Help-schedulefunction-timerules" class="help-image" height="213px" src="assets/help-schedulefunction-timerules-b2be3f5597d1e2885750e61980f61e5e.png" />
<h4 class='padding_20t' id='ide-daterules'>Date Rules</h4>
<p class='bold' id='ide-everyday'>Every Day</p>
<p>Runs the function once per trading day. The example below calls <code>myfunc</code> every morning, 15 minutes after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc every day 15 minutes after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.every_day(),&#x000A;    time_rules.market_open(minutes=15)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p class='bold' id='ide-weekstart'>Week Start</p>
<p>Runs the function once per calendar week. By default, the function runs on the first trading day of the week. You can add an optional offset from the start of the week to choose another day. The example below calls <code>myfunc</code> once per week, on the second day of the week, 3 hours and 10 minutes after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc once per week, on the second day of the week,&#x000A;  # 3 hours and 10 minutes after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.week_start(days_offset=1),&#x000A;    time_rules.market_open(hours=3, minutes=10)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p class='bold' id='ide-weekend'>Week End</p>
<p>Runs the function once per calendar week. By default, the function runs on the last trading day of the week. You can add an optional offset, from the end of the week, to choose the trading day of the week. The example below calls <code>myfunc</code> once per week, on the second-to-last day of the week, 1 hour after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc once per week, on the last day of the week,&#x000A;  # 1 hour after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.week_end(days_offset=1),&#x000A;    time_rules.market_open(hours=1)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p class='bold' id='ide-monthstart'>Month Start</p>
<p>Runs the function once per calendar month. By default, the function runs on the first trading day of each month. You can add an optional offset from the start of the month, <strong>counted in trading days</strong> (not calendar days).</p>
<p>The example below calls <code>myfunc</code> once per month, on the second trading day of the month, 30 minutes after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc once per month, on the second day of the month,&#x000A;  # 30 minutes after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.month_start(days_offset=1),&#x000A;    time_rules.market_open(minutes=30)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p class='bold' id='ide-monthend'>Month End</p>
<p>Runs the function once per calendar month. By default, the function runs on the last trading day of each month. You can add an optional offset from the end of the month, <strong>counted in trading days</strong>. The example below calls <code>myfunc</code> once per month, on the third-to-last trading day of the month, 15 minutes after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc once per month, on the last day of the month,&#x000A;  # 15 minutes after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.month_end(days_offset=2),&#x000A;    time_rules.market_open(minutes=15)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<h4 class='padding_20t' id='ide-timerules'>Time Rules</h4>
<p class='bold' id='ide-marketopen'>Market Open</p>
<p>Runs the function at a specific time relative to the market open.  Without a specified offset, the function is run one minute after the market opens.</p>
<p>The example below calls <code>myfunc</code> every day, 1 hour and 20 minutes after the market opens.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc every day, 1 hour and 20 minutes after the market opens&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.every_day(),&#x000A;    time_rules.market_open(hours=1, minutes=20)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p class='bold' id='ide-marketclose'>Market Close</p>
<p>Runs the function at a specific time relative to the market close.  Without a specified offset, the function is run one minute before the market close. The example below calls <code>myfunc</code> every day, 2 minutes before the market close.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will call myfunc every day, 2 minutes before the market closes&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.every_day(),&#x000A;    time_rules.market_close(minutes=2)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<h4 class='padding_20t'>Scheduling Multiple Functions</h4>
<p>More complicated function scheduling can be done by combining <code>schedule_function</code> calls.</p>
<p>Using two calls to <code>schedule_function</code>, a portfolio can be rebalanced at the beginning and middle of each month:</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # execute on the second trading day of the month&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.month_start(days_offset=1)&#x000A;  )&#x000A;&#x000A;  # execute on the 10th trading day of the month&#x000A;  schedule_function(&#x000A;    myfunc,&#x000A;    date_rules.month_start(days_offset=9)&#x000A;  )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass</pre>
<p>To call a function every 30 minutes, use a loop with <code>schedule_function</code>:</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # For every minute available (max is 6 hours and 30 minutes)&#x000A;  total_minutes = 6*60 + 30&#x000A;&#x000A;  for i in range(total_minutes):&#x000A;    # Every 30 minutes run schedule&#x000A;    if i % 30 == 0:&#x000A;      # This will start at 9:31AM and will run every 30 minutes&#x000A;      schedule_function(&#x000A;      myfunc,&#x000A;        date_rules.every_day(),&#x000A;        time_rules.market_open(minutes=i),&#x000A;        True&#x000A;      )&#x000A;&#x000A;def myfunc(context,data):&#x000A;  pass&#x000A;&#x000A;def handle_data(context,data):&#x000A;  pass</pre>
<h3 id='overview-gettingdata'>Getting price data for securities</h3>
<p>One of the most common actions your algorithm will do is fetch price and volume information for one or more securities.  Quantopian lets you get this data for a specific minute, or for a window of minutes.</p>
<p>To get data for a specific minute, use <code>data.current</code> and pass it one or more securities and one or more fields.  <strong>The data returned will be the as-traded values.</strong></p>
<p><code>data.current</code> can also be used to find the last minute in which an asset traded, by passing <code>'last_traded'</code> as the field name</p>
<p>To get data for a window of time, use <code>data.history</code> and pass it one or more assets, one or more fields, '1m' or '1d' for granularity of data, and the number of bars.  <strong>The data returned will be adjusted for splits, mergers, and dividends as of the current simulation time.</strong></p>
<p>Important things to know:</p>
<ul>
<li><code>price</code> is forward-filled, returning last known price, if there is one.  Otherwise, <code>NaN</code> is returned.</li>
<li><code>volume</code> returns 0 if the security didn't trade or didn't exist during a given minute.</li>
<li>For <code>open</code>, <code>high</code>, <code>low</code>, and <code>close</code>, a <code>NaN</code> is returned if the security didn't trade or didn't exist at the given minute.</li>
<li>Don't save the results of <code>data.history</code> from one day to the next. Your history call today is price-adjusted relative to today, and your history call from yesterday was adjusted relative to yesterday. </li>
</ul>
<p>To read about all the details, go to the API documentation.</p>
<h3 id='ide-history'>History</h3>
<div class='markdown-generated'>
<p>In many strategies, it is useful to compare the most recent bar data to previous bars.  The Quantopian platform provides utilities to easily access and perform calculations on recent history. </p>

<p>When your algorithm calls <code>history</code>, the returned data is adjusted for splits, mergers, and dividends as of the current simulation date. In other words, when your algorithm asks for a historical window of prices, and there is a split in the middle of that window, the first part of that window will be adjusted for the split. This adustment is done so that your algorithm can do meaningful calculations using the values in the window.</p>

<p>This code queries the last 20 days of price history for a static set of securities.  Specifically, this returns the closing daily price for the last 20 days, including the current price for the current day. Prices are split- and dividend-adjusted as of the current date in the simulation:</p>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.assets = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    price_history = data.history(context.assets, &quot;price&quot;, 20, &quot;1d&quot;)&#x000A;</code></pre>

<p>The bar_count field specifies the number of days or minutes to include in the DataFrame returned by the history function. This parameter accepts only integer values.</p>

<p>The frequency field specifies how often the data is sampled: daily or minutely.  Acceptable inputs are ‘1d’ or ‘1m’. For other frequencies, use the pandas <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.resample.html">resample</a> function.</p>

<h4>Examples</h4>

<p>Below are examples of code along with explanations of the data returned.</p>

<h5>Daily History</h5>

<p>Use &quot;1d&quot; for the frequency.  The dataframe returned is always in daily bars. The bars never span more than one trading day.  The last bar, if partial, is built using the minutes of the day.</p>

<p>Examples (assuming <code>context.assets</code> exists):</p>

<ul>
<li><code>history(context.assets, &quot;price&quot;, 1, &quot;1d&quot;)</code> returns the current price.</li>
<li><code>history(context.assets, &quot;volume&quot;, 1, &quot;1d&quot;)</code> returns the volume since the current day&#39;s open, even if it is partial.</li>
<li><code>history(context.assets, &quot;price&quot;, 2, &quot;1d&quot;)</code> returns yesterday&#39;s close price and the current price.</li>
<li><code>history(context.assets, &quot;price&quot;, 6, &quot;1d&quot;)</code> returns the prices for the previous 5 days and the current price.</li>
</ul>

<p>Partial trading days are treated as a single day unit. Scheduled half day sessions, unplanned early closures for unusual circumstances, and other truncated sessions are each treated as a single trading day.</p>

<h5>Minute History</h5>

<p>Use &quot;1m&quot; for the frequency.  </p>

<p>Examples (assuming <code>context.assets</code> exists):</p>

<ul>
<li><code>history(context.assets, &quot;price&quot;, 1, &quot;1m&quot;)</code> returns the current price.</li>
<li><code>history(context.assets, &quot;price&quot;, 2, &quot;1m&quot;)</code> returns the previous minute&#39;s close price and the current price.</li>
<li><code>history(context.assets, &quot;volume&quot;, 60, &quot;1m&quot;)</code> returns the volume for the previous 60 minutes.<br></li>
</ul>

<h4>Returned Data</h4>

<p>If a single security and a single field were passed into <code>history</code>, a pandas Series is returned, indexed by date.</p>

<p>If multiple securities and single field are passed in, the returned pandas DataFrame is indexed by date, and has assets as columns.</p>

<p>If a single security and multiple fields are passed in, the returned pandas DataFrame is indexed by date, and has fields as columns.</p>

<p>If multiple assets and multiple fields are passed in, the returned pandas Panel is indexed by field, has date as the major axis, and securities as the minor axis.</p>

<p>All pricing data is split- and dividend-adjusted as of the current date in the simulation or live trading. As a result, pricing data returned by <code>data.history()</code> should not be stored and past the end of the day on which it was retreived, as it may no longer be correctly adjusted.</p>

<p><strong>&quot;price&quot; is always forward-filled.  The other fields (&quot;open&quot;, &quot;high&quot;, &quot;low&quot;, &quot;close&quot;, &quot;volume&quot;) are never forward-filled.</strong></p>

<h4>History and Backtest Start</h4>

<p>Quantopian&#39;s price data starts on Jan 2, 2002.  Any <code>history</code> call that extends before that date will raise an exception.</p>

<h4>Common Usage: Current and Previous Bar</h4>

<p>A common use case is to compare yesterday&#39;s close price with the current price.</p>

<p>This example compares yesterday&#39;s close (labeled prev_bar) with the current price (labeled curr_bar) and places an order for 20 shares if the current price is above yesterday&#39;s closing price.</p>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    price_history = data.history(context.securities, &quot;price&quot;, bar_count=2, frequency=&quot;1d&quot;)&#x000A;    for s in context.securities:&#x000A;        prev_bar = price_history[s][-2]&#x000A;        curr_bar = price_history[s][-1]&#x000A;        if curr_bar &gt; prev_bar:&#x000A;            order(s, 20)&#x000A;</code></pre>

<h4>Common Usage: Looking Back X Bars</h4>

<p>It can also be useful to look further back into history for a comparison.  Computing the percent change over given historical time frame requires the starting and ending price values only, and ignores intervening prices.</p>

<p>The following example operates over AAPL and TSLA.  It passes both securities into <code>history</code>, getting back a pandas Series.</p>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    prices = data.history(context.securities, &quot;price&quot;, bar_count=10, frequency=&quot;1d&quot;)&#x000A;    pct_change = (prices.ix[-1] - prices.ix[0]) / prices.ix[0]&#x000A;    log.info(pct_change)&#x000A;</code></pre>

<p>Alternatively, leveraging the following <code>iloc</code> pandas DataFrame function, which returns the first and last values as a pair:</p>

<pre><code>price_history.iloc[[0, -1]]&#x000A;</code></pre>

<p>The percent change example can be re-written as:</p>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    prices = data.history(context.securities, &quot;price&quot;, bar_count=10, frequency=&quot;1d&quot;)&#x000A;    pct_change = price_history.iloc[[0, -1]].pct_change()&#x000A;    log.info(pct_change)&#x000A;</code></pre>

<p>To find the difference between the values, the code example can be written as:</p>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    prices = data.history(context.securities, &quot;price&quot;, bar_count=10, frequency=&quot;1d&quot;)&#x000A;    diff = price_history.iloc[[0, -1]].diff()&#x000A;    log.info(diff)&#x000A;</code></pre>

<h4>Common Usage: Rolling Transforms</h4>

<p>Rolling transform calculations such as mavg, stddev, etc. can be calculated via methods provided by pandas.</p>

<ul>
<li>mavg -> <a href="http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.mean.html">DataFrame.mean</a></li>
<li>stddev -> <a href="http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.std.html">DataFrame.std</a></li>
<li>vwap -> <a href="http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.sum.html">DataFrame.sum</a>, for volume and price</li>
</ul>

<h4>Common Usage: Moving Average</h4>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    price_history = data.history(context.securities, &quot;price&quot;, bar_count=5, frequency=&quot;1d&quot;)&#x000A;    log.info(price_history.mean())&#x000A;</code></pre>

<h4>Common Usage: Standard Deviation</h4>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def handle_data(context, data):&#x000A;    price_history = data.history(context.securities, &quot;price&quot;, bar_count=5, frequency=&quot;1d&quot;)&#x000A;    log.info(price_history.std())&#x000A;</code></pre>

<h4>Common Usage: VWAP</h4>

<pre><code>def initialize(context):&#x000A;    # AAPL, MSFT, and SPY&#x000A;    context.securities = [sid(24), sid(5061), sid(8554)]&#x000A;&#x000A;def vwap(prices, volumes):&#x000A;    return (prices * volumes).sum() / volumes.sum()&#x000A;&#x000A;def handle_data(context, data):&#x000A;    hist = data.history(context.securities, [&quot;price&quot;, &quot;volume&quot;], 30, &#39;1d&#39;)&#x000A;&#x000A;    vwap_15 = vwap(hist[&quot;price&quot;][-15:], hist[&quot;volume&quot;][-15:])&#x000A;    vwap_30 = vwap(hist[&quot;price&quot;], hist[&quot;volume&quot;])&#x000A;&#x000A;    for s in context.securities:&#x000A;        if vwap_15[s] &gt; vwap_30[s]:&#x000A;            order(s, 50)&#x000A;</code></pre>

<h4>Common Usage: Using An External Library</h4>

<p>Since <code>history</code> can return a pandas DataFrame, the values can then be passed to libraries that operate on numpy and pandas data structures.</p>

<p>An example OLS strategy:</p>

<pre><code>import statsmodels.api as sm&#x000A;&#x000A;def ols_transform(prices, sec1, sec2):&#x000A;    &quot;&quot;&quot;&#x000A;    Computes regression coefficients (slope and intercept)&#x000A;    via Ordinary Least Squares between two securities.&#x000A;    &quot;&quot;&quot;&#x000A;    p0 = prices[sec1]&#x000A;    p1 = sm.add_constant(prices[sec2], prepend=True)&#x000A;    return sm.OLS(p0, p1).fit().params&#x000A;&#x000A;def initialize(context):&#x000A;    # KO&#x000A;    context.sec1 = sid(4283)&#x000A;    # PEP&#x000A;    context.sec2 = sid(5885)&#x000A;&#x000A;def handle_data(context, data):&#x000A;    price_history = data.history([context.sec1, context.sec2], &quot;price&quot;, bar_count=30, frequency=&quot;1d&quot;)&#x000A;    intercept, slope = ols_transform(price_history, context.sec1, context.sec2)&#x000A;</code></pre>

<h4>Common Usage: Using TA-Lib</h4>

<p>Since <code>history</code> can return a pandas Series, that Series can be passed to TA-Lib.</p>

<p>An example EMA calculation:</p>

<pre><code># Python TA-Lib wrapper&#x000A;# https://github.com/mrjbq7/ta-lib&#x000A;import talib&#x000A;&#x000A;def initialize(context):&#x000A;    # AAPL&#x000A;    context.my_stock = sid(24)&#x000A;&#x000A;def handle_data(context, data):&#x000A;    my_stock_series = data.history(context.my_stock, &quot;price&quot;, bar_count=30, frequency=&quot;1d&quot;)&#x000A;    ema_result = talib.EMA(my_stock_series, timeperiod=12)&#x000A;    record(ema=ema_result[-1])&#x000A;</code></pre>

</div>
<h3 id='ide-ordering'>Ordering</h3>
<p>Call <code>order(security, amount)</code> to place a simple market order.  <code>security</code> is the security you wish to trade, and the amount is the number of shares you want to buy. Use a negative amount in order to sell.  The method returns an order id that can be used to track the order's status.  The <a href='faq.html#backtester'>FAQ</a> has more detailed information about how orders are handled and filled by the backtester.</p>
<p>Ordering a delisted security is an error condition; so is ordering a security before an IPO. To check if a stock can be traded at a given point in your algorithm, use <code>data.can_trade</code>, which returns <code>True</code> if the security is alive and has traded at least once.  For example, on the day a security IPOs, <code>can_trade</code> will return <code>False</code> until trading actually starts, often several hours after the market open.</p>
<p>Since Quantopian forward-fills price, your algorithm might need to know if the price for a security is from the most recent minute.  The <code>data.is_stale</code> method returns <code>True</code> if the asset is alive but the latest price is from a previous minute.</p>
<p>Quantopian supports four different order types:</p>
<ul>
<li><strong>market order</strong>: <code>order(security, amount)</code> will place a simple market order.</li>
<li><strong>limit order</strong>: Use <code>order(security, amount, style=LimitOrder(price))</code> to place a limit order. A limit order executes at the specified price or better, if the price is reached.</li>
<i>Note: order(security, amount, limit_price=price) is old syntax and will be deprecated in the future.</i>
<br>
<br>
<li><strong>stop order</strong>: Call <code>order(security, amount, style=StopOrder(price))</code> to place a stop order (also known as a stop-loss order). When the specified price is hit, the order converts into a market order.</li>
<i>Note: order(security, amount, stop_price=price) is old syntax and will be deprecated in the future.</i>
<br>
<br>
<li><strong>stop-limit order</strong>: Call <code>order(security, amount, style=StopLimitOrder(limit_price, stop_price))</code> to place a stop-limit order. When the specified stop price is hit, the order converts into a limit order.</li>
<i>Note: order(security, amount, limit_price=price1, stop_price=price2) is old syntax and will be deprecated in the future.</i>
</ul>
<p><strong>All open orders are cancelled at the end of the day, both in backtesting and live trading.</strong></p>
<p>You can see the status of a specific order by calling <code>get_order(order)</code>. Here is a code example that places an order, stores the order_id, and uses the id on subsequent calls to log the order amount and the amount filled:</p>
<pre class='prettyprint margin_50l'># place a single order at market open.  &#x000A;if context.ordered == True:  &#x000A;    context.order_id = order_value(context.aapl, 1000000) &#x000A;    context.ordered = False &#x000A; &#x000A;# retrieve the order placed in the first bar  &#x000A;context.order_id = get_order(context.order_id)  &#x000A;if aapl_order:  &#x000A;    # log the order amount and the amount that is filled  &#x000A;    message = 'Order for {amount} has {filled} shares filled.'  &#x000A;    message = message.format(amount=aapl_order.amount, filled=aapl_order.filled)  &#x000A;    log.info(message)</pre>
<p>If your algorithm is using a stop order, you can check the stop status in the <code>stop_reached</code> attribute of the order ID:</p>
<pre class='prettyprint margin_50l'># Monitor open orders and check is stop order triggered  &#x000A;for stock in context.secs:    &#x000A;      &#x000A;      #check if we have any open orders queried by order id    &#x000A;      ID = context.secs[stock]    &#x000A;      order_info = get_order(ID)    &#x000A;&#x000A;      # If we have orders, then check if stop price is reached    &#x000A;      if order_info:      &#x000A;        CheckStopPrice = order_info.stop_reached      &#x000A;          if CheckStopPrice: log.info(('Stop price triggered for stock %s') % (stock.symbol)</pre>
<p>You can see a list of all open orders by calling <code>get_open_orders()</code>.  This example logs all the open orders across all securities:</p>
<pre class='prettyprint margin_50l'># retrieve all the open orders and log the total open amount  &#x000A;    # for each order  &#x000A;    open_orders = get_open_orders()  &#x000A;    # open_orders is a dictionary keyed by sid, with values that are lists of orders.  &#x000A;    if open_orders:  &#x000A;        # iterate over the dictionary  &#x000A;        for security, orders in open_orders.iteritems():  &#x000A;            # iterate over the orders  &#x000A;            for oo in orders:  &#x000A;                message = 'Open order for {amount} shares in {stock}'  &#x000A;                message = message.format(amount=oo.amount, stock=security)  &#x000A;                log.info(message)</pre>
<p>If you want to see the open orders for a specific stock, you can specify the security like: <code>get_open_orders(sid(24))</code>. Here is an example that iterates over open orders in one stock:</p>
<pre class='prettyprint margin_50l'># retrieve all the open orders and log the total open amount  &#x000A;    # for each order  &#x000A;    open_aapl_orders = get_open_orders(context.aapl)  &#x000A;    # open_aapl_orders is a list of order objects.  &#x000A;    # iterate over the orders in aapl  &#x000A;    for oo in open_aapl_orders:  &#x000A;        message = 'Open order for {amount} shares in {stock}'  &#x000A;        message = message.format(amount=oo.amount, stock=security)  &#x000A;        log.info(message)</pre>
<p>Orders can be cancelled by calling <code>cancel_order(order)</code>. Orders are cancelled asynchronously.</p>
<p class='bold' id='exchange-routing'>Exchange Routing</p>
<p>
In live trading with Interactive Brokers (IB), you can specify if you want your order routed to exchanges via IB’s 
<a href='http://ibkb.interactivebrokers.com/article/728' target='_blank'>Smart Routing</a>
or to be routed to IEX. By default, orders will use IB’s Smart Routing method.
</p>
<p>To route your order to IEX, you need to first import <code>IBExchange</code> from <code>brokers.ib</code>.  Then, in your order function, you can pass <code>exchange=IBExchange.IEX</code> into the order style parameter. For example, <code>order(symbol('AAPL'), 100, style=MarketOrder(exchange=IBExchange.IEX))</code> will send a market order to IEX for 100 shares of Apple.</p>
<p>Order styles supported for routing to IEX:</p>
<ul>
<li>MarketOrder</li>
<li>LimitOrder</li>
<li>StopOrder</li>
<li>StopLimitOrder</li>
</ul>
<p>Below is a full code example:</p>
<pre class='prettyprint margin_50l'>from brokers.ib import IBExchange&#x000A;&#x000A;def initialize(context):&#x000A;    pass&#x000A;&#x000A;def handle_data(context, data):&#x000A;    # Explicitly setting exchange to IEX &#x000A;    order(symbol('AAPL'), 100, style=MarketOrder(exchange=IBExchange.IEX))&#x000A;&#x000A;    # Explicitly setting exchange to SMART.  This is the default behavior if no exchange is passed.&#x000A;    order(symbol('IBM'), 100, style=LimitOrder(10, exchange=IBExchange.SMART))</pre>
<h3 id='ide-portfolio'>Viewing Portfolio State</h3>
<p>Your current portfolio state is accessible from the <code>context</code> object in <code>handle_data</code>:</p>
<img alt="Help-portfolio" class="help-image" height="213px" src="assets/help-portfolio-b5ff87319ff800a60959bc6f64c1d1ce.png" />
<p>To view an individual position's information, use the <code>context.portfolio.positions</code> dictionary:</p>
<img alt="Help-positions" class="help-image" height="133px" src="assets/help-positions-2702d504dd981734f91efa382a401191.png" />
<p>Details on the portfolio and position properties can be found in the API documentation below.</p>
<h3 id='pipeline-title'>
Pipeline
</h3>
<div id='pipeline-overview'>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <p>Many trading algorithms are variations on the following structure:</p>
<ol class="arabic simple">
<li>For each asset in a known (large) universe, compute <strong>N</strong> scalar values for
the asset based on a trailing window of data.</li>
<li>Select a smaller &#8220;tradeable universe&#8221; of assets based on the values computed
in <strong>(1)</strong>.</li>
<li>Calculate desired portfolio weights on the trading universe computed in
<strong>(2)</strong>.</li>
<li>Place orders to move the algorithm&#8217;s current portfolio allocations to the
desired weights computed in <strong>(3)</strong>.</li>
</ol>
<p>The <strong>Pipeline API</strong> module provides a framework for expressing this style of
algorithm.</p>
<p>Users interact with the Pipeline by creating and registering objects that
represent <strong>stages of a computational pipeline</strong>.  Quantopian&#8217;s internal
machinery compiles these objects into a <a class="reference external" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph</a> and feeds
them into an optimizing compute engine to be processed efficiently.</p>


        </div>
      </div>
    </div>

  <script type="text/javascript">/* <![CDATA[ */(function(d,s,a,i,j,r,l,m,t){try{l=d.getElementsByTagName('a');t=d.createElement('textarea');for(i=0;l.length-i;i++){try{a=l[i].href;s=a.indexOf('/cdn-cgi/l/email-protection');m=a.length;if(a&&s>-1&&m>28){j=28+s;s='';if(j<m){r='0x'+a.substr(j,2)|0;for(j+=2;j<m&&a.charAt(j)!='X';j+=2)s+='%'+('0'+('0x'+a.substr(j,2)^r).toString(16)).slice(-2);j++;s=decodeURIComponent(s)+a.substr(j,m-j)}t.innerHTML=s.replace(/</g,'&lt;').replace(/>/g,'&gt;');l[i].href='mailto:'+t.value}}catch(e){}}}catch(e){}})(document);/* ]]> */</script></body>
</html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="basic-usage">
<h1>Basic Usage</h1>
<p>It&#8217;s easiest to understand the basic concepts of the Pipeline API after walking
through an example.</p>
<p>In the algorithm below, we use the Pipeline API to describe a computation
producing 10-day and 30-day <a class="reference external" href="http://www.investopedia.com/terms/s/sma.asp">Simple Moving Averages</a> of close price for every
stock in Quantopian&#8217;s database.  We then specify that we want to filter down
each day to just stocks with a 10-day average price of $5.00 or less. Finally,
in our <cite>before_trading_start</cite>, we print the first five rows of our results.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quantopian.algorithm</span> <span class="kn">import</span> <span class="n">attach_pipeline</span><span class="p">,</span> <span class="n">pipeline_output</span>
<span class="kn">from</span> <span class="nn">quantopian.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">quantopian.pipeline.data.builtin</span> <span class="kn">import</span> <span class="n">USEquityPricing</span>
<span class="kn">from</span> <span class="nn">quantopian.pipeline.factors</span> <span class="kn">import</span> <span class="n">SimpleMovingAverage</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>

    <span class="c"># Create and attach an empty Pipeline.</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">attach_pipeline</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>

    <span class="c"># Construct Factors.</span>
    <span class="n">sma_10</span> <span class="o">=</span> <span class="n">SimpleMovingAverage</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">sma_30</span> <span class="o">=</span> <span class="n">SimpleMovingAverage</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

    <span class="c"># Construct a Filter.</span>
    <span class="n">prices_under_5</span> <span class="o">=</span> <span class="p">(</span><span class="n">sma_10</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>

    <span class="c"># Register outputs.</span>
    <span class="n">pipe</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sma_10</span><span class="p">,</span> <span class="s">&#39;sma_10&#39;</span><span class="p">)</span>
    <span class="n">pipe</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sma_30</span><span class="p">,</span> <span class="s">&#39;sma_30&#39;</span><span class="p">)</span>

    <span class="c"># Remove rows for which the Filter returns False.</span>
    <span class="n">pipe</span><span class="o">.</span><span class="n">set_screen</span><span class="p">(</span><span class="n">prices_under_5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">before_trading_start</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c"># Access results using the name passed to `attach_pipeline`.</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pipeline_output</span><span class="p">(</span><span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">results</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="c"># Define a universe with the results of a Pipeline.</span>
    <span class="c"># Take the first ten assets by 30-day SMA.</span>
    <span class="n">update_universe</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;sma_30&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>On each <code class="docutils literal"><span class="pre">before_trading_start</span></code> call, our algorithm will print a
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v0.18.1)"><code class="xref py py-class docutils literal"><span class="pre">pandas.DataFrame</span></code></a> containing data like this:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="26%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">index</th>
<th class="head">sma_10</th>
<th class="head">sma_30</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Equity(21 [AAME])</td>
<td>2.012222</td>
<td>1.964269</td>
</tr>
<tr class="row-odd"><td>Equity(37 [ABCW])</td>
<td>1.226000</td>
<td>1.131233</td>
</tr>
<tr class="row-even"><td>Equity(58 [SERV])</td>
<td>2.283000</td>
<td>2.309255</td>
</tr>
<tr class="row-odd"><td>Equity(117 [AEY])</td>
<td>3.150200</td>
<td>3.333067</td>
</tr>
<tr class="row-even"><td>Equity(225 [AHPI])</td>
<td>4.286000</td>
<td>4.228846</td>
</tr>
</tbody>
</table>
<p>We can break our example algorithm into five parts:</p>
<div class="contents first-example-links local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="help.html#initializing-a-pipeline" id="id1">Initializing a Pipeline</a></li>
<li><a class="reference internal" href="help.html#importing-datasets" id="id2">Importing Datasets</a></li>
<li><a class="reference internal" href="help.html#building-computations" id="id3">Building Computations</a></li>
<li><a class="reference internal" href="help.html#adding-computations-to-a-pipeline" id="id4">Adding Computations to a Pipeline</a></li>
<li><a class="reference internal" href="help.html#using-results" id="id5">Using Results</a></li>
</ul>
</div>
<div class="section" id="initializing-a-pipeline">
<h2>Initializing a Pipeline</h2>
<p>The first step of any algorithm using the Pipeline API is to create and
register an empty <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.Pipeline" title="quantopian.pipeline.Pipeline"><code class="xref py py-class docutils literal"><span class="pre">Pipeline</span></code></a> object.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quantopian.algorithm</span> <span class="kn">import</span> <span class="n">attach_pipeline</span><span class="p">,</span> <span class="n">pipeline_output</span>
<span class="kn">from</span> <span class="nn">quantopian.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
    <span class="n">attach_pipeline</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A <code class="xref py py-class docutils literal"><span class="pre">Pipeline</span></code> is an object that represents computation we would like to
perform every day.  A freshly-constructed pipeline is empty, which means it
doesn&#8217;t yet know how to compute anything, and it won&#8217;t produce any values if we
ask for its outputs.  We&#8217;ll see below how to provide our Pipeline with
expressions to compute.</p>
<p>Just constructing a new pipeline doesn&#8217;t do anything by itself: we have to tell
our algorithm to use the new pipeline, and we have to provide a name for the
pipeline so that we can identify it later when we ask for results.  The
<code class="xref py py-func docutils literal"><span class="pre">attach_pipeline()</span></code> function from <code class="xref py py-mod docutils literal"><span class="pre">quantopian.algorithm</span></code> accomplishes
both of these tasks.</p>
</div>
<div class="section" id="importing-datasets">
<h2>Importing Datasets</h2>
<p>Before we can build computations for our pipeline to execute, we need a way to
identify the inputs to those computations.  In our example, we&#8217;ll use data from
the <code class="xref py py-class docutils literal"><span class="pre">USEquityPricing</span></code> dataset, which
we import from <code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.builtin</span></code>.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quantopian.pipeline.data.builtin</span> <span class="kn">import</span> <span class="n">USEquityPricing</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">USEquityPricing</span></code> is an example of a <code class="xref py py-class docutils literal"><span class="pre">DataSet</span></code>.
The most important thing to understand about DataSets is that <strong>they do not
hold actual data</strong>.  DataSets are simply collections of objects that tell the
Pipeline API where and how to find the inputs to computations.  Since these
objects often correspond to database columns, we refer to the attributes of
<code class="docutils literal"><span class="pre">DataSets</span></code> as <code class="docutils literal"><span class="pre">columns</span></code>.</p>
<p>USEquityPricing provides five columns:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">USEquityPricing.open</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">USEquityPricing.high</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">USEquityPricing.low</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">USEquityPricing.close</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">USEquityPricing.volume</span></code></li>
</ul>
<p>Many datasets besides <code class="docutils literal"><span class="pre">USEquityPricing</span></code> are available on Quantopian.  These
include corporate fundamental data, news sentiment, macroeconomic indicators,
and more. All datasets are namespaced by provider under
<code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data</span></code>.</p>
<p>Pipeline-compatible datasets are currently importable from the following
modules:</p>
<ul class="simple">
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.accern</span></code> (<a class="reference external" href="https://www.quantopian.com/data/accern">Accern</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.estimize</span></code> (<a class="reference external" href="https://www.quantopian.com/data/estimize">Estimize</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.eventVestor</span></code> (<a class="reference external" href="https://www.quantopian.com/data/eventvestor">EventVestor</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.morningstar</span></code> (<a class="reference external" href="help.html#ide-fundamentals">Morningstar</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.psychsignal</span></code> (<a class="reference external" href="https://www.quantopian.com/data/psychsignal">PsychSignal</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.quandl</span></code> (<a class="reference external" href="https://www.quantopian.com/data/quandl">Quandl</a>)</li>
<li><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.sentdex</span></code> (<a class="reference external" href="https://www.quantopian.com/data/sentdex">Sentdex</a>)</li>
</ul>
<p>Example algorithms and notebooks for working with each of these datasets can be
found on the <a class="reference external" href="data.html">Quantopian Data</a> page.</p>
</div>
<div class="section" id="building-computations">
<h2>Building Computations</h2>
<p>Once we&#8217;ve imported the datasets we intend to use in our algorithm, our next
step is to build the transformations we want our Pipeline to compute each day.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="n">sma_10</span> <span class="o">=</span> <span class="n">SimpleMovingAverage</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">sma_30</span> <span class="o">=</span> <span class="n">SimpleMovingAverage</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.SimpleMovingAverage" title="quantopian.pipeline.factors.SimpleMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">SimpleMovingAverage</span></code></a> class used here
is an example of a <a class="reference external" href="http://www.zipline.io/appendix.html#zipline.pipeline.factors.Factor" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a>.  Factors, in the
Pipeline API, are <strong>objects that represent reductions on trailing windows of
data</strong>.  Every Factor stores four pieces of state:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">inputs</span></code>: A list of <code class="xref py py-class docutils literal"><span class="pre">BoundColumn</span></code> objects
describing the inputs to the Factor.</li>
<li><code class="docutils literal"><span class="pre">window_length</span></code> : An integer describing how many rows of historical data
the Factor needs to be provided each day.</li>
<li><code class="docutils literal"><span class="pre">dtype</span></code>: A numpy <code class="docutils literal"><span class="pre">dtype</span></code> object representing the type of values computed
by the Factor.  Most factors are of dtype <code class="docutils literal"><span class="pre">float64</span></code>, indicating that they
produce numerical values represented as 64-bit floats.  Factors can also be
of dtype <code class="docutils literal"><span class="pre">datetime64[ns]</span></code>.</li>
<li>A <code class="docutils literal"><span class="pre">compute</span></code> function that operates on the data described by <code class="docutils literal"><span class="pre">inputs</span></code> and
<code class="docutils literal"><span class="pre">window_length</span></code>.</li>
</ol>
<div class="pipeline-vwap figure align-right" style="width: 50%">
<a class="reference internal image-reference" href="assets/help_pipeline_vwap.svg"><img alt="Volume-Weighted Average Price" src="assets/help_pipeline_vwap.svg" width="100%" /></a>
<div class="legend">
Example Factor: Volume-Weighted Average Price</div>
</div>
<p>When we compute a <a class="reference external" href="http://www.zipline.io/appendix.html#zipline.pipeline.factors.Factor" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> for a day on which
we have <code class="docutils literal"><span class="pre">N</span></code> assets in our database, the underlying Pipeline API engine
provides that Factor&#8217;s <code class="docutils literal"><span class="pre">compute</span></code> function a two-dimensional array of shape
<code class="docutils literal"><span class="pre">(window_length</span> <span class="pre">x</span> <span class="pre">N)</span></code> for each input in <code class="docutils literal"><span class="pre">inputs</span></code>.  The job of the compute
function is to produce a one-dimensional array of length <code class="docutils literal"><span class="pre">N</span></code> as an output.</p>
<p>The figure to the right shows the computation performed on a single day by
another built-in Factor, <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.VWAP" title="quantopian.pipeline.factors.VWAP"><code class="xref py py-class docutils literal"><span class="pre">VWAP</span></code></a>.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="n">prices_under_5</span> <span class="o">=</span> <span class="p">(</span><span class="n">sma_10</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The next line of our example algorithm constructs a
<a class="reference external" href="http://www.zipline.io/appendix.html#zipline.pipeline.filters.Filter" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a>.  Like Factors, Filters are
reductions over input data defined by datasets.  The difference between Filters
and Factors is that Filters produce <strong>boolean-valued</strong> outputs, whereas Factors
produce <strong>numerical-</strong> or <strong>datetime-valued</strong> outputs.  The expression
<code class="docutils literal"><span class="pre">(sma_10</span> <span class="pre">&lt;</span> <span class="pre">5)</span></code> uses <a class="reference external" href="https://docs.python.org/2/reference/datamodel.html#object.__lt__">Operator Overloading</a> to construct a Filter instance
whose <code class="docutils literal"><span class="pre">compute</span></code> is equivalent to &#8220;compute 10-day moving average price for
each asset, then return an array containing <code class="docutils literal"><span class="pre">True</span></code> for all assets whose
computed value was less than 5, otherwise containing <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>Quantopian provides a library of <a class="reference external" href="help.html#built-in-factors">factors</a> (SimpleMovingAverage, RSI, VWAP and
MaxDrawdown) which will continue to grow. You can also create custom factors.
See the <a class="reference external" href="help.html#pipeline-samples">examples</a>, and <a class="reference external" href="help.html#pipeline-api">API Documentation</a> for more information.</p>
</div>
<div class="section" id="adding-computations-to-a-pipeline">
<h2>Adding Computations to a Pipeline</h2>
<p>Pipelines support two broad classes of operations: <strong>adding new columns</strong> and
<strong>screening out unwanted rows</strong>.</p>
<p>To add a new column, we call the <code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> method of our pipeline with a
Filter or Factor and a name for the column to be created.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="n">pipe</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sma_10</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;sma_10&#39;</span><span class="p">)</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sma_30</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;sma_30&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These calls to <code class="docutils literal"><span class="pre">add</span></code> tell our pipeline to compute a 10-day SMA with the name
<code class="docutils literal"><span class="pre">&quot;sma_10&quot;</span></code> and our 30-day SMA with the name <code class="docutils literal"><span class="pre">&quot;sma_30&quot;</span></code>.</p>
<p>The other important operation supported by pipelines is screening out unwanted
rows our final results.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="n">pipe</span><span class="o">.</span><span class="n">set_screen</span><span class="p">(</span><span class="n">prices_under_5</span><span class="p">)</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal"><span class="pre">set_screen</span></code> informs our pipeline that each day we want to throw
away any rows for whose assets our <code class="docutils literal"><span class="pre">prices_under_5</span></code> Filter produced a value
of <code class="docutils literal"><span class="pre">False</span></code>.</p>
</div>
<div class="section" id="using-results">
<h2>Using Results</h2>
<p>By the end of our <code class="docutils literal"><span class="pre">initialize</span></code> function, we&#8217;ve already defined the core logic
of our algorithm.  All that remains to be done is to ask for the results of the
pipeline attached to our algorithm.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">before_trading_start</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pipeline_output</span><span class="p">(</span><span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">results</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The return value of <code class="docutils literal"><span class="pre">pipeline_output</span></code> will be a <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v0.18.1)"><code class="xref py py-class docutils literal"><span class="pre">pandas.DataFrame</span></code></a>
containing a column for each call we made to <code class="xref py py-meth docutils literal"><span class="pre">Pipeline.add()</span></code> in our
initialize method and containing a row for each asset that our pipeline&#8217;s
screen.  The printed values should look like this:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="26%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">index</th>
<th class="head">sma_10</th>
<th class="head">sma_30</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Equity(21 [AAME])</td>
<td>2.012222</td>
<td>1.964269</td>
</tr>
<tr class="row-odd"><td>Equity(37 [ABCW])</td>
<td>1.226000</td>
<td>1.131233</td>
</tr>
<tr class="row-even"><td>Equity(58 [SERV])</td>
<td>2.283000</td>
<td>2.309255</td>
</tr>
<tr class="row-odd"><td>Equity(117 [AEY])</td>
<td>3.150200</td>
<td>3.333067</td>
</tr>
<tr class="row-even"><td>Equity(225 [AHPI])</td>
<td>4.286000</td>
<td>4.228846</td>
</tr>
</tbody>
</table>
<p>The most common way to use the results of a pipeline is to define the
algorithm&#8217;s tradeable universe via the <code class="docutils literal"><span class="pre">update_universe</span></code> API function.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="n">update_universe</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;sma_30&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">update_universe</span></code> function expects to be passed an <a class="reference external" href="https://docs.python.org/3.5/glossary.html#term-iterable">iterable</a> of <code class="docutils literal"><span class="pre">Asset</span></code>
objects.  Conveniently, the <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#index-objects">index</a> of the frame returned by <code class="docutils literal"><span class="pre">pipeline_output</span></code>
contains assets.  In the line above, we select the bottom ten assets after
sorting by the result of our 30-day SMA factor.</p>
</div>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="next-steps">
<h1>Next Steps</h1>
<div class="section" id="custom-factors">
<h2>Custom Factors</h2>
<p>One of the most powerful features of the Pipeline API is that it allows users
to define their own custom factors.  The easiest way to do this is to subclass
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.CustomFactor" title="quantopian.pipeline.CustomFactor"><code class="xref py py-class docutils literal"><span class="pre">quantopian.pipeline.CustomFactor</span></code></a> and implement a <code class="docutils literal"><span class="pre">compute</span></code> method
whose signature is:</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>An instance of <code class="xref py py-class docutils literal"><span class="pre">CustomFactor</span></code> that&#8217;s been added to a pipeline will have
its <code class="docutils literal"><span class="pre">compute</span></code> method called every day with data defined by the values
supplied to its constructor as <code class="docutils literal"><span class="pre">inputs</span></code> and <code class="docutils literal"><span class="pre">window_length</span></code>.</p>
<p>For example, if we define and add a <code class="docutils literal"><span class="pre">CustomFactor</span></code> like this:</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyFactor</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">asset_ids</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
       <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">do_something_with_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">attach_pipeline</span><span class="p">(</span><span class="n">Pipeline</span><span class="p">(),</span> <span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>
    <span class="n">my_factor</span> <span class="o">=</span> <span class="n">MyFactor</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">my_factor</span><span class="p">,</span> <span class="s">&#39;my_factor&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>then every simulation day <code class="xref py py-func docutils literal"><span class="pre">my_factor.compute()</span></code> will be called with data as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">values</span></code> will all be 5 x N numpy array, where N is roughly number of assets
in our database on the day in question (generally between 8000-10000). Each
column of <code class="docutils literal"><span class="pre">values</span></code> will contain the last 5 close prices of one asset.
There will be 5 rows in the array because we passed <code class="docutils literal"><span class="pre">window_length=5</span></code> to
the <code class="docutils literal"><span class="pre">MyFactor</span></code> constructor.</li>
<li><code class="docutils literal"><span class="pre">out</span></code> will be an empty array of length N. The job of <code class="docutils literal"><span class="pre">compute</span></code> is to
write output values into out. We write values directly into an output array
rather than returning them to avoid making unnecessary copies. This is an
uncommon idiom in Python, but very common in languages like C and Fortran
that care about high performance numerical code. Many <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.10)"><code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code></a> functions
take an out parameter for similar reasons.</li>
<li><code class="docutils literal"><span class="pre">asset_ids</span></code> will be an integer array of length N containing security ids
corresponding to each column of <code class="docutils literal"><span class="pre">values</span></code>.</li>
<li><code class="docutils literal"><span class="pre">today</span></code> will be a <code class="docutils literal"><span class="pre">datetime64[ns]</span></code> representing the day for which compute
is being called.</li>
</ul>
<p><a class="reference external" href="http://www.zipline.io/appendix.html#zipline.algorithm.TradingAlgorithm" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">zipline.algorithm.TradingAlgorithm</span></code></a></p>
</div>
<div class="section" id="default-inputs">
<h2>Default Inputs</h2>
<p>Some factors are naturally parametrizable on both <code class="docutils literal"><span class="pre">inputs</span></code> and
<code class="docutils literal"><span class="pre">window_length</span></code>.  It makes reasonable sense, for example, to take a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.SimpleMovingAverage" title="quantopian.pipeline.factors.SimpleMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">SimpleMovingAverage</span></code></a> of more than one length or over more than one
input.  For this reason, factors like <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.SimpleMovingAverage" title="quantopian.pipeline.factors.SimpleMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">SimpleMovingAverage</span></code></a> don&#8217;t
provide defaults for <code class="docutils literal"><span class="pre">inputs</span></code> or <code class="docutils literal"><span class="pre">window_length</span></code>.  Every time you construct
an instance of <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.SimpleMovingAverage" title="quantopian.pipeline.factors.SimpleMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">SimpleMovingAverage</span></code></a>, you have to pass a window_length
and an inputs list.</p>
<p>Many factors, however, are naturally defined as operating on a specific dataset
or on a specific window size.  <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.VWAP" title="quantopian.pipeline.factors.VWAP"><code class="xref py py-class docutils literal"><span class="pre">VWAP</span></code></a>
should always be called with <code class="docutils literal"><span class="pre">inputs=[USEquityPricing.close,</span>
<span class="pre">USEquityPricing.volume]</span></code>, and <code class="docutils literal"><span class="pre">RSI</span></code> is canonically calculated over a 14-day
window.  For factors, it&#8217;s convenient to be able to provide a default.  If
values are not passed for <code class="docutils literal"><span class="pre">window_length</span></code> or <code class="docutils literal"><span class="pre">inputs</span></code>, the <code class="docutils literal"><span class="pre">CustomFactor</span></code>
constructor will try to fall back to class-level attributes with the same
names.  This means that we can implement a VWAP-like CustomFactor by defining
an <code class="docutils literal"><span class="pre">inputs</span></code> list as a class level attribute.</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">PriceRange</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the difference between the highest high and the lowest</span>
<span class="sd">    low of each over an arbitrary input range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">high</span><span class="p">,</span> <span class="n">USEquityPricing</span><span class="o">.</span><span class="n">low</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">highs</span><span class="p">,</span> <span class="n">lows</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">highs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">lows</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="o">...</span>
<span class="c"># We&#39;ll automatically use high and low as inputs because we declared them as</span>
<span class="c"># defaults for the class.</span>
<span class="n">price_range_10</span> <span class="o">=</span> <span class="n">PriceRange</span><span class="p">(</span><span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fundamental-data">
<h2>Fundamental Data</h2>
<p>Quantopian provides a number of Pipeline-compatible datasets sourced from
<a class="reference external" href="http://corporate1.morningstar.com/us/home/">Morningstar</a> fundamental data.  These datasets are namespaced under the
<code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.morningstar</span></code> module, whose structure mimics that
of the built-in <code class="docutils literal"><span class="pre">fundamentals</span></code> <a class="reference external" href="http://www.sqlalchemy.org">SQLAlchemy</a> namespace.</p>
<p>The following datasets are currently available from the
<code class="xref py py-mod docutils literal"><span class="pre">morningstar</span></code> module:</p>
<ul class="simple">
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#asset-classification">asset_classification</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#balance-sheet">balance_sheet</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#cash-flow-statement">cash_flow_statement</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#company-reference">company_reference</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#earnings-ratios">earnings_ratios</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#earnings-report">earnings_report</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#financial-statement-filing">financial_statement_filing</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#general-profile">general_profile</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#income-statement">income_statement</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#operation-ratios">operation_ratios</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#share-class-reference">share_class_reference</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#valuation">valuation</a></li>
<li><a class="reference external" href="https://www.quantopian.com/help/fundamentals#valuation-ratios">valuation_ratios</a></li>
</ul>
<p>Each of these datasets provides columns that can be passed as inputs to
Pipeline API computations.</p>
<p>For example, <code class="xref py py-attr docutils literal"><span class="pre">morningstar.valuation.market_cap</span></code> is a column representing
the most recently reported market cap for each asset on each date.  There are
over 900 total columns available in the morningstar datasets. See the
Quantopian <a class="reference external" href="https://www.quantopian.com/help/fundamentals">Fundamentals Reference</a> for a full description of all such
attributes.</p>
<p><strong>Note:</strong> The Pipeline API currently only supports columns that can be
represented as one of the following numpy <a class="reference external" href="http://docs.scipy.org/doc/numpy-1.10.1/reference/arrays.dtypes.html">dtypes</a>:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">float64</span></code></li>
<li><code class="docutils literal"><span class="pre">int64</span></code></li>
<li><code class="docutils literal"><span class="pre">bool_</span></code></li>
<li><code class="docutils literal"><span class="pre">datetime64</span></code></li>
</ul>
<p>Notably, we do not yet support string-based fields in Pipelines.  We expect to
remove this restriction in a future update.</p>
</div>
<div class="section" id="masking-factors">
<h2>Masking Factors</h2>
<p>When computing a <code class="xref py py-class docutils literal"><span class="pre">CustomFactor</span></code>, it is sometimes the case that you are
only interested in computing over a certain set of stocks as opposed to the
entire universe. Most commonly this is because your CustomFactor&#8217;s compute
method is computationally expensive, so you want to limit the number of stocks
to compute over in order to optimize for performance.</p>
<p>You can achieve this by passing a <a class="reference external" href="http://www.zipline.io/appendix.html#zipline.pipeline.filters.Filter" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> to
your CustomFactor upon instantiation via the <code class="docutils literal"><span class="pre">mask</span></code> parameter. When passed a
mask, a CustomFactor will only compute values over stocks for which the Filter
returns True. All other stocks for which the Filter returned False will be
filled with missing values.</p>
<p><strong>Example:</strong></p>
<p>Suppose we want to compute a factor over only the top 500 stocks by market cap.
We can define a CustomFactor and Filter as follows:</p>
<div class="highlight-Python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyFactor</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">USEquityPrice</span><span class="o">.</span><span class="n">close</span><span class="p">]</span>
    <span class="n">window_length</span> <span class="o">=</span> <span class="n">N</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">close</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">do_something_expensive</span><span class="p">(</span><span class="n">close</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MarketCap</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">,</span> <span class="n">morningstar</span><span class="o">.</span><span class="n">valuation</span><span class="o">.</span><span class="n">shares_outstanding</span><span class="p">]</span>
    <span class="n">window_length</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">close</span><span class="p">,</span> <span class="n">shares</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">close</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">shares</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="n">pipeline</span> <span class="o">=</span> <span class="n">attach_pipeline</span><span class="p">(</span><span class="n">Pipeline</span><span class="p">(),</span> <span class="s">&#39;my_pipeline&#39;</span><span class="p">)</span>

    <span class="n">mkt_cap</span> <span class="o">=</span> <span class="n">MarketCap</span><span class="p">()</span>
    <span class="n">mkt_cap_top_500</span> <span class="o">=</span> <span class="n">mkt_cap</span><span class="o">.</span><span class="n">top</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>

    <span class="c"># Pass our filter to our custom factor via the mask parameter.</span>
    <span class="n">my_factor</span> <span class="o">=</span> <span class="n">MyFactor</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">mkt_cap_top_500</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">my_factor</span><span class="p">,</span> <span class="s">&#39;my_factor&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="normalizing-results">
<h2>Normalizing Results</h2>
<p>It is often desirable to <a class="reference external" href="https://en.wikipedia.org/wiki/Normalization_(statistics)">normalize</a> the output of a factor before using it in
an algorithm. In this context, normalizing means re-scaling a set of values in
a way that makes comparisons between values more meaningful.</p>
<p>Such re-scaling can be useful for comparing the results of different factors.
A technical indicator like <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.RSI" title="quantopian.pipeline.factors.RSI"><code class="xref py py-class docutils literal"><span class="pre">RSI</span></code></a> might
produce an output bounded between 1 and 100, whereas a fundamental ratio might
produce a values of any real number. Normalizing two incomensurable factors via
an operation like <a class="reference external" href="http://www.investopedia.com/terms/z/zscore.asp">Z-Score</a> makes it easier to incorporate both factors into a
larger model, because doing so reduces both factors to <a class="reference external" href="https://en.wikipedia.org/wiki/Nondimensionalization">dimensionless</a>
quantities.</p>
<p>The base <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> class provides several
methods for normalizing factor outputs. The
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.demean" title="quantopian.pipeline.factors.Factor.demean"><code class="xref py py-meth docutils literal"><span class="pre">demean()</span></code></a> method transforms the output
of a factor by computing the mean of each row and subtracting it from every
entry in the row.  Similarly, the
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.zscore" title="quantopian.pipeline.factors.Factor.zscore"><code class="xref py py-meth docutils literal"><span class="pre">zscore()</span></code></a> method subtracts the mean
from each row and then divides by the standard deviation of the row.</p>
<p><strong>Example:</strong></p>
<p>Suppose that <code class="docutils literal"><span class="pre">f</span></code> is a <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> which
would produce the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    1.0    2.0    3.0    4.0
2017-03-14    1.5    2.5    3.5    1.0
2017-03-15    2.0    3.0    4.0    1.5
2017-03-16    2.5    3.5    1.0    2.0
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">f.demean()</span></code> constructs a new <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a>
that will produce its output by first computing <code class="docutils literal"><span class="pre">f</span></code> and then subtracting the
mean from each row:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13 -1.500 -0.500  0.500  1.500
2017-03-14 -0.625  0.375  1.375 -1.125
2017-03-15 -0.625  0.375  1.375 -1.125
2017-03-16  0.250  1.250 -1.250 -0.250
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">f.zscore()</span></code> works similarly, except that it also divides each row by the
standard deviation of the row.</p>
<div class="section" id="eliminating-outliers-with-masks">
<h3>Eliminating Outliers with Masks</h3>
<p>A common pitfall when normalizing a factor is that many normalization methods
are sensitive to the magnitude of large outliers. A common technique for
dealing with this issue is to ignore extreme or otherwise undesired data points
when transforming the result of a Factor.</p>
<p>To simplify the process of programmatically excluding data points, all
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> normalization methods accept an
optional keyword argument, <code class="docutils literal"><span class="pre">mask</span></code>, which accepts a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.filters.Filter" title="quantopian.pipeline.filters.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a>.  When a filter is provided,
entries where the filter produces False are ignored by the normalization
process, and those values are assigned a value of <code class="docutils literal"><span class="pre">NaN</span></code> in the normalized
output.</p>
<p><strong>Example:</strong></p>
<p>Suppose that <code class="docutils literal"><span class="pre">f</span></code> is a <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> which
would produce the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13   99.0    2.0    3.0    4.0
2017-03-14    1.5   99.0    3.5    1.0
2017-03-15    2.0    3.0   99.0    1.5
2017-03-16    2.5    3.5    1.0   99.0
</pre></div>
</div>
<p>Simply demeaning or z-scoring this data isn&#8217;t helpful, because the row-means
are heavily skewed by the outliers on the diagonal. We can construct a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.filters.Filter" title="quantopian.pipeline.filters.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> that identifiers outliers using
the <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.percentile_between" title="quantopian.pipeline.factors.Factor.percentile_between"><code class="xref py py-meth docutils literal"><span class="pre">percentile_between()</span></code></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">MyFactor</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">non_outliers</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">percentile_between</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <code class="docutils literal"><span class="pre">non_outliers</span></code> is a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.filters.Filter" title="quantopian.pipeline.filters.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> that produces True for locations
in the output of <code class="docutils literal"><span class="pre">f</span></code> that fall on or below the 75th percentile for their row
and produces False otherwise:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13  False   True   True   True
2017-03-14   True  False   True   True
2017-03-15   True   True  False   True
2017-03-16   True   True   True  False
</pre></div>
</div>
<p>We can use our <code class="docutils literal"><span class="pre">non_outliers</span></code> filter to more intelligently normalize <code class="docutils literal"><span class="pre">f</span></code> by
passing as a mask to <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.demean" title="quantopian.pipeline.factors.Factor.demean"><code class="xref py py-meth docutils literal"><span class="pre">demean()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">normalized</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">demean</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">non_outliers</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">normalized</span></code> is a new <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> that will
produce its output by computing <code class="docutils literal"><span class="pre">f</span></code>, subtracting the mean of non-diagonal
values from each row, and then writing <code class="docutils literal"><span class="pre">NaN</span></code> into the masked locations:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    NaN -1.000  0.000  1.000
2017-03-14 -0.500    NaN  1.500 -1.000
2017-03-15 -0.166  0.833    NaN -0.666
2017-03-16  0.166  1.166 -1.333    NaN
</pre></div>
</div>
</div>
<div class="section" id="grouped-normalization-with-classifiers">
<h3>Grouped Normalization with Classifiers</h3>
<p>Another important application of normalization is adjusting the results of a
factor based some method of grouping or classifying assets. For example, we
might want to compute earnings yield across all known assets and then normalize
the result by dividing each asset&#8217;s earnings ratio by the mean earnings yield
for that asset&#8217;s sector or industry.</p>
<p>In the same way that the optional <code class="docutils literal"><span class="pre">mask</span></code> parameter allows us to modify the
behavior of <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.demean" title="quantopian.pipeline.factors.Factor.demean"><code class="xref py py-meth docutils literal"><span class="pre">demean()</span></code></a> to ignore
certain values, the <code class="docutils literal"><span class="pre">groupby</span></code> parameter allows us to specify that
normalizations should be performed on <strong>subsets</strong> of rows, rather than on the
entire row at once.</p>
<p>In the same way that we pass a <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.filters.Filter" title="quantopian.pipeline.filters.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> to
define values to ignore, we pass a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a> to define how to partition up
the rows of the factor being normalized.  Classifiers are expressions similar
to Factors and Filters, except that they produce integers instead of floats or
booleans.  Locations for which a classifier produced the same integer value are
grouped together when that classifier is passed to a normalization method.</p>
<p><strong>Example:</strong></p>
<p>Suppose that we again have a factor, <code class="docutils literal"><span class="pre">f</span></code>, which produces the following
output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    1.0    2.0    3.0    4.0
2017-03-14    1.5    2.5    3.5    1.0
2017-03-15    2.0    3.0    4.0    1.5
2017-03-16    2.5    3.5    1.0    2.0
</pre></div>
</div>
<p>and suppose that we have a classifier <code class="docutils literal"><span class="pre">c</span></code>, which classifies companies by
industry, using a label of 1 for consumer electronics and a label of 2 for
food service</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13      1      1      2      2
2017-03-14      1      1      2      2
2017-03-15      1      1      2      2
2017-03-16      1      1      2      2
</pre></div>
</div>
<p>We construct a new factor that de-means <code class="docutils literal"><span class="pre">f</span></code> <strong>by sector</strong> via:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">demean</span><span class="p">(</span><span class="n">groupby</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>which produces the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13 -0.500  0.500 -0.500  0.500
2017-03-14 -0.500  0.500  1.250 -1.250
2017-03-15 -0.500  0.500  1.250 -1.250
2017-03-16 -0.500  0.500 -0.500  0.500
</pre></div>
</div>
<p>There are currently three ways to construct a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a>:</p>
<ol class="arabic simple">
<li>The <code class="docutils literal"><span class="pre">.latest</span></code> attribute of any
<code class="xref py py-mod docutils literal"><span class="pre">morningstar</span></code> column of dtype <cite>int64</cite> produces a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a>.  There are currently nine
such columns:<ul>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.cannaics</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.morningstar_economy_sphere_code</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.morningstar_industry_code</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.morningstar_industry_group_code</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.morningstar_sector_code</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.naics</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.sic</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.stock_type</span></code></li>
<li><code class="xref py py-attr docutils literal"><span class="pre">morningstar.asset_classification.style_box</span></code></li>
</ul>
</li>
<li>There are a few <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a>
applications common enough that Quantopian provides dedicated subclasses for
them. These hand-written classes come with additional documentation and
class-level attributes with symbolic names for their labels.  There are
currently two such built-in classifiers:<ul>
<li><a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.morningstar.Sector" title="quantopian.pipeline.classifiers.morningstar.Sector"><code class="xref py py-class docutils literal"><span class="pre">quantopian.pipeline.classifiers.morningstar.Sector</span></code></a></li>
<li><a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.morningstar.SuperSector" title="quantopian.pipeline.classifiers.morningstar.SuperSector"><code class="xref py py-class docutils literal"><span class="pre">quantopian.pipeline.classifiers.morningstar.SuperSector</span></code></a></li>
</ul>
</li>
<li>Any <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> can be converted into a
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a> via its
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor.quantiles" title="quantopian.pipeline.factors.Factor.quantiles"><code class="xref py py-meth docutils literal"><span class="pre">quantiles()</span></code></a> method.  The resulting
<a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.classifiers.Classifier" title="quantopian.pipeline.classifiers.Classifier"><code class="xref py py-class docutils literal"><span class="pre">Classifier</span></code></a> produces labels by sorting
the results of the original <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> each day
and grouping the results into equally-sized buckets.</li>
</ol>
</div>
</div>
<div class="section" id="working-with-dates">
<h2>Working with Dates</h2>
<p>Most of the data available in the Pipeline API is numerically-valued. There
are, however, some pipeline datasets that contain non-numeric data.</p>
<p>The most common class of non-numeric data available in the Pipeline API is data
representing dates and times of events.  An example of such a dataset is the
EventVestor <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar" title="quantopian.pipeline.data.eventvestor.EarningsCalendar"><code class="xref py py-class docutils literal"><span class="pre">EarningsCalendar</span></code></a>, which provides two columns:</p>
<ul class="simple">
<li><a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement" title="quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement"><code class="xref py py-attr docutils literal"><span class="pre">EarningsCalendar.next_announcement</span></code></a></li>
<li><a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar.previous_announcement" title="quantopian.pipeline.data.eventvestor.EarningsCalendar.previous_announcement"><code class="xref py py-attr docutils literal"><span class="pre">EarningsCalendar.previous_announcement</span></code></a></li>
</ul>
<p>When supplied as inputs to a <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.CustomFactor" title="quantopian.pipeline.CustomFactor"><code class="xref py py-class docutils literal"><span class="pre">CustomFactor</span></code></a>, these
columns provide numpy arrays of dtype <code class="xref py py-class docutils literal"><span class="pre">numpy.datetime64</span></code> representing,
for each pair of asset and simulation date, the dates of the next and previous
earnings announcements for the asset as of the simulation date.</p>
<p>For example, Microsoft&#8217;s earnings announcement calendar for 2014 was as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Quarter</th>
<th class="head">Announcement Date</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Q1</strong></td>
<td>2014-01-23</td>
</tr>
<tr class="row-odd"><td><strong>Q2</strong></td>
<td>2014-04-24</td>
</tr>
<tr class="row-even"><td><strong>Q3</strong></td>
<td>2014-07-22</td>
</tr>
<tr class="row-odd"><td><strong>Q4</strong></td>
<td>2014-10-23</td>
</tr>
</tbody>
</table>
<p>If we specify <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement" title="quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement"><code class="xref py py-attr docutils literal"><span class="pre">EarningsCalendar.next_announcement</span></code></a> as an input to a
CustomFactor with a window_length of 1, we&#8217;ll be passed the following data for
MSFT in our compute function:</p>
<ul class="simple">
<li>From <code class="docutils literal"><span class="pre">2014-01-24</span></code> to <code class="docutils literal"><span class="pre">2014-04-24</span></code>, the next announcement for MSFT will be
<code class="docutils literal"><span class="pre">2014-04-24</span></code>.</li>
<li>From <code class="docutils literal"><span class="pre">2014-04-25</span></code> to <code class="docutils literal"><span class="pre">2014-07-22</span></code>, the next announcement will be
<code class="docutils literal"><span class="pre">2014-07-22</span></code>.</li>
<li>From <code class="docutils literal"><span class="pre">2014-07-23</span></code> to <code class="docutils literal"><span class="pre">2014-10-23</span></code>, the next announcement will be
<code class="docutils literal"><span class="pre">2014-10-23</span></code>.</li>
</ul>
<p>If a company had not yet announced its next earnings on a given simulation
date, <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement" title="quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement"><code class="xref py py-attr docutils literal"><span class="pre">next_announcement</span></code></a> will contain a value of
<code class="docutils literal"><span class="pre">numpy.NaT</span></code> which stands for &#8220;Not a Time&#8221;.  Note that unlike the special
floating-point value <a class="reference external" href="http://docs.scipy.org/doc/numpy-1.10.0/user/misc.html#ieee-754-floating-point-special-values">NaN</a>, (&#8220;Not a Number&#8221;), <code class="docutils literal"><span class="pre">NaT</span></code> compares equal to itself.</p>
<p>The <a class="reference internal" href="https://www.quantopian.com/api-reference.html#quantopian.pipeline.data.eventvestor.EarningsCalendar.previous_announcement" title="quantopian.pipeline.data.eventvestor.EarningsCalendar.previous_announcement"><code class="xref py py-attr docutils literal"><span class="pre">previous_announcement</span></code></a> column behaves similarly,
except that it fills backwards rather than forwards, producing the date of the
most-recent historical announcement as of any given date.</p>
</div>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
</div>
<h3 id='ide-dollar-volume'>Dollar Volume</h3>
<p>The dollar volume of a stock is a good measure of its liquidity. Highly liquid securities are easier to enter or exit without impacting the price, and in general, orders of these securities will be filled more quickly. Conversely, orders of low dollar-volume securities can be slow to fill, and can impact the fill price. This can make it difficult for strategies involving illiquid securities to be executed.</p>
<p>To filter out low dollar-volume securities from your pipeline, you can add a builtin <code>AverageDollarVolume</code> custom factor, and add a screen to only look at the top dollar volume securities:</p>
<pre class='prettyprint'><code>from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline import Pipeline&#x000A;from quantopian.pipeline.factors import AverageDollarVolume&#x000A;...&#x000A;def initialize(context):&#x000A;    pipe = Pipeline()&#x000A;    attach_pipeline(pipe, name='my_pipeline')&#x000A;&#x000A;    # Construct an average dollar volume factor and add it to the pipeline.&#x000A;    dollar_volume = AverageDollarVolume(window_length=30)&#x000A;    pipe.add(dollar_volume, 'dollar_volume')&#x000A;&#x000A;    # Define high dollar-volume filter to be the top 10% of securities by dollar volume.&#x000A;    high_dollar_volume = dollar_volume.percentile_between(90, 100)&#x000A;&#x000A;    # Filter to only the top dollar volume securities.&#x000A;    pipe.set_screen(high_dollar_volume)</code></pre>
<h3 id='ide-algospeed'>Best Practices For A Fast Algorithm</h3>
<p>The Quantopian backtester will run fastest when you follow certain best practices:</p>
<p>
<strong>Only access data when you need it:</strong> All pricing data is always accessible to you, and it is loaded on-demand. You pay the performance cost of accessing the data when you call for it. If your algorithm checks a price every minute, that has a performance cost. If you only ask for the price when you need it, which is likely less frequently, it will speed up your algorithms.
</p>
<p>
<strong>Use schedule function liberally:</strong> Schedule all of your functions to run only when necessary, as opposed to every minute in <code>handle_data</code>. You should only use handle_data for things you really need to happen every minute. Everything else should be it's own function, scheduled to run when appropriate with <code>schedule_function</code>.
</p>
<p>
<strong>Batch data look ups:</strong> Whenever possible you should batch data requests. All of the data functions (<code>data.history</code>, <code>data.current</code>, <code>data.can_trade</code>, and <code>data.is_stale</code>) all accept a list of securities when requesting data. Running these once with a list of securities will be significantly more performant than looping through the list of securities and calling these functions individually per security.
</p>
<p>
<strong>Record data daily, not minutely, in backtesting:</strong>  Any data you <code>record</code> in your backtest will record the last data point per day. If you try to record something in <code>handle_data</code> to record more frequently, it will still only record one daily data point in the backtest. Recording in handle_data will not give you more data, and will significantly slow down your algorithm. We recommend creating a separate record function, and scheduling it to run once a day (or less frequently) since greater frequency won't give you more data. The one caveat here is that record does work minutely in live trading. You can update your record function to run more frequently before live trading your algo, or use <code>get_environment</code> to schedule record functions to behave different in backtesting and live trading.
</p>
<p>
<strong>Access account and portfolio data only when needed:</strong>  Account and portfolio information is calculated daily or on demand. If you access context.account or context.portfolio in handle_data, this will force the system to calculate your entire portfolio minutely, and slow down your algo. You should only call context.account or context.portfolio when you need to use the data. We recommend doing this in a schedule function. The one caveat here is that your account and portfolio information is calculated minutely in live trading. You can update your algorithm to access this information more frequently before live trading if necessary, or use get_environment to schedule functions to behave different in backtesting and live trading.
</p>
<h3 id='ide-manual-lookup'>Manual Lookup</h3>
<p id='ide-symbol'>If you want to manually select a security, you can use the <code>symbol</code> function to look up a security by its ticker or company name. Using the symbol method brings up a search box that shows you the top results for your query.</p>
<img alt="Help-symbol-lookup" class="help-image" height="153px" src="assets/help-symbol-lookup-91f9f4a0bc33dee953687f2a785aa064.png" />
<p>To reference multiple securities in your algorithm, call the <code>symbols</code> function to create a list of securities. Note the pluralization! The function can accept a list of up to 500 securities and its parameters are not case sensitive.</p>
<p>Sometimes, tickers are reused over time as companies delist and new ones begin trading. For example, G used to refer to Gillette but now refers to Genpact. If a ticker was reused by multiple companies, use <a href='help.html#api-symbollookupdate'>set_symbol_lookup_date('YYYY-MM-DD')</a> to specify what date to use when resolving conflicts. This date needs to be set before any calls to <code>symbol</code> or <code>symbols</code>.</p>
<img alt="Help-symbol" class="help-image" height="153px" src="assets/help-symbol-0b05971bf70ebd0399a2aa4618c642d8.png" />
<p>Another option to manually enter securities is to use the <code>sid</code> function. All securities have a unique security id (SID) in our system. Since symbols may be reused among exchanges, this prevents any confusion and verifies you are calling the desired security. You can use our sid method to look up a security by its id, symbol, or name.</p>
<img alt="Help-sid" class="help-image" height="153px" src="assets/help-sid-098ac8df95e2d6096f2c0834be1de766.png" />
<p>In other words, <code>sid(24)</code> is equivalent to <code>symbol('AAPL')</code> or Apple.</p>
<p>Quantopian's backtester makes a best effort to automatically adjust the backtest's start or end dates to accommodate the assets that are being used. For example, if you're trying to run a backtest with Tesla in 2004, the backtest will suggest you begin on June 28, 2010 the first day the security traded. This ability is significantly decreased when using <code>symbol</code> instead of <code>sid</code>.</p>
<p>The <code>symbol</code> and <code>symbols</code> methods accept only string literals as parameters. The <code>sid</code> method accepts only an integer literal as a parameter. A static analysis is run on the code to quickly retrieve data needed for the backtest.</p>
<h3 id='ide-logging'>Logging</h3>
<p>Your algorithm can easily generate log output by using the <code>log.error</code> (and <code>warn</code>, <code>info</code>, <code>debug</code>) methods.  Log output appears in the right-hand panel of the IDE or in the backtest result page.</p>
<p>Logging is rate-limited (throttled) for performance reasons. The basic limit is two log messages per call of <code>initialize</code> and <code>handle_data</code>. Each backtest has an additional buffer of 20 extra log messages. Once the limit is exceeded, messages are discarded until the buffer has been emptied. A message explaining that some messages were discarded is shown. </p>
<p>Two examples:</p>
<ul>
<li>Suppose in <code>initialize</code> you log 22 lines. Two lines are permitted, plus the 20 extra log messages, so this works. However, a 23rd log line would be discarded.</li>
<li>Suppose in <code>handle_data</code>, you log three lines. Each time <code>handle_data</code> is called, two lines are permitted, plus one of the extra 20 is consumed.  Thus, 20 calls of <code>handle_data</code> are logged entirely. On the 21st call two lines are logged, and the last line is discarded.  Subsequent log lines are also discarded until the buffer is emptied.</li>
</ul>
<p>Additionally, there is a per-member overall log limit.  When a backtest causes the overall limit to be reached, the logs for the oldest backtest are discarded.</p>
<h3 id='ide-record'>Recording and plotting variables</h3>
<p>You can create time series charts by using the <code>record</code> method and passing series names and corresponding values using keyword arguments. Up to five series can be recorded and charted.  Recording is done at day-level granularity. Recorded time series are then displayed in a chart below the performance chart.</p>
<p>In backtesting, the last recorded value per day is used.  Therefore, we recommend using <code>schedule_function</code> to record values once per day.</p>
<p>In live trading, you can have a new recorded value every minute.</p>
<p>A simple, contrived example:</p>
<pre class='prettyprint margin_50l'>def initialize(context):&#x000A;    pass&#x000A;&#x000A;def handle_data(context, data):&#x000A;    # track the prices of MSFT and AAPL&#x000A;    record(msft=data.current(sid(5061), 'price'), aapl=data.current(sid(24), 'price'))</pre>
<p>And for backtesting, schedule a function:</p>
<pre class='prettyprint margin_50l'>def initialize(context):&#x000A;    schedule_function(record_vars, date_rules.every_day(), time_rules.market_close())&#x000A;&#x000A;def record_vars(context, data):&#x000A;    # track the prices of MSFT and AAPL&#x000A;    record(msft=data.current(sid(5061), 'price'), aapl=data.current(sid(24), 'price'))&#x000A;&#x000A;def handle_data(context, data):&#x000A;    pass</pre>
<p>In the result for this backtest, you'll get something like this:</p>
<img alt="Help-record" class="help-image" height="166px" src="assets/help-record-08edef2da982bd21a780515989d30405.png" />
<p>You can also pass variables as the series name using positional arguments. The value of the variable can change throughout the backtest, dynamically updating in the custom chart. The <code>record</code> function can accept a string or a variable that has a string value.</p>
<pre class='prettyprint margin_50l'>def initialize(context):&#x000A;    # AA, AAPL, ALK&#x000A;    context.securities = [sid(2), sid(24), sid(300)] &#x000A;&#x000A;def handle_data(context, data):&#x000A;    # You can pass a string variable into record().&#x000A;    # Here we record the price of all the securities in our list.&#x000A;    for stock in context.securities:&#x000A;      price = data.current(stock, 'price')&#x000A;      record(stock, price)&#x000A;&#x000A;    # You can also pass in a variable with a string value.&#x000A;    # This records the high and low values for AAPL.&#x000A;    fields = ['high', 'low']&#x000A;    for field in fields:&#x000A;      record(field, data.current(sid(24),field))</pre>
<p>The code produces a custom chart that looks like this. Click on a variable name in the legend to remove it from the chart, allowing you to zoom in on the other time series. Click the variable name again to restore it on the chart.</p>
<img alt="Help-record_kwargs" class="help-image" height="100px" src="assets/help-record_kwargs-69f044747b9755f96b4dc7285885fd07.png" />
<p>Some notes:</p>
<ul>
<li>For each series, the value at the end of each trading day becomes the recorded value for that day.  This is important to remember when backtesting.</li>
<li>Until a series starts being recorded, it will have no value.  If <code>record(new_series=10)</code> is done on day 10, new_series will have no value for days 1-9.</li>
<li>Each series will retain its last recorded value until a new value is used.  If <code>record(my_series=5)</code> is done on day 5, every subsequent day will have the same value (5) for my_series until a new value is given.</li>
<li>The backtest graph output automatically changes the x-axis time units when there are too many days to fit cleanly. For instance, instead of displaying 5 days of data individually, it will combine those into a 1-week data point. In that case the recorded values for that week are averaged and that average is displayed.</li>
</ul>
<p>To see more, check out the <a href='help.html#sample-record'>example record algorithm</a> at the end of the help documentation.</p>
<h3 id='ide-dividends'>Dividends</h3>
<p>The Quantopian database holds over 150,000 dividend events dating from January 2002. Dividends are treated as events and streamed through the performance tracking system that monitors your algorithm during a backtest. Dividend events modify the security price and the portfolio's cash balance.</p>
<p>In lookback windows, like <code>history</code>, prices are dividend-adjusted. Please review <a href='help.html#overview-datasources'>Data Sources</a> for more detail.</p>
<p>Dividends specify four dates:</p>
<ul>
<li><strong>declared date</strong> is the date on which the company announced the dividend.</li>
<li><strong>record date</strong> is the date on which a shareholder must be recorded as an owner to receive a dividend payment. Because settlement can take 3 days, a second date is used to calculate ownership on the record date.</li>
<li><strong>ex date</strong> is 3 trading days prior to the record date. If a holder sells the security before this date, they are not paid the dividend. The ex date is when the price of the security is typically most affected.</li>
<li><strong>pay date</strong> is the date on which a shareholder receives the cash for a dividend.</li>
</ul>
<p>Security prices are marked down by the dividend amount on the open following the ex_date. The portfolio's cash position is increased by the amount of the dividend on the pay date. Quantopian chose this method so that cash positions are correctly maintained, which is particularly important when an algorithm is used for live trading. The downside to this method is that causes a lower portfolio value for the period between the two dates.</p>
<p>In order for your algorithm to receive dividend cash payments, you must have a long position (positive amount) in the security as of the close of market on the trading day prior to the ex_date AND you must run the simulation through the pay date, which is typically about 60 calendar days later.</p>
<p>If you are short the security at market close on the trading day prior to the ex_date, your algorithm will be required to <strong>pay</strong> the dividends due. As with long positions, the cash balance will be <strong>debited</strong> by the dividend payments on the pay date. This is to reflect the short seller's obligation to pay dividends to the entity that loaned the security.</p>
<p>Special dividends (where more than 25% of the value of the company is involved) are not yet tracked in Quantopian.  There are several hundred of these over the last 11 years.  We will add these dividends to our data in the future.</p>
<p>Dividends are not relayed to algorithms as events that can be accessed by the API; we will add that feature in the future.</p>
<h3 id='ide-fundamentals'>Fundamental Data</h3>
<div class='markdown-generated'>
<p>Quantopian provides fundamental data from Morningstar, available for backtesting in your algorithm. The data covers over 8,000 companies traded in the US with over 670 metrics. Broadly, the <code>get_fundamentals</code> method (described below) queries across all of the stocks in the fundamentals database. Using a SQL-like syntax to choose columns, filter, sort, and limit results, you can generate a basket of securities for use in your Quantopian algorithm, based on the financial metrics of the company. Further, you can use these metrics as part of your trading logic in your algorithm. </p>

<p><strong>A full listing of the available fields can be found at the <a href="https://www.quantopian.com/help/fundamentals" target="_blank">Fundamentals Reference</a> page.</strong></p>

<p>Fundamentals allow you to do two activities inside Quantopian backtests:</p>

<ol>
<li>Create a universe of securities to use within your algorithm based on fundamental data</li>
<li>Provide data within your algorithm (inside <code>handle_data</code> or scheduled functions) for making investment decisions</li>
</ol>

<p>There are three methods related to fundamental data: <code>before_trading_start</code>, <code>get_fundamentals</code>, and <code>update_universe</code>.</p>

<p><code>before_trading_start</code> is called once per day prior to market open.  It can be used to create a universe of securities using fundamental data by using <code>get_fundamentals</code> and passing in a query object. The query object is built using the syntax of SQLAlchemy, a python ORM. See the <a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying" target="_blank">SQLAlchemy documentation</a> for more details on how to generate a query.</p>

<p>In the example below, the algorithm gets two pieces of information per security: the P/E ratio and the sector code as determined by Morningstar. The <code>get_fundamentals</code> method automatically includes a column for the security id (SID). The returned data is then filtered down via <code>filter</code>, using P/E ratio and sector codes. Finally, the data is sorted using <code>order_by</code> and truncated using <code>limit</code>.</p>

<pre><code>&quot;&quot;&quot;&#x000A;    Called once before the start of each trading day.&#x000A;    Updates our universe with the securities and values&#x000A;    found from fetch_fundamentals&#x000A;&quot;&quot;&quot;&#x000A;&#x000A;def before_trading_start(context, data): &#x000A;    # Query for securities based on PE ratio and their economic sector&#x000A;    fundamental_df = get_fundamentals(&#x000A;        # Retrieve data based on PE ratio and economic sector&#x000A;        query(&#x000A;            fundamentals.valuation_ratios.pe_ratio,&#x000A;            fundamentals.asset_classification.morningstar_sector_code,&#x000A;        )&#x000A;&#x000A;        # Filter where the Sector code matches our technology sector code&#x000A;        .filter(fundamentals.asset_classification.morningstar_sector_code == 311)&#x000A;&#x000A;        # Filter where PE ratio is greater than 20 &#x000A;        .filter(fundamentals.valuation_ratios.pe_ratio &gt; 20)&#x000A;&#x000A;        # Filter where PE ratio is less than 50&#x000A;        .filter(fundamentals.valuation_ratios.pe_ratio &lt; 50)&#x000A;&#x000A;        # Order by highest PE ratio and limit to 4 results &#x000A;        .order_by(fundamentals.valuation_ratios.pe_ratio.desc()).limit(4)&#x000A;    )&#x000A;</code></pre>

<p>A full listing of the available fields can be found at the <a href="https://www.quantopian.com/help/fundamentals" target="_blank">Fundamentals Reference</a> page. The fundamentals database is updated on a daily basis. A <a href="help.html#sample-fundamentals">sample algorithm</a> is available showing how to access fundamental data. </p>

<p>The <code>get_fundamentals</code> method returns a pandas dataframe, which can be used in two interesting ways:</p>

<ol>
<li><p>Added to <code>context</code> for later use in your algorithm&#39;s functions. Your algorithm can then make use of the data in this dataframe.</p>

<pre><code>context.fundamental_df = fundamental_df&#x000A;</code></pre></li>
<li><p>Passed to the <code>update_universe</code> method, which adds the securities to your universe. No orders of any kind can be executed from within <code>before_trading_start</code>.</p>

<pre><code>update_universe(context.fundamental_df.columns.values)&#x000A;</code></pre></li>
</ol>

<h4>&quot;as of&quot; Dates</h4>

<p>Each fundamental data field has a corresponding as_of field, e.g. <code>basic_eps</code> also has <code>basic_eps_as_of</code>.  The as_of field contains the relevant time period of the metric, as a Python date object.  Some of the data in Morningstar is quarterly (revenue, earnings, etc.), while other data is daily/weekly (market cap, P/E ratio, etc.).  Each metric&#39;s as_of date field  is set to the end date of the period to which the metric applies.</p>

<p>For example, if you use a quarterly earnings metric like basic_eps, the accompanying date field <code>basic_eps_as_of</code> will be set to the end date of the relevant quarter (for example, June 30, 2014). The as_of date indicates the date upon which the measured period ends.</p>

<p>Quantopian currently exposes the most recent period&#39;s data. If you need previous periods&#39; metrics, you must manually save those metrics in your algorithm as your backtest progresses.</p>

<h4>Point in Time</h4>

<p>When running a backtest, Quantopian doesn&#39;t use the as_of date for exposing the data to your algorithm. Rather, a new value is exposed at the &quot;point in time&quot; in the past when the metric would be known to you. This day is called the <strong>file date</strong>. </p>

<p>Companies don&#39;t typically announce their earnings the day after the period is complete. If a company files earnings for the period ending June 30th (the as_of date), the file date (the date upon which this information is known to the public) is about 45 days later.</p>

<p>Quantopian takes care of this logic for you in the backtester. For data updates since Quantopian began subscribing to Morningstar&#39;s data, Quantopian tracks the file date based on when the information changes in Morningstar. For historic changes, Morningstar also provides a file date to reconstruct how the data looked at specific points in time. In circumstances where the file date is not known to Quantopian, the file date is defaulted to be 45 days after the <code>as_of</code> date.</p>

<h4>Restrictions</h4>

<p>Some restrictions regarding the use of fundamental data in Quantopian:</p>

<ul>
<li>You cannot execute an order from <code>before_trading_start</code></li>
<li>Fundamental data cannot yet be used with the <code>history</code> function</li>
</ul>

</div>
<h3 id='overview-setbenchmark'>Setting a custom benchmark</h3>
<p>The default benchmark in your algorithm is SPY, an ETF that tracks the S&P 500.  You can change it in the <code>initialize</code> function by using <code>set_benchmark</code> and passing in another security.  Only one security can be used for the benchmark, and only one benchmark can be set per algorithm.  If you set multiple benchmarks, the last one will be used.</p>
<p>Here's an example:</p>
<pre class='prettyprint margin_50l'>def initialize(context):&#x000A;  set_benchmark(symbol('TSLA'))&#x000A;&#x000A;def handle_data(context, data):&#x000A;  ...</pre>
<h3 id='ide-slippage'>Slippage Models</h3>
<p>Slippage is where our backtester calculates the realistic impact of your orders on the execution price you receive.  When you place an order for a trade, your order affects the market.  Your buy order drives prices up, and your sell order drives prices down; this is generally referred to as the 'price impact' of your trade.  The size of the price impact is driven by how large your order is compared to the current trading volume. The slippage method also evaluates if your order is simply too big: you can't trade more than market's volume, and generally you can't expect to trade more than a fraction of the volume.  All of these concepts are wrapped into the slippage method.</p>
<p>When an order isn't filled because of insufficient volume, it remains open to be filled in the next minute. This continues until the order is filled, cancelled, or the end of the day is reached when all orders are cancelled.</p>
<p>Slippage must be defined in the <code>initialize</code> method. It has no effect if defined elsewhere in your algorithm. If you do not specify a slippage method, slippage defaults to <code>VolumeShareSlippage(volume_limit=0.025, price_impact=0.1)</code> (you can take up to 2.5% of a minute's trade volume).</p>
<p>To set slippage, use the <code>set_slippage</code> method and pass in <code>FixedSlippage</code>, <code>VolumeShareSlippage</code>, or a custom slippage model that you define.</p>
<p>By default, backtests use the <code>VolumeShareSlippage</code> model.</p>
<img alt="Slippage-main" class="help-image" height="73px" src="assets/slippage-main-f227d7ca04430c37fbc5ae76d9ddaa63.png" />
<h4 class='padding_20t padding_20b'>Volume Share Slippage</h4>
<p>In the <code>VolumeShareSlippage</code> model, the price you get is a function of your order size relative to the security's actual traded volume.  You provide a volume_limit cap (default 0.025), which limits the proportion of volume that your order can take up per bar.  For example: if the backtest is running in one-minute bars, and you place an order for 60 shares; then 1000 shares trade in each of the next several minute; and the volume_limit is 0.025; then your trade order will be split into three orders (25 shares, 25 shares, and 10 shares). Setting the volume_limit to 1.00 will permit the backtester to use up to 100% of the bar towards filling your order. Using the same example, this will fill 60 shares in the next minute bar.</p>
<p>The price impact constant (default 0.1) defines how large of an impact your order will have on the backtester's price calculation.  The slippage  is calculated by multiplying the price impact constant by the square of the ratio of the order to the total volume.  In our previous example, for the 25-share orders, the price impact is .1 * (25/1000) * (25/1000), or 0.00625%.  For the 10-share order, the price impact is .1 * (10/1000) * (10/1000), or .001%.</p>
<img alt="Volumesharesslippage" class="help-image" height="90px" src="assets/volumesharesslippage-b3a7fcf63cb74ac64010b146529986da.png" />
<h4 class='padding_20t padding_20b'>Fixed Slippage</h4>
<p>When using the <code>FixedSlippage</code> model, the size of your order does not affect the price of your trade execution.  You specify a 'spread' that you think is a typical bid/ask spread to use.  When you place a buy order, half of the spread is added to the price; when you place a sell order, half of the spread is subtracted from the price.</p>
<p>Fills under fixed slippage models are not limited to the amount traded in the minute bar. In the first non-zero-volume bar, the order will be completely filled. This requires you to be careful about ordering; naive use of fixed slippage models will lead to unrealistic fills, particularly with large orders and/or illiquid securities.</p>
<img alt="Fixed-slippage" class="help-image" height="75px" src="assets/fixed-slippage-9190b5ae5e296506517495493f551c14.png" />
<h4 class='padding_20t padding_20b'>Custom Slippage</h4>
<p>You can build a custom slippage model that uses your own logic to convert a stream of orders into a stream of transactions. In the <code>initialize()</code> function you must specify the slippage model to be used and any special parameters that the slippage model will use. Example:</p>
<pre class='prettyprint'>def initialize(context):&#x000A;    set_slippage(MyCustomSlippage())</pre>
<p>Your custom model must be a class that inherits from <code>slippage.SlippageModel</code> and implements <code>process_order(self, data, order)</code>.  The <code>process_order</code> method must return a tuple of (execution_price, execution_volume), which signifies the price and volume for the transaction that your model wants to generate.  The transaction is then created for you.</p>
<p>Your model gets passed the same <code>data</code> object that is passed to your other functions, letting you do any price or history lookup for any security in your model.  The <code>order</code> object contains the rest of the information you need, such as the asset, order size, and order type.</p>
<p>The <code>order</code> object has the following properties: <code>amount</code> (float), <code>asset</code> (Asset), <code>stop</code> and <code>limit</code> (float), and <code>stop_reached</code> and <code>limit_reached</code> (boolean).  The <code>trade_bar</code> object is the same as data[sid] in <code>handle_data</code> and has <code>open_price</code>, <code>close_price</code>, <code>high</code>, <code>low</code>, <code>volume</code>, and <code>sid</code>.</p>
<p>The <code>slippage.create_transaction</code> method takes the given order, the data object, and the price and amount calculated by your slippage model, and returns the newly constructed transaction.</p>
<p>Many slippage models' behavior depends on how much of the total volume traded is being captured by the algorithm.  You can use <code>self.volume_for_bar</code> to see how many shares of the current security have been traded so far during this bar. If your algorithm has many different orders for the same stock in the same bar, this is useful for making sure you don't take an unrealistically large fraction of the traded volume.</p>
<p>If your slippage model doesn't place a transaction for the full amount of the order, the order stays open with an updated <code>amount</code> value, and will be passed to <code>process_order</code> on the next bar.  Orders that have limits that have not been reached will not be passed to <code>process_order</code>.  Finally, if your transaction has 0 shares or more shares than the original order amount, an exception will be thrown.</p>
<p>Please see the <a href='help.html#sample-custom-slippage'>sample custom slippage model</a>.</p>
<h3 id='ide-commission'>Commission Models</h3>
<p>To set the cost of your trades, use the <code>set_commission</code> method and pass in <code>PerShare</code> or <code>PerTrade</code>.  Like the slippage model, <code>set_commission</code> must be used in the <code>initialize</code> method and has no effect if used elsewhere in your algorithm.  If you don't specify a commission, your backtest defaults to $0.0075 per share with a $1 minimum cost per trade.</p>
<p>You can define your trading cost in either dollars per share or dollars per trade.</p>
<img alt="Commission" class="help-image" height="83px" src="assets/commission-4a3b87bf94df536a8ab26ee629b84c85.png" />
<h3 id='overview-fetcher'>Fetcher - Load any CSV file</h3>
<p>Quantopian provides historical data since 2002 for US equities in minute bars. The US market data provides a backbone for financial analysis, but some of the most promising areas of research are finding signals in non-market data.  Fetcher provides your algorithm with access to external time series data. Any time series that can be retrieved as a CSV file via http or https can be incorporated into a Quantopian algorithm.</p>
<p>Fetcher lets Quantopian download CSV files and use them in your simulations. To use it, use <code>fetch_csv(url)</code> in your <code>initialize</code> method. <code>fetch_csv</code> will download the CSV file and parse it into a pandas dataframe.  You may then specify your own methods to modify the entire dataframe prior to the start of the simulation. During simulation, the rows of the CSV/dataframe are provided to your algorithm's <code>handle_data</code> and other functions as additional properties of the data parameter.</p>
<p>Best of all, your Fetcher data will play nicely with Quantopian's other data features:</p>
<ul>
<li>Use <code>record</code> to plot a time series of your fetcher data.</li>
<li>Create a trailing window of data using <code>history</code> to make statistical models using your fetcher data.</li>
<li>Your data will be streamed to your algorithm without look-ahead bias. That means if your backtest is currently at 10/01/2013 but your Fetcher data begins on 10/02/2013, your algorithm will not have access to the Fetcher data until 10/02/2013. You can account for this by checking the existence of your Fetcher field, see <a href='help.html#api-common-errors-key-error'>common errors</a> for more information.</li>
</ul>
<p>Fetcher supports two kinds of time series:</p>
<ul>
<li><strong>Security Information</strong>: data that is about individual securities, such as short interest for a stock</li>
<li><strong>Signals</strong>: data that stands alone, such as the Consumer Price Index, or the spot price of palladium</li>
</ul>
<p>For <strong>Security Info</strong>, your CSV file must have a column with header of 'symbol' which represents the symbol of that security on the date of that row.  Internally, Fetcher maps the symbol to the Quantopian security id (sid).  You can have many securities in a single CSV file.  To access your CSV data in handle_data:</p>
<pre class='prettyprint margin_50l'>## This algo imports sample short interest data from a CSV file for one security, &#x000A;## NFLX, and plots the short interest:&#x000A;&#x000A;def initialize(context):  &#x000A;    # fetch data from a CSV file somewhere on the web.&#x000A;    # Note that one of the columns must be named 'symbol' for &#x000A;    # the data to be matched to the stock symbol&#x000A;    fetch_csv('https://dl.dropboxusercontent.com/u/169032081/fetcher_sample_file.csv', &#x000A;               date_column = 'Settlement Date',&#x000A;               date_format = '%m/%d/%y')  &#x000A;    context.stock = symbol('NFLX')&#x000A;    &#x000A;def handle_data(context, data):    &#x000A;    record(Short_Interest = data.current(context.stock, 'Days To Cover'))</pre>
<p>Here is the sample CSV file. Note that for the Security Info type of import, one of the columns must be 'symbol'.</p>
<pre class='prettyprint margin_50l'>Settlement Date,symbol,Days To Cover&#x000A;9/30/13,NFLX,2.64484&#x000A;9/13/13,NFLX,2.550829&#x000A;8/30/13,NFLX,2.502331&#x000A;8/15/13,NFLX,2.811858&#x000A;7/31/13,NFLX,1.690317</pre>
<p>For <strong>Signals</strong>, your CSV file does not need a symbol column.  Instead, you provide it via the symbol parameter:</p>
<pre class='prettyprint margin_50l'>def initialize(context):&#x000A;    fetch_csv('http://yourserver.com/cpi.csv', symbol='cpi')&#x000A;&#x000A;def handle_data(context, data):&#x000A;    # get the cpi for this date&#x000A;    current_cpi = data.current('cpi','value')&#x000A;&#x000A;    # plot it&#x000A;    record(cpi=current_cpi)</pre>
<h4>Importing Files from Dropbox</h4>
<p>Many users find Dropbox to be a convenient way to access CSV files. To use Dropbox, place your file in the Public folder and use the 'Public URL'. A common mistake is to use a URL of format <code>https://www.dropbox.com/s/abcdefg/filename.csv</code>, which is a URL about the file, not the file itself. Instead, you should use the Public URL which has a format similar to <code>https://dl.dropboxusercontent.com/u/1234567/filename.csv</code>.</p>
<h4>Importing Files from Google Drive</h4>
<p>If you don't have a public Dropbox folder, you can also import a CSV from your Google Drive. To get the public URL for your file:</p>
<ol>
<li>Click on File &gt; Publish to the web.</li>
<li>Change the 'web page' option to 'comma-separated values (.csv)'.</li>
<li>Click the Publish button.</li>
<li>Copy and paste the URL into your Fetcher query.</li>
</ol>
<h4>Data Manipulation with Fetcher</h4>
<p>If you produce the CSV, it is relatively easy to put the data into a good format for Fetcher. First decide if your file should be a signal or security info source, then build your columns accordingly.</p>
<p>However, you may not always have control over the CSV data file. It may be maintained by someone else, or you may be using a service that dynamically generates the CSV. <a href='http://www.quandl.com'>Quandl</a>, for example, provides a REST API to access many curated datasets as CSV. While you could download the CSV files and modify them before using them in Fetcher, you would lose the benefit of the nightly data updates. In most cases it's better to request fresh files directly from the source.</p>
<p>Fetcher provides two ways to alter the CSV file:</p>
<ul>
<li><code>pre_func</code> specifies the method you want to run on the pandas dataframe containing the CSV immediately after it was fetched from the remote server.  Your method can rename columns, reformat dates, slice or select data - it just has to return a dataframe.</li>
<li><code>post_func</code> is called after Fetcher has sorted the data based on your given date column.  This method is intended for time series calculations you want to do on the entire dataset, such as timeshifting, calculating rolling statistics, or adding derived columns to your dataframe.  Again, your method should take a dataframe and return a dataframe.</li>
</ul>
<h4>Live Trading and Fetcher</h4>
<p>When Fetcher is used in Live Trading or Paper Trading, the <code>fetch_csv()</code> command is invoked once per trading day, when the algorithm warms up, before market open. It's important that the fetched data with dates in the past be maintained so that warm up can be performed properly; Quantopian does not keep a copy of your fetched data, and algorithm warmup will not work properly if past data is changed or removed. Data for 'today' and dates going forward can be added and updated.</p>
<p>Any updates to the CSV file should happen before <strong>midnight Eastern Time</strong> for the data to be ready for the next trading day.</p>
<h4>Working With Multiple Data Frequencies</h4>
<p>When pulling in external data, you need to be careful about the data frequency to prevent look-ahead bias. All Quantopian backtests are run on minutely frequency.  If you are fetching daily data, the daily row will be fetched at the beginning of the day, instead of the end of day.  To guard against the bias, you need to use the <code>post_func</code> function. For more information see <code>post_func</code> <a href='help.html#api-fetchcsv'>API documentation</a> or take a look at this <a href='https://www.quantopian.com/posts/ranking-and-trading-on-days-to-cover'>example algorithm</a>.</p>
<p><code>History()</code> is not supported on fetched data. For a workaround, see this <a href= 'https://www.quantopian.com/posts/method-to-get-historic-values-from-fetcher-data'>community forum post</a>.</p>
<p>For more information about Fetcher, go to the <a href='help.html#api-fetchcsv'>API documentation</a> or look at the <a href='help.html#sample-csv-1'>sample algorithms</a>.</p>
<h4>Figuring out what assets came from Fetcher</h4>
<p>It can be useful to know which assets currently have Fetcher signals for a given day.  <code>data.fetcher_assets</code> returns a list of assets that, for the given backtest or live trading day, are active from your Fetcher file.</p>
<p>Here's an example file with ranked securities:</p>
<pre class='prettyprint margin_50l'>symbol, start date, stock_score&#x000A;AA,     2/13/12,     11.7&#x000A;WFM,    2/13/12,     15.8&#x000A;FDX,    2/14/12,     12.1&#x000A;M,      2/16/12,     14.3</pre>
<p>You can backtest the code below during the dates 2/13/2012 - 2/18/2012. When you use this sample file and algorithm, <code>data.fetcher_assets</code> will return, for each day:</p>
<ul>
<li>2/13/2012: AA, WFM</li>
<li>2/14/2012: FDX</li>
<li>2/15/2012: FDX (forward filled because no new data became available)</li>
<li>2/16/2012: M</li>
</ul>
<p>Note that when using this feature in live trading, it is important that all historical data in your fetched data be accessible and unchanged. We do not keep a copy of fetched data; it is reloaded at the start of every trading day. If historical data in the fetched file is altered or removed, the algorithm will not run properly. New data should always be appended to (not overwritten over) your existing Fetcher .csv source file. In addition, appended rows cannot contain dates in the past. For example, on May 3rd, 2015, a row with the date May 2nd, 2015, could not be appended in live trading.</p>
<h3 id='ide-validation'>Validation</h3>
<p>Our IDE has extensive syntax and validation checks. It makes sure your algorithm is valid Python, fulfills our API, and has no obvious runtime exceptions (such as dividing by zero).  You can run the validation checks by clicking on the Build button (or pressing control-B), and we'll run them automatically right before starting a new backtest.</p>
<p>Errors and warnings are shown in the window on the right side of the IDE.  Here's an example where the log line is missing an end quote.</p>
<img alt="Help-validation" class="help-image" height="100px" src="assets/help-validation-3753ed1ab4197d3faffff61185274d2b.png" />
<p>When all errors and warnings are resolved, the Build button kicks off a quick backtest. The quick backtest is a way to make sure that the algorithm roughly does what you want it to, without any errors.</p>
<p>Once the algorithm is running roughly the way you'd like, click the 'Full Backtest' button to kick off a full backtest with minute-bar data.</p>
<h3 id='ide-module-import'>Module Import</h3>
<p>Only specific, whitelisted portions of Python modules can be imported. Select portions of the following libraries are allowed. If you need a module that isn't on this list, please <a href='mailto:feedback@quantopian.com'>let us know.</a></p>
<ul>
<li><code>bisect</code></li>
<li><code>blaze</code></li>
<li><code>brokers</code></li>
<li><code>cmath</code></li>
<li><code>collections</code></li>
<li><code>copy</code></li>
<li><code>cvxopt</code></li>
<li><code>datetime</code></li>
<li><code>functools</code></li>
<li><code>heapq</code></li>
<li><code>itertools</code></li>
<li><code>math</code></li>
<li><code>numpy</code></li>
<li><code>odo</code></li>
<li><code>operator</code></li>
<li><code>pandas</code></li>
<li><code>pykalman</code></li>
<li><code>pytz</code></li>
<li><code>quantopian</code></li>
<li><code>Queue</code></li>
<li><code>re</code></li>
<li><code>scipy</code></li>
<li><code>sklearn</code></li>
<li><code>sqlalchemy</code></li>
<li><code>statsmodels</code></li>
<li><code>talib</code></li>
<li><code>time</code></li>
<li><code>zipline</code></li>
<li><code>zlib</code></li>
</ul>
<h3 id='ide-collaboration'>Collaboration</h3>
<p>You can collaborate in real-time with other Quantopian members on your algorithm. In the IDE, press the “Collaborate” button and enter your friend’s email address. Your collaborators will receive an email letting them know they have been invited. They will also see your algorithm listed in their <a href="algorithms.html">Algorithms Library</a> with a collaboration icon. If your collaborator isn't yet a member of Quantopian, they will have to register before they can see your algorithm.</p>
<img alt="Button" class="help-image" height="100px" src="assets/button-daa786ce9ae71e3d6bfb6f7997cb5d1a.png" />
<p class='bold'>The collab experience is fully coordinated:</p>
<ul>
<li>The code is changed on all screens in real time.</li>
<li>When one collaborator &quot;Builds&quot; a backtest, all of the collaborators see the backtest results, logging, and/or errors.</li>
<li>There is a chat tab for you to use while you collaborate.</li>
</ul>
<img alt="Collab_ide" class="help-image" height="153px" src="assets/collab_ide-1de8b51cad4c85b75046032d24936b74.png" />
<p>Technical Details</p>
<ul>
<li>Only the owner can invite other collaborators, deploy the algorithm for live trading, or delete the algorithm.</li>
<li>There isn't a technical limit on number of collaborators, but there is a practical limit. The more collaborators you have, the more likely that you'll notice a performance problem. We'll improve that in the future.</li>
<li>To connect with a member, search their profile in the forums and send them a private message. If they choose to share their email address with you, then you can invite them to collaborate.</li>
</ul>
<h2 id='backtests'>Running Backtests</h2>
<p>You can set the start date, end date, and starting capital used by the backtest in the IDE.</p>
<img alt="Help-ide2" class="help-image" height="300px" src="assets/help-ide2-2467c15e87923cfa38ee5d34286730b0.png" />
<p>SPY, an ETF tracking the S&P 500, is the benchmark used for algorithms simulated in the backtest. It represents the total returns and reinvests the dividends to model the market performance.  You can also <a href='help.html#overview-setbenchmark'>set your own benchmark</a> in your algorithm.</p>
<p>To create a new backtest, click the 'Run Full Backtest' button from the IDE. That button appears once your algorithm successfully validates. Press the 'Build' button to start the validation if the 'Run Full Backtest' button is not visible in the upper-right of the IDE.</p>
<p>We also provide a Backtests Page that has a summary of all backtests run against an algorithm. To go to the Backtests page, either click the Backtest button at the top right of the IDE, or, from the My Algorithms page click the number of backtests that have been run.  The backtests page lists all the backtests that have been run for this algorithm, including any that are in progress. You can view an existing or in-progress backtest by clicking on it. Closing the browser will not stop the backtest from running. Quantopian runs in the cloud and it will continue to execute your backtest until it finishes running. If you want to stop the backtest, press the Cancel button.</p>
<h3 id='debugger'>Debugger</h3>
<p>The debugger gives you a powerful way to inspect the details of a running backtest.  By setting breakpoints, you can pause execution and examine variables, order state, positions, and anything else your backtest is doing.</p>
<h5>Using the Debugger</h5>
<p>In the IDE, click on a line number in the gutter to set a breakpoint. A breakpoint can be set on any line except comments and method definitions.  A blue marker appears once the breakpoint is set.</p>
<img alt="Help-debugger-breakpoint" class="help-image" src="assets/help-debugger-breakpoint-f422eeaf2c5626a185497a9579b3a3d7.png" style="width:600px" />
<p>To set a conditional breakpoint, right-click on a breakpoint's blue marker and click 'Edit Breakpoint'.  Put in some Python code and the breakpoint will hit when this condition evaluates to true. In the example below, this breakpoint hits when the price of Apple is above $100. Conditional breakpoints are shown in yellow in the left-hand gutter.</p>
<img alt="Help-conditional-breakpoint" class="help-image" src="assets/help-conditional-breakpoint-44798e65b44568cd486e5ef2e4d5cf00.png" style="width:500px" />
<p>You can set an unlimited number of breakpoints.  Once the backtest has started, it will stop when execution gets to a line that has a breakpoint, at which point the backtest is paused and the debug window is shown. In the debugger, you can then query your variables, orders and portfolio state, data, and anything else used in your backtest.  While the debugger window is active, you can set and remove other breakpoints.</p>
<img alt="Help-debugger-example" class="help-image" src="assets/help-debugger-example-0f13b03aa5e52764bc42f42248282ebd.png" style="width:900px" />
<p>To inspect an object, enter it in the debug window and press enter.  Most objects will be pretty-printed into a tree format to enable easy inspection and exploration.</p>
<p>The following commands can be used in the debugger window:</p>
<table class='table table-bordered table-condensed'>
<thead>
<tr class='white-container'>
<td>Keyboard Shortcut</td>
<td>Action</td>
</tr>
</thead>
<tbody>
<tr>
<td>.c or .continue</td>
<td>Resume backtest until it triggers the next breakpoint or an exception is raised.</td>
</tr>
<tr>
<td>.n or .next</td>
<td>Executes the next line of code. This steps over the next expression.</td>
</tr>
<tr>
<td>.s or .step</td>
<td>Executes the next line of code. This steps into the next expression, following function calls.</td>
</tr>
<tr>
<td>.r or .return</td>
<td>Execute until you are about to return from the current function call.</td>
</tr>
<tr>
<td>.f or .finish</td>
<td>Disables all breakpoints and finishes the backtest.</td>
</tr>
<tr>
<td>.clear</td>
<td>Clears the data in the debugger window.</td>
</tr>
<tr>
<td>.h or .help</td>
<td>Shows the command shortcuts for the debugger.</td>
</tr>
</tbody>
</table>
<h5>Technical Details</h5>
<ul>
<li>The debugger is available in the IDE. It is not available on the Full Backtest screen.</li>
<li>You can edit your code during a debugging session, but those edits aren't used in the debugger until a new backtest is started.</li>
<li>After 10 minutes of inactivity in the IDE, any breakpoints will be suspended and the backtest will automatically finish running.</li>
<li>After 50 seconds, the breakpoint commands will timeout. This is the same amount of time given for 1 handle_data call.</li>
</ul>
<h3 id='backtests-results'>Backtest results</h3>
<p>Once a full backtest starts, we load all the trading events for the securities that your algorithm specified, and feed them to your algorithm in time order.  Results will start streaming in momentarily after the backtest starts.</p>
<p>Here is a snapshot of a backtest results page.  Mouse over each section to learn more.</p>
<div class='results-map'>
<img alt="Help-backtest-results" class="help-image" height="387px" src="assets/help-backtest-results-ad9fafde0d120e4ce7e0c47da1906519.png" />
<div class='overall-results'>Overall results</div>
<div class='performance-chart'>Cumulative performance and benchmark overlay</div>
<div class='daily-returns'>Daily and weekly P/L</div>
<div class='transactions-chart'>Transactions chart</div>
<div class='result-details'>Result details</div>
<div class='test-details'>Backtest settings and status</div>
</div>
<p><strong>Backtest settings and status</strong>: Shows the initial settings for the backtest, the progress bar when the backtest is in progress, and the final state once the test is done.  If the backtest is cancelled, exceeds its max daily loss, or have runtime errors, that information will be displayed here.</p>
<p><strong>Result details</strong>: Here's where you dive into the details of your backtest results.  You can examine every transaction that occurred during the backtest, see how your positions evolved over time, and look at detailed risk metrics.  For the risk metrics, we show you 1, 3, 6, and 12-month windows to provide more granular breakdowns</p>
<p><strong>Overall results</strong>: This is the overall performance and risk measures of your backtest.  These numbers will update during the course of the backtest as new data comes in.</p>
<p><strong>Cumulative performance and benchmark overlay</strong>: Shows your algorithm's performance over time (in blue) overlaid with the benchmark (in red).</p>
<p><strong>Daily and weekly P/L</strong>: Shows your P/L per day or week, depending on the date range selected.</p>
<p><strong>Transactions chart</strong>: Shows all the cumulative dollar value of all the buys and sells your algorithm placed, per day or week.  Buys are shown as positive blue, and sells as negative reds.</p>
<h2 id='live-trading'>Live Trade Your Algorithm with your Broker</h2>
<p>You can live trade your algorithm with <a href='https://www.interactivebrokers.com' target='_blank'>Interactive Brokers</a> using your real money and paper broker account, or with <a href='https://www.robinhood.com' target='_blank'>Robinhood</a> using your real money broker account..</p>
<p>To deploy a real money algorithm, follow these steps:</p>
<ol>
<li>Enter your broker credentials in your <a href='users/sign_up.html#trading' target='_blank'>Quantopian trading profile</a>.</li>
<li>Run a full backtest.</li>
<li>Click the 'Live Trade Algorithm' button in the top-right corner.</li>
<li>Choose the Broker option to choose your configured broker. The non-broker Quantopian option is free paper trading using 15-minute delayed data on the platform.</li>
<li>Authenticate your brokerage account and the live trading dashboard is loaded.</li>
</ol>
<p>For a detailed walk-through, here is a <a href='https://www.youtube.com/watch?v=hye1L86s43M'>step-by-step overview video</a> of deploying a real money algorithm.</p>
<h3 id='broker-fields'>Broker Account Fields</h3>
<p>In your algorithm code, you can access the <a href='https://www.interactivebrokers.com/php/whiteLabel/Screens/Account_Information.htm' target='_blank'>account information</a> passed from the broker. This is useful to incorporate your margin, settled cash, liquidity, among other fields into the trading logic.</p>
<p>In <strong>backtesting,</strong> it will default to values from your simulated portfolio. In <strong>live trading</strong>, the fields will populate with data passed from the broker.</p>
<p><strong>If the broker has not yet reported a value, the field will report <code>None</code> until new data is present</strong>. Below is an example showing how to check if the account field has been reported. The account information will be accessed once per minute, at every call of <code>handle_data</code>. Once a value has been reported, it will be forward filled until the next value is reported by the broker.</p>
<pre class='prettyprint'>def handle_data(context,data):&#x000A;    if context.account.buying_power is None or context.account.buying_power < 10000:&#x000A;      return&#x000A;&#x000A;    else:&#x000A;      order_value(symbol('NFLX'), context.account.settled_cash)</pre>
<p>See the <a href='help.html#api-account'>API information</a> section for the available broker fields.</p>
<h3 id='ide-trading-guards'>Trading Guards</h3>
<p>There are several trading guards you can place in your algorithm to prevent unexpected behavior.  All the guards are enforced when orders are placed. These guards are set in the <code>initialize</code> function.</p>
<p class='bold'>Exclude Specific Securities</p>
<p>You can prevent the algorithm from trading specific securities by using <code>set_do_not_order_list</code>. If the algorithm attempts to order any security in the list, it will stop trading and throw an exception. You can use the built-in leveraged ETF list provided by Quantopian or create a customized list of securities.</p>
<p>We've built a list for you that lists all the leveraged ETFs.  To use this list, use <code>set_do_not_order_list(security_lists.leveraged_etf_list)</code>. For a trader trying to track their own leverage levels, these ETFs are a challenge. The <a href='open.html'>Quantopian Open</a> prohibits trading in these ETFs for that reason.</p>
<p>As shown in the example below, within <code>handle_data</code>you can test for a security's membership in a pre-built list.  Quantopian-provided lists will be updated from time to time as tradeable ETFs are offered and withdrawn on the market.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # create the trading guard to avoid over-leveraged ETFs &#x000A;  set_do_not_order_list(security_lists.leveraged_etf_list)&#x000A;&#x000A;def handle_data(context,data):&#x000A;  # the point in time lists allow for in/not in checks and iteration&#x000A;  # the list is point-in-time and allows for checks and iterations&#x000A;  if symbol('AAPL') not in security_lists.leveraged_etf_list:&#x000A;    order_target(symbol('AAPL'), 100)&#x000A;&#x000A;  # view the contents of the list&#x000A;  for etf in security_lists.leveraged_etf_list:&#x000A;    print '{s} is a leveraged etf'.format(s=etf)</pre>
<p class='bold'>Long Only</p>
<p>Specify <code>long_only</code> to prevent the algorithm from taking short positions. It does not apply to existing open orders or positions in your portfolio.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will raise an exception if it attempts to place an &#x000A;  # order which would cause us to hold negative shares of any security.&#x000A;  set_long_only()</pre>
<p class='bold'>Maximum Order Count</p>
<p>Sets a limit on the number of orders that can be placed by this algorithm in a single day. In the <code>initialize</code> function you can enter the <code>set_max_order_count</code>, it will have no effect if placed elsewhere in the algorithm.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will raise an exception if more than 50 orders are placed in a day&#x000A;  set_max_order_count(50)</pre>
<p class='bold'>Maximum Order Size</p>
<p>Sets a limit on the size of any single order placed by this algorithm.  This limit can be set in terms of number of shares, dollar value, or both.  The limit can optionally be set for a given security; if the security is not specified, it applies to all securities. This must be run in the <code>initialize</code> function.</p>
<pre class='prettyprint'>def initialize(context):&#x000A;  # Algorithm will raise an exception if we attempt to order more than &#x000A;  # 10 shares or 1000 dollars worth of AAPL in a single order.&#x000A;  set_max_order_size(symbol('AAPL'), max_shares=10, max_notional=1000.0)</pre>
<p class='bold'>Maximum Position Size</p>
<p>Sets a limit on the absolute magnitude of any position held by the algorithm for a given security. This limit can be set in terms of number of shares, dollar value, or both. A position can grow beyond this limit because of market movement; the limit is only imposed at the time the order is placed. The limit can optionally be set for a given security; if the security is not specified, it applies to all securities. This must be run in the <code>initialize</code> function.</p>
<pre class='prettyprint'>def initialize(context): &#x000A;  # Algorithm will raise an exception if we attempt to hold more than &#x000A;  # 30 shares or 2000 dollars worth of AAPL.&#x000A;  set_max_position_size(symbol('AAPL'), max_shares=30, max_notional=2000.0)</pre>
<h3 id='zipline'>Zipline</h3>
<p>Zipline is our <a href='http://zipline.io' target='_blank'>open-sourced</a> engine that powers the backtester in the IDE. You can see the <a href='https://github.com/quantopian/zipline' target='_blank'>code repository</a> in Github and contribute pull requests to the project. There is a <a href='https://groups.google.com/forum/#!forum/zipline' target='_blank'>Google group</a> available for seeking help and facilitating discussions. For other questions, please contact <a href='mailto:opensource@quantopian.com'>opensource@quantopian.com</a>. You can use Zipline to develop your strategy offline and then port to Quantopian for paper trading and live trading using the <code>get_environment</code> <a href='help.html#api-get-environment'>method</a>.</p>
<h2 id='api-doco'>API Documentation</h2>
<h3 id='api-toplevel'>Methods to implement</h3>
<p>Your algorithm is required to implement one method: <code>initialize</code>.  Two other mehtods, <code>handle_data</code> and <code>before_trading_start</code> are optional.</p>
<div class='api-method'>
<p class='api-code' id='api-initialize'><code>initialize(context)</code></p>
<p>Called once at the very beginning of a backtest.  Your algorithm can use this method to set up any bookkeeping that you'd like.</p>
<p>The context object will be passed to all the other methods in your algorithm.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>context</span>:
<span>An initialized and empty Python dictionary.  The dictionary has been augmented so that properties can be accessed using dot notation as well as the traditional bracket notation.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
<div class='section-title'>Example</div>
<pre class='prettyprint'>def initialize(context):&#x000A;    context.notional_limit = 100000</pre>
</div>
<div class='api-method'>
<p class='api-code' id='api-handle_data'><code>handle_data(context, data)</code></p>
<p>Called every minute.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>context</span>:
<span>Same context object in <code>initialize</code>, stores any state you've defined, and stores portfolio object.</span>
</p>
<p>
<span class='parameter'>data</span>:
<span>An object that provides methods to get price and volume data, check whether a security exists, and check the last time a security traded.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
<div class='section-title'>Example</div>
<pre class='prettyprint'>def handle_data(context, data):&#x000A;    # all your algorithm logic here&#x000A;    # ...&#x000A;    order_target_percent(symbol('AAPL'), 1.0)&#x000A;    # ...</pre>
</div>
<div class='api-method'>
<p class='api-code' id='api-before_trading_start'><code>before_trading_start(context, data)</code></p>
<p>Optional. Called daily prior to the open of market. Orders cannot be placed inside this method.  The primary purpose of this method is to use Pipeline to create a set of securities that your algorithm will use.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>context</span>:
<span>Same context object as in <code>handle_data</code>.</span>
</p>
<p>
<span class='parameter'>data</span>:
<span>Same data object in <code>handle_data</code>.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
</div>
<h3 class='margin_30t' id='api-data-methods'>Data Methods</h3>
<p>The <code>data</code> object passed to <code>handle_data</code>, <code>before_trading_start</code>, and all scheduled methods is the algorithm's gateway to all of Quantopian's minutely pricing data.</p>
<div class='api-method'>
<p class='api-code' id='api-data-current'><code>data.current(assets, fields)</code></p>
<p>Returns the current value of the given assets for the given fields at the current algorithm time.  Current values are the as-traded price (except if they have to be forward-filled across an adjustment boundary).</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>assets</span>:
<span>Asset or iterable of Assets.</span>
</p>
<p>
<span class='parameter'>fields</span>:
<span>string or iterable of strings.  Valid values are 'price', 'last_traded', 'open', 'high', 'low', 'close', 'volume', or column names in Fetcher files.</span>
</p>
<div class='section-title'>
<span>Returns</span>
<p>If a single asset and a single field are passed in, a scalar value is returned.</p>
<p>If a single asset and a list of fields are passed in, a pandas Series is returned whose indices are the fields, and whose values are scalar values for this asset for each field.</p>
<p>If a list of assets and a single field are passed in, a pandas Series is returned whose indices are the assets, and whose values are scalar values for each asset for the given field.</p>
<p>If a list of assets and a list of fields are passed in, a pandas DataFrame is returned, indexed by asset.  The columns are the requested fields, filled with the scalar values for each asset for each field.</p>
</div>
<div class='section-title notes'>
<span>Notes</span>
<p>
'price' returns the last known close price of the asset.  If there is no last known value (either because the asset has never traded, or because it has delisted) <code>NaN</code> is returned.  If a value is found, and we had to cross an adjustment boundary (split, dividend, etc) to get it, the value is adjusted before being returned.  <strong>'price' is always forward-filled.</strong>
</p>
<p>
'last_traded' returns the date of the last trade event of the asset, even if the asset has stopped trading. If there is no last known value, <code>pd.NaT</code> is returned.
</p>
<p>
'volume' returns the trade volume for the current simulation time.  If there is no trade this minute, 0 is returned.
</p>
<p>
'open', 'high', 'low', and 'close' return the relevant information for the current trade bar.  If there is no current trade bar, <code>NaN</code> is returned.  <strong>These fields are never forward-filled.</strong>
</p>
</div>
</div>
<div class='api-method'>
<p class='api-code' id='api-data-history'><code>data.history(assets, fields, bar_count, frequency)</code></p>
<p>Returns a window of data for the given assets and fields. This data is adjusted for splits, dividends, and mergers as of the current algorithm time.</p>
<p>The semantics of missing data are identical to the ones described in the notes for <code>data.current</code>.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>assets</span>:
<span>Asset or iterable of Assets.</span>
</p>
<p>
<span class='parameter'>fields</span>:
<span>string or iterable of strings.  Valid values are 'price', 'last_traded', 'open', 'high', 'low', 'close', 'volume', or column names in Fetcher files.</span>
</p>
<p>
<span class='parameter'>bar_count</span>:
<span>integer number of bars of trade data.</span>
</p>
<p>
<span class='parameter'>frequency</span>:
<span>string. '1m' for minutely data or '1d' for daily date</span>
</p>
<div class='section-title returns'>
<span>Returns</span>
<p>Series or DataFrame or Panel, depending on the dimensionality of the 'assets' and 'fields' parameters.</p>
<p>If single asset and field are passed in, the returned Series is indexed by date.</p>
<p>If multiple assets and single field are passed in, the returned DataFrame is indexed by date, and has assets as columns.</p>
<p>If a single asset and multiple fields are passed in, the returned DataFrame is indexed by date, and has fields as columns.</p>
<p>If multiple assets and multiple fields are passed in, the returned Panel is indexed by field, has dt as the major axis, and assets as the minor axis.</p>
</div>
<div class='section-title notes'>
<span>Notes</span>
<p>
These notes are identical to the information for <code>data.current</code>.
</p>
<p>
'price' returns the last known close price of the asset.  If there is no last known value (either because the asset has never traded, or because it has delisted) <code>NaN</code> is returned.  If a value is found, and we had to cross an adjustment boundary (split, dividend, etc) to get it, the value is adjusted before being returned.  <strong>'price' is always forward-filled.</strong>
</p>
<p>
'last_traded' returns the date of the last trade event of the asset, even if the asset has stopped trading. If there is no last known value, <code>pd.NaT</code> is returned.
</p>
<p>
'volume' returns the trade volume for the current simulation time.  If there is no trade this minute, 0 is returned.
</p>
<p>
'open', 'high', 'low', and 'close' return the relevant information for the current trade bar.  If there is no current trade bar, <code>NaN</code> is returned.  <strong>These fields are never forward-filled.</strong>
</p>
</div>
</div>
<div class='api-method'>
<p class='api-code' id='api-data-can_trade'><code>data.can_trade(assets)</code></p>
<p>For the given asset or iterable of assets, returns true if the security has a known last price and is currently listed on a supported exchange.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>assets</span>:
<span>Asset or iterable of Assets.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>boolean or Series of booleans, indexed by asset.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-data-is_stale'><code>data.is_stale(assets)</code></p>
<p>For the given asset or iterable of assets, returns true if the asset has ever traded and there is no trade data for the current simulation time.</p>
<p>If the asset has never traded, returns False.</p>
<p>If the current simulation time is not a valid market time, we use the current time to check if the asset is alive, but we use the last market minute/day for the trade data check.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>assets</span>:
<span>Asset or iterable of Assets.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>boolean or Series of booleans, indexed by asset.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-date-fetcher_assets'><code>data.fetcher_assets</code> (property)</p>
<p>Returns a list of assets from the algorithm's Fetcher file that are active for the current simulation time.  This lets your algorithm know what assets are available in the Fetcher file.</p>
<div class='section-title'>Returns</div>
<p>
<span>A list of assets from the algorithm's Fetcher file that are active for the current simulation time.</span>
</p>
</div>
<h3 class='margin_30t' id='api-order-methods'>Order Methods</h3>
<p>Within your algorithm, there are some order methods you can use. The family of <code>order_target</code> functions only consider the status of filled orders, not open orders, when making their calculations to the target position. Here is an <a href= 'https://www.quantopian.com/posts/order-target-percent-ordering-too-much'>example</a> of how to prevent over-ordering.</p>
<div class='api-method'>
<p class='api-code' id='api-order'><code>order(security, amount, style=OrderType)</code></p>
<p>Places an order for the specified security of the specified number of shares.  Order type is inferred from the parameters used. If only security and amount are used as parameters, the order is placed as a market order.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares.  Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>OrderType</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-order-value'><code>order_value(security, amount, style=OrderType) </code></p>
<p>Place an order by desired value rather than desired number of shares. Placing a negative order value will result in selling the given value. Orders are always truncated to whole shares.</p>
<div class='section-title'>Example</div>
<p>Order AAPL worth up to $1000: <code>order_value(symbol('AAPL'), 1000)</code>. If price of AAPL is $105 a share, this would buy 9 shares, since the partial share would be truncated (discarding slippage and transaction cost).</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>Floating point dollar value of shares, truncated to a whole share. Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>OrderType</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-order-percent'><code>order_percent(security, amount, style=OrderType)</code></p>
<p>Places an order in the specified security corresponding to the given percent of the current portfolio value, which is the sum of the positions value and ending cash balance. Placing a negative percent order will result in selling the given percent of the current portfolio value.  Orders are always truncated to whole shares. Percent must be expressed as a decimal (0.50 means 50%).</p>
<div class='section-title'>Example</div>
<p><code>order_percent(symbol('AAPL'), .5)</code> will order AAPL shares worth 50% of current portfolio value. If AAPL is $100/share and the portfolio value is $2000, this buys 10 shares (discarding slippage and transaction cost).</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares.  Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>OrderType</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-order-target'><code>order_target(security, amount, style=OrderType)</code></p>
<p>Places an order to adjust a position to a target number of shares. If there is no existing position in the security, an order is placed for the full target number. If there is a position in the security, an order is placed for the difference between the target number of shares and the current number of shares. Placing a negative target order will result in a short position equal to the negative number specified. </p>
<div class='section-title'>Example</div>
<p>If the current portfolio has 5 shares of AAPL and the target is 20 shares, <code>order_target(symbol('AAPL'), 20)</code> orders 15 more shares of AAPL.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares.  Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>OrderType</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id, or None if there is no difference between the target position and current position.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-order-target-value'><code>order_target_value(security, amount, style=OrderType)</code></p>
<p>Places an order to adjust a position to a target value. If there is no existing position in the security, an order is placed for the full target value. If there is a position in the security, an order is placed for the difference between the target value and the current position value. Placing a negative target order will result in a short position equal to the negative target value. Orders are always truncated to whole shares</p>
<div class='section-title'>Example</div>
<p>If the current portolio holds $500 worth of AAPL and the target is $2000, <code>order_target_value(symbol('AAPL'), 2000)</code> orders $1500 worth of AAPL (rounded down to the nearest share).</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares.  Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>OrderType</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id, or None if there is no difference between the target position and current position.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-order-target-percent'><code>order_target_percent(security, percent, style=type) </code></p>
<p>Place an order to adjust a position to a target percent of the current portfolio value.  If there is no existing position in the security, an order is placed for the full target percentage. If there is a position in the security, an order is placed for the difference between the target percent and the current percent.  Placing a negative target percent order will result in a short position equal to the negative target percent. Portfolio value is calculated as the sum of the positions value and ending cash balance. Orders are always truncated to whole shares, and percentage must be expressed as a decimal (0.50 means 50%).</p>
<div class='section-title'>Example</div>
<p>If the current portfolio value is 5% worth of AAPL and the target is to allocate 10% of the portfolio value to AAPL, <code>order_target_percent(symbol('AAPL'), 0.1)</code> will place an order for the difference, in this case ordering 5% portfolio value worth of AAPL.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>percent</span>:
<span>The portfolio percentage allocated to the security. Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>type</span>:
<span>(optional) Specifies the order style and the default is a market order. The available order styles are:</span>
<ul>
<li>style=MarketOrder(exchange)</li>
<li>style=StopOrder(stop_price, exchange)</li>
<li>style=LimitOrder(limit_price, exchange)</li>
<li>style=StopLimitOrder(limit_price=price1, stop_price=price2, exchange)</li>
</ul>
<p>Click <a href='help.html#exchange-routing'>here</a> to view an example for exchange routing.</p>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id, or None if there is no difference between the target position and current position.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-cancel-order'><code>cancel_order(order)</code></p>
<p>Attempts to cancel the specified order. Cancel is attempted asynchronously.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>order</span>:
<span>Can be the order_id as a string or the order object.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-get-open-orders'><code>get_open_orders(security)</code></p>
<p>If security is None or not specified, returns all open orders.  If security is specified, returns open orders for that security</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>sid</span>:
<span>(optional) A security object. Can be also be None.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>If sid is unspecified or None, returns a dictionary keyed by security id. The dictionary contains a list of orders for each sid, oldest first.  If a sid is specified, returns a list of open orders for that sid, oldest first.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-get-order'><code>get_order(order)</code></p>
<p>Returns the specified order. The order object is discarded at the end of <code>handle_data</code>.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>order</span>:
<span>Can be the order_id as a string or the order object.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>returns an order object that is read/writeable but is discarded at the end of <code>handle_data</code>.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-get-fundamentals'><code>get_fundamentals(query, filter_ordered_nulls)</code></p>
<p>Loads Morningstar fundamental data based on the query parameter.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>query</span>:
<span>A query built using <a href= 'http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying' target=_blank>SQLAlchemy's syntax</a> for accessing fundamental data. SQLAlchemy is an ORM. Below is a simple example of the SQLAlchemy syntax:</span>
<pre class='prettyprint margin_50l'># Retrieve fundamental data based on the PE ratio and economic sector&#x000A;# Then, filter results to a specific sector, based on PE value.&#x000A;# Finally, return the first 4 results from an ascending list&#x000A;query(&#x000A;    fundamentals.valuation_ratios.pe_ratio,&#x000A;    fundamentals.asset_classification.morningstar_sector_code)&#x000A;    .filter(fundamentals.asset_classification.morningstar_sector_code == 311)&#x000A;    .filter(fundamentals.valuation_ratios.pe_ratio > 20)&#x000A;    .filter(fundamentals.valuation_ratios.pe_ratio < 50)&#x000A;    .order_by(fundamentals.valuation_ratios.pe_ratio).limit(4)&#x000A;)</pre>
<p>Within Quantopian, specific SQLAlchemy methods are whitelisted for your use within the Quantopian IDE. These methods are <code>filter</code>, <code>filter_by</code>, <code>first</code>, <code>offset</code>, <code>order_by</code>, <code>limit</code>, <code>exists</code>, <code>group_by</code>, <code>having</code>.</p>
<br>
<p>Some SQLAlchemy column operators have been whitelisted use within the Quantopian IDE: <code>asc</code>, <code>desc</code>, <code>nullsfirst</code>, <code>nullslast</code>, <code>label</code>, <code>in_</code>, <code>like</code>, <code>is_</code>, <code>contains</code> (and corresponding negating operators)</p>
<br>
</p>
<p>
<span class='parameter'>filter_ordered_nulls</span>:
<span>Optional. Defaults to True. When True, if you are sorting the query results via an `order_by` method, any row with a NULL value in the sorted column will be filtered out. Setting to False overrides this behavior and provides you with rows with a NULL value for the sorted column.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>A Pandas dataframe for use in `context` and for updating your universe with `update_universe`.</span>
</p>
</div>
<h3 class='margin_30t' id='api-order-execution'>Order Execution in IB</h3>
<p>Within your algorithm, there are special execution styles for live trading:</p>
<div class='api-method'>
<h4 class='padding_10b'>Relative Order</h4>
<p class='api-code' id='api-relative-order'><code>order(security, amount, style=RelativeOrder(offset, pct_offset, limit_price, exchange))</code></p>
<p>RelativeOrder is an order type with Interactive Brokers (IB) that allows you to seek a more aggressive price than the National Best Bid and Offer in live trading. By placing more aggressive bids and offers than the current best bids and offers, you can increase your odds of filling the order. This can be placed as a fixed off-set amount (e.g. two cents higher on a buy, two cents lower on a sell) and/or as a percentage offset. You can combine a fixed amount-offset with a percentage offset. The quotes are automatically adjusted as the markets move, to remain aggressive.</p>
<div class='section-title'></div>
<p class='bold'>To use this order type, you need to have a subscription to IB's market data for Relative Orders. Otherwise, IB will provide the free 15-minute delayed data for these values. </p>
<div class='section-title'></div>
<p>In a buy order, if the National Best Bid (NBB) increases before your order executes, your order automatically adjusts upwards to maintain its fixed offset from the NBB. If the NBB moves down, there will be no adjustment because your bid will become even more aggressive and execute.</p>
<div class='section-title'></div>
<p>For sell orders, your offer is pegged to the National Best Offer (NBO) by a more aggressive offset, and if the NBO moves down, your offer will also adjust downward. If the NBO moves up, there will be no change because your offer will become more aggressive and execute.</p>
<div class='section-title'></div>
<p>If you specify both a fixed off-set amount and percent offset, IB will use the more aggressive of the two possible prices (i.e. higher on a buy, lower on a sell). In this order type, you can also specify a limit price that guarantees your order will never adjust to a value greater than the specified price on a buy and will never adjust lower than the specified price on a sell.</p>
<div class='section-title'></div>
<p>When backtesting this order type, or forward-testing a Quantopian-backed paper trading algorithm, the order is modeled as a simple market order. It is only executed as a true <code>RelativeOrder</code> when run with an IB-backed paper or real-money algorithm.  In the future, the backtester will be updated to include this order type.  Also, you may choose to build a custom slippage model that models this type of order in backtesting.</p>
<div class='section-title'></div>
<p>Technical Details:</p>
<ul>
<li>Only IB real money accounts can execute algorithms with <code>RelativeOrder</code>.</li>
<li>IB doesn't support RelativeOrder for paper accounts. The order will appear as 'Cancelled' in the live algorithm dashboard.</li>
<li>In backtesting and Quantopian paper trading, the order is modeled as a simple market order.</li>
<li class='bold'>You need a subscription to IB's market data for Relative Orders, otherwise IB provides 15 minute delayed prices.</li>
</ul>
<div class='section-title'></div>
<p>To use this order style, you will need to import <code>RelativeOrder</code> from the library <code>brokers.ib</code>.</p>
<br>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares. Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>offset</span>:
<span>Floating point value measured in dollars. Specifies a fixed offset from the current NBB or NBO.</span>
</p>
<p>
<span class='parameter'>pct_offset</span>:
<span>Floating point value between 0.0 and 100.0 inclusive.  Specifies a fixed % offset from the NBB or NBO.</span>
</p>
<p>
<span class='parameter'>limit_price</span>:
<span>Price specifying the maximum (on a buy) or minimum (on a sell) price at which order executes.</span>
</p>
<p>
<span class='parameter'>exchange</span>:
<span>Not used. This order routes to SMART in IB Live Trading and is ignored in non-live trading.  Routing to IEX is not allowed for this order type.</span>
</p>
<div class='section-title'>Example</div>
<pre class='prettyprint margin_50l'>from brokers.ib import RelativeOrder&#x000A;&#x000A;def initialize(context):&#x000A;  pass&#x000A;&#x000A;def handle_data(context, data):&#x000A;  # Order to buy at a price two cents higher than the National Best Bid.&#x000A;  order(symbol('AAPL'), 100, style=RelativeOrder(offset=.02))&#x000A;  &#x000A;  # Order to sell at a price 0.5% lower than the National Best Bid&#x000A;  order(symbol('BAC'), -100, style=RelativeOrder(pct_offset=0.5))&#x000A;  # Order to buy at a price two cents higher than 0.5% higher than&#x000A;  # the current National Best Bid.&#x000A;  # But at a price no greater than $15.00 per share.&#x000A;  order(symbol('JPM'), 100, style=RelativeOrder(limit_price=15, offset=0.02, pct_offset=0.5))</pre>
</div>
<div class='api-method'>
<h4 class='padding_10b'>VWAPBestEffort</h4>
<p class='api-code' id='api-VWAPBestEffort'><code>order(security, amount, style=VWAPBestEffort(limit_price=price1, start_date=date1, </code></p>
<p class='api-code padding_400l'><code>end_date=date2, max_pct_vol=percent, </code></p>
<p class='api-code padding_400l'><code>avoid_liquidity=False, exchange=Exchange))</code></p>
<p>
<a href='https://www.interactivebrokers.com/en/?f=%2Fen%2Ftrading%2Forders%2FvwapAlgo.php' target='_blank'>VWAPBestEffort</a>
is an Interactive Brokers (IB) execution algorithm that breaks up your order into small portions and distributes them over a specified period in attempt to get you the Volume Weighted Average Price (VWAP). It seeks to achieve the VWAP calculated from the time you submit the order to the market close. This order type is exclusive to IB and only available for live trading. IB supports BestEfforts VWAP for market orders and limit orders. It cannot be applied to stop orders or stop-limit orders.  This is compatible with any ordering function including <code>order</code>, <code>order_target</code>, <code>order_value</code>, and <code>order_target_percent</code>. Once your market or limit order is submitted to IB, the broker will attempt to fill it according to their BestEfforts algorithm.
</p>
<div class='section-title'></div>
<p>Using this method, your order is partially filled throughout the timperiod and is completely filled by the end date. We strongly encourage you to check for open orders in your algorithm to drive your ordering logic.</p>
<div class='section-title'></div>
<p>You can specify a fixed window for your VWAP calculation or you can maintain a moving window throughout the day, as specified by the <code>start_date</code> and <code>end_date</code> parameters. To place a VWAP order you will need to import the <code>VWAPBestEffort</code> class from the <code>brokers.ib</code> module.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>security</span>:
<span>A security object.</span>
</p>
<p>
<span class='parameter'>amount</span>:
<span>The integer amount of shares. Positive means buy, negative means sell.</span>
</p>
<p>
<span class='parameter'>limit_price</span>:
<span>(optional) Floating point value specifying the limit price for orders. If left None, orders are placed as market orders.</span>
</p>
<p>
<span class='parameter'>start_date</span>:
<span>(optional) Start of period to obtain VWAP. The default is the current algorithm time + 1 minute. The BestEffort order will be submitted to IB in the next minute bar.</span>
</p>
<p>
<span class='parameter'>end_date</span>:
<span>(optional) End of period to obtain VWAP. The default is at market close.</span>
</p>
<p>
<span class='parameter'>max_pct_volume</span>:
<span>(optional) The maximum percentage allowed to trade of the daily volume. The available range is 0.01 – 0.5, and if left unspecified will default to 0.025.</span>
</p>
<p>
<span class='parameter'>avoid_liquidity</span>:
<span>(optional) Check to ensure the order will not hit the bid or lift the offer if possible. This may help to avoid liquidity-taker fees, and could result in liquidity-adding rebates. However, it may also result in greater deviations from the benchmark. It is a boolean variable that defaults to False.</span>
</p>
<p>
<span class='parameter'>exchange</span>:
<span>(optional) Exchange where to route orders. Defaults to SMART in IB Live Trading, and is ignored in non-live trading. Routing to IEX is not allowed for this order type.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>An order id.</span>
</p>
<div class='section-title'>Example</div>
<div class='markdown-generated'>
<pre><code>from brokers.ib import VWAPBestEffort, IBExchange&#x000A;from datetime import timedelta&#x000A;import pandas as pd&#x000A;&#x000A;def initialize(context):&#x000A;    schedule_function(func=buy, date_rule=date_rules.every_day(), time_rule=time_rules.market_open())&#x000A;&#x000A;def handle_data(context, data):&#x000A;    pass&#x000A;&#x000A;def buy(context, data):    &#x000A;    now = get_datetime(&#39;US/Eastern&#39;)&#x000A;&#x000A;    # Do nothing if there are open orders:&#x000A;    if has_orders(context):&#x000A;        print(&#39;has open orders - doing nothing!&#39;)&#x000A;        return&#x000A;&#x000A;    # For IB Paper and Live Trading, executes a VWAP Best Effort order during the entire day&#x000A;    # using the specified parameters, with LMT as the underlying order type. &#x000A;    # Equivalent to order_target(symbol(&#39;MSFT&#39;), 100, style=LimitOrder(45)) during zipline backtesting.&#x000A;    order_target(symbol(&#39;MSFT&#39;), 100, style=VWAPBestEffort(limit_price=45, start_date=now + timedelta(minutes=1), &#x000A;        max_pct_vol=.05, avoid_liquidity=False, exchange=IBExchange.SMART))  &#x000A;&#x000A;    # For IB Paper and Live Trading, executes a VWAP Best Effort order in a 30 minute window&#x000A;    # using the specified parameters, with MKT as the underlying order type.&#x000A;    # Equivalent to order_target(symbol(&#39;AAPL&#39;), 100) during zipline backtesting.           &#x000A;    order_target(symbol(&#39;AAPL&#39;), 100, style=VWAPBestEffort(start_date=now + timedelta(minutes=1), &#x000A;        end_date=now + timedelta(minutes=30), max_pct_vol=.05, avoid_liquidity=False,exchange=IBExchange.SMART))&#x000A;&#x000A;def has_orders(context):&#x000A;    # Return true if there are pending orders.&#x000A;    has_orders = False&#x000A;    open_orders = get_open_orders()&#x000A;    for stock in open_orders:&#x000A;        orders = open_orders[stock]&#x000A;        if orders:&#x000A;            for oo in orders:&#x000A;                message = &#39;Open order for {amount} shares in {stock}&#39;  &#x000A;                message = message.format(amount=oo.amount, stock=stock)&#x000A;                log.info(message)&#x000A;                has_orders = True&#x000A;            return has_orders&#x000A;</code></pre>

</div>
</div>
<h3 class='margin_30t' id='pipeline-api'>Pipeline</h3>
<div id='pipeline-api-docs'>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="core-api">
<h1>Core API</h1>
<dl class="class">
<dt id="quantopian.pipeline.Pipeline">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.</code><code class="descname">Pipeline</code><span class="sig-paren">(</span><em>columns=None</em>, <em>screen=None</em><span class="sig-paren">)</span></dt>
<dd><p>A Pipeline object represents a collection of named expressions to be
compiled and executed by a PipelineEngine.</p>
<p>A Pipeline has two important attributes: &#8216;columns&#8217;, a dictionary of named
<cite>Term</cite> instances, and &#8216;screen&#8217;, a Filter representing criteria for
including an asset in the results of a Pipeline.</p>
<p>To compute a pipeline in the context of a TradingAlgorithm, users must call
<code class="docutils literal"><span class="pre">attach_pipeline</span></code> in their <code class="docutils literal"><span class="pre">initialize</span></code> function to register that the
pipeline should be computed each trading day.  The outputs of a pipeline on
a given day can be accessed by calling <code class="docutils literal"><span class="pre">pipeline_output</span></code> in
<code class="docutils literal"><span class="pre">handle_data</span></code> or <code class="docutils literal"><span class="pre">before_trading_start</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>columns</strong> (<em>dict, optional</em>) &#8211; Initial columns.</li>
<li><strong>screen</strong> (<em>zipline.pipeline.term.Filter, optional</em>) &#8211; Initial screen.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quantopian.pipeline.Pipeline.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>term</em>, <em>name</em>, <em>overwrite=False</em><span class="sig-paren">)</span></dt>
<dd><p>Add a column.</p>
<p>The results of computing <cite>term</cite> will show up as a column in the
DataFrame produced by running this pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>column</strong> (<em>zipline.pipeline.Term</em>) &#8211; A Filter, Factor, or Classifier to add to the pipeline.</li>
<li><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; Name of the column to add.</li>
<li><strong>overwrite</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether to overwrite the existing entry if we already have a column
named <cite>name</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.Pipeline.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Remove a column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; The name of the column to remove.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> &#8211;
If <cite>name</cite> is not in self.columns.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>removed</strong> (<em>zipline.pipeline.term.Term</em>) &#8211;
The removed term.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.Pipeline.set_screen">
<code class="descname">set_screen</code><span class="sig-paren">(</span><em>screen</em>, <em>overwrite=False</em><span class="sig-paren">)</span></dt>
<dd><p>Set a screen on this Pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter</strong> (<em>zipline.pipeline.Filter</em>) &#8211; The filter to apply as a screen.</li>
<li><strong>overwrite</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether to overwrite any existing screen.  If overwrite is False
and self.screen is not None, we raise an error.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.Pipeline.show_graph">
<code class="descname">show_graph</code><span class="sig-paren">(</span><em>format='svg'</em><span class="sig-paren">)</span></dt>
<dd><p>Render this Pipeline as a DAG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>format</strong> (<em>{'svg', 'png', 'jpeg'}</em>) &#8211; Image format to render with.  Default is &#8216;svg&#8217;.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.Pipeline.columns">
<code class="descname">columns</code></dt>
<dd><p>The columns registered with this pipeline.</p>
</dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.Pipeline.screen">
<code class="descname">screen</code></dt>
<dd><p>The screen applied to the rows of this pipeline.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.CustomFactor">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.</code><code class="descname">CustomFactor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Base class for user-defined Factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputs</strong> (<em>iterable, optional</em>) &#8211; An iterable of <cite>BoundColumn</cite> instances (e.g. USEquityPricing.close),
describing the data to load and pass to <cite>self.compute</cite>.  If this
argument is not passed to the CustomFactor constructor, we look for a
class-level attribute named <cite>inputs</cite>.</li>
<li><strong>outputs</strong> (<em>iterable[str], optional</em>) &#8211; An iterable of strings which represent the names of each output this
factor should compute and return. If this argument is not passed to the
CustomFactor constructor, we look for a class-level attribute named
<cite>outputs</cite>.</li>
<li><strong>window_length</strong> (<em>int, optional</em>) &#8211; Number of rows to pass for each input.  If this argument is not passed
to the CustomFactor constructor, we look for a class-level attribute
named <cite>window_length</cite>.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter describing the assets on which we should compute each day.
Each call to <code class="docutils literal"><span class="pre">CustomFactor.compute</span></code> will only receive assets for
which <code class="docutils literal"><span class="pre">mask</span></code> produced True on the day for which compute is being
called.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Users implementing their own Factors should subclass CustomFactor and
implement a method named <cite>compute</cite> with the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">):</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>On each simulation date, <code class="docutils literal"><span class="pre">compute</span></code> will be called with the current date,
an array of sids, an output array, and an input array for each expression
passed as inputs to the CustomFactor constructor.</p>
<p>The specific types of the values passed to <cite>compute</cite> are as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>today : np.datetime64[ns]
    Row label for the last row of all arrays passed as `inputs`.
assets : np.array[int64, ndim=1]
    Column labels for `out` and`inputs`.
out : np.array[self.dtype, ndim=1]
    Output array of the same shape as `assets`.  `compute` should write
    its desired return values into `out`. If multiple outputs are
    specified, `compute` should write its desired return values into
    `out.&lt;output_name&gt;` for each output name in `self.outputs`.
*inputs : tuple of np.array
    Raw data arrays corresponding to the values of `self.inputs`.
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">compute</span></code> functions should expect to be passed NaN values for dates on
which no data was available for an asset.  This may include dates on which
an asset did not yet exist.</p>
<p>For example, if a CustomFactor requires 10 rows of close price data, and
asset A started trading on Monday June 2nd, 2014, then on Tuesday, June
3rd, 2014, the column of input data for asset A will have 9 leading NaNs
for the preceding days on which data was not yet available.</p>
<p class="rubric">Examples</p>
<p>A CustomFactor with pre-declared defaults:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TenDayRange</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the difference between the highest high in the last 10</span>
<span class="sd">    days and the lowest low.</span>

<span class="sd">    Pre-declares high and low as default inputs and `window_length` as</span>
<span class="sd">    10.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">high</span><span class="p">,</span> <span class="n">USEquityPricing</span><span class="o">.</span><span class="n">low</span><span class="p">]</span>
    <span class="n">window_length</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">highs</span><span class="p">,</span> <span class="n">lows</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">nanmin</span><span class="p">,</span> <span class="n">nanmax</span>

        <span class="n">highest_highs</span> <span class="o">=</span> <span class="n">nanmax</span><span class="p">(</span><span class="n">highs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">lowest_lows</span> <span class="o">=</span> <span class="n">nanmin</span><span class="p">(</span><span class="n">lows</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">highest_highs</span> <span class="o">-</span> <span class="n">lowest_lows</span>

<span class="c"># Doesn&#39;t require passing inputs or window_length because they&#39;re</span>
<span class="c"># pre-declared as defaults for the TenDayRange class.</span>
<span class="n">ten_day_range</span> <span class="o">=</span> <span class="n">TenDayRange</span><span class="p">()</span>
</pre></div>
</div>
<p>A CustomFactor without defaults:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MedianValue</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the median value of an arbitrary single input over an</span>
<span class="sd">    arbitrary window..</span>

<span class="sd">    Does not declare any defaults, so values for `window_length` and</span>
<span class="sd">    `inputs` must be passed explicitly on every construction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">nanmedian</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Values for `inputs` and `window_length` must be passed explicitly to</span>
<span class="c"># MedianValue.</span>
<span class="n">median_close10</span> <span class="o">=</span> <span class="n">MedianValue</span><span class="p">([</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">median_low15</span> <span class="o">=</span> <span class="n">MedianValue</span><span class="p">([</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">low</span><span class="p">],</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>A CustomFactor with multiple outputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MultipleOutputs</span><span class="p">(</span><span class="n">CustomFactor</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">]</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;alpha&#39;</span><span class="p">,</span> <span class="s">&#39;beta&#39;</span><span class="p">]</span>
    <span class="n">window_length</span> <span class="o">=</span> <span class="n">N</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">today</span><span class="p">,</span> <span class="n">assets</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">close</span><span class="p">):</span>
        <span class="n">computed_alpha</span><span class="p">,</span> <span class="n">computed_beta</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">(</span><span class="n">close</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">alpha</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">computed_alpha</span>
        <span class="n">out</span><span class="o">.</span><span class="n">beta</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">computed_beta</span>

<span class="c"># Each output is returned as its own Factor upon instantiation.</span>
<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">MultipleOutputs</span><span class="p">()</span>

<span class="c"># Equivalently, we can create a single factor instance and access each</span>
<span class="c"># output as an attribute of that instance.</span>
<span class="n">multiple_outputs</span> <span class="o">=</span> <span class="n">MultipleOutputs</span><span class="p">()</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">multiple_outputs</span><span class="o">.</span><span class="n">alpha</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">multiple_outputs</span><span class="o">.</span><span class="n">beta</span>
</pre></div>
</div>
<p>Note: If a CustomFactor has multiple outputs, all outputs must have the
same dtype. For instance, in the example above, if alpha is a float then
beta must also be a float.</p>
</dd></dl>

</div>
<div class="section" id="base-classes">
<h1>Base Classes</h1>
<p>Base classes defined in <code class="xref py py-mod docutils literal"><span class="pre">zipline</span></code> that provide pipeline functionality.</p>
<dl class="class">
<dt id="zipline.pipeline.data.dataset.BoundColumn">
<em class="property">class </em><code class="descclassname">zipline.pipeline.data.dataset.</code><code class="descname">BoundColumn</code></dt>
<dd><p>A column of data that&#8217;s been concretely bound to a particular dataset.</p>
<p>Instances of this class are dynamically created upon access to attributes
of DataSets (for example, USEquityPricing.close is an instance of this
class).</p>
<dl class="attribute">
<dt id="BoundColumn.dtype">
<code class="descname">dtype</code></dt>
<dd><p><em>numpy.dtype</em></p>
<p>The dtype of data produced when this column is loaded.</p>
</dd></dl>

<dl class="attribute">
<dt id="BoundColumn.latest">
<code class="descname">latest</code></dt>
<dd><p><em>zipline.pipeline.data.Factor or zipline.pipeline.data.Filter</em></p>
<p>A Filter, Factor, or Classifier computing the most recently known value
of this column on each date.</p>
<p>Produces a Filter if self.dtype == <code class="docutils literal"><span class="pre">np.bool_</span></code>.
Produces a Classifier if self.dtype == <code class="docutils literal"><span class="pre">np.int64</span></code>
Otherwise produces a Factor.</p>
</dd></dl>

<dl class="attribute">
<dt id="BoundColumn.dataset">
<code class="descname">dataset</code></dt>
<dd><p><em>zipline.pipeline.data.DataSet</em></p>
<p>The dataset to which this column is bound.</p>
</dd></dl>

<dl class="attribute">
<dt id="BoundColumn.name">
<code class="descname">name</code></dt>
<dd><p><em>str</em></p>
<p>The name of this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipline.pipeline.data.dataset.BoundColumn.dataset">
<code class="descname">dataset</code></dt>
<dd><p>The dataset to which this column is bound.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipline.pipeline.data.dataset.BoundColumn.name">
<code class="descname">name</code></dt>
<dd><p>The name of this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipline.pipeline.data.dataset.BoundColumn.qualname">
<code class="descname">qualname</code></dt>
<dd><p>The fully-qualified name of this column.</p>
<p>Generated by doing &#8216;.&#8217;.join([self.dataset.__name__, self.name]).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.Factor">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">Factor</code></dt>
<dd><p>Pipeline API expression producing a numerical or date-valued output.</p>
<p>Factors are the most commonly-used Pipeline term, representing the result
of any computation producing a numerical result.</p>
<p>Factors can be combined, both with other Factors and with scalar values,
via any of the builtin mathematical operators (<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, etc).
This makes it easy to write complex expressions that combine multiple
Factors.  For example, constructing a Factor that computes the average of
two other Factors is simply:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">SomeFactor</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">SomeOtherFactor</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">average</span> <span class="o">=</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>Factors can also be converted into <code class="xref py py-class docutils literal"><span class="pre">zipline.pipeline.Filter</span></code> objects
via comparison operators: (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">eq</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>).</p>
<p>There are many natural operators defined on Factors besides the basic
numerical operators. These include methods identifying missing or
extreme-valued outputs (isnull, notnull, isnan, notnan), methods for
normalizing outputs (rank, demean, zscore), and methods for constructing
Filters based on rank-order properties of results (top, bottom,
percentile_between).</p>
<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.eq">
<code class="descname">eq</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd><p>Binary Operator: &#8216;==&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.demean">
<code class="descname">demean</code><span class="sig-paren">(</span><em>mask=sentinel('NotSpecified')</em>, <em>groupby=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Factor that computes <code class="docutils literal"><span class="pre">self</span></code> and subtracts the mean from
row of the result.</p>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore values where <code class="docutils literal"><span class="pre">mask</span></code> returns False
when computing row means, and output NaN anywhere the mask is False.</p>
<p>If <code class="docutils literal"><span class="pre">groupby</span></code> is supplied, compute by partitioning each row based on
the values produced by <code class="docutils literal"><span class="pre">groupby</span></code>, de-meaning the partitioned arrays,
and stitching the sub-results back together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter defining values to ignore when computing means.</li>
<li><strong>groupby</strong> (<em>zipline.pipeline.Classifier, optional</em>) &#8211; A classifier defining partitions over which to compute means.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>Let <code class="docutils literal"><span class="pre">f</span></code> be a Factor which would produce the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    1.0    2.0    3.0    4.0
2017-03-14    1.5    2.5    3.5    1.0
2017-03-15    2.0    3.0    4.0    1.5
2017-03-16    2.5    3.5    1.0    2.0
</pre></div>
</div>
<p>Let <code class="docutils literal"><span class="pre">c</span></code> be a Classifier producing the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13      1      1      2      2
2017-03-14      1      1      2      2
2017-03-15      1      1      2      2
2017-03-16      1      1      2      2
</pre></div>
</div>
<p>Let <code class="docutils literal"><span class="pre">m</span></code> be a Filter producing the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13  False   True   True   True
2017-03-14   True  False   True   True
2017-03-15   True   True  False   True
2017-03-16   True   True   True  False
</pre></div>
</div>
<p>Then <code class="docutils literal"><span class="pre">f.demean()</span></code> will subtract the mean from each row produced by
<code class="docutils literal"><span class="pre">f</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13 -1.500 -0.500  0.500  1.500
2017-03-14 -0.625  0.375  1.375 -1.125
2017-03-15 -0.625  0.375  1.375 -1.125
2017-03-16  0.250  1.250 -1.250 -0.250
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">f.demean(mask=m)</span></code> will subtract the mean from each row, but means
will be calculated ignoring values on the diagonal, and NaNs will
written to the diagonal in the output. Diagonal values are ignored
because they are the locations where the mask <code class="docutils literal"><span class="pre">m</span></code> produced False.</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    NaN -1.000  0.000  1.000
2017-03-14 -0.500    NaN  1.500 -1.000
2017-03-15 -0.166  0.833    NaN -0.666
2017-03-16  0.166  1.166 -1.333    NaN
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">f.demean(groupby=c)</span></code> will subtract the group-mean of AAPL/MSFT and
MCD/BK from their respective entries.  The AAPL/MSFT are grouped
together because both assets always produce 1 in the output of the
classifier <code class="docutils literal"><span class="pre">c</span></code>.  Similarly, MCD/BK are grouped together because they
always produce 2.</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13 -0.500  0.500 -0.500  0.500
2017-03-14 -0.500  0.500  1.250 -1.250
2017-03-15 -0.500  0.500  1.250 -1.250
2017-03-16 -0.500  0.500 -0.500  0.500
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">f.demean(mask=m,</span> <span class="pre">groupby=c)</span></code> will also subtract the group-mean of
AAPL/MSFT and MCD/BK, but means will be calculated ignoring values on
the diagonal , and NaNs will be written to the diagonal in the output.</p>
<div class="highlight-python"><div class="highlight"><pre>             AAPL   MSFT    MCD     BK
2017-03-13    NaN  0.000 -0.500  0.500
2017-03-14  0.000    NaN  1.250 -1.250
2017-03-15 -0.500  0.500    NaN  0.000
2017-03-16 -0.500  0.500  0.000    NaN
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Mean is sensitive to the magnitudes of outliers. When working with
factor that can potentially produce large outliers, it is often useful
to use the <code class="docutils literal"><span class="pre">mask</span></code> parameter to discard values at the extremes of the
distribution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">MyFactor</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalized</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">demean</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">percentile_between</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">demean()</span></code> is only supported on Factors of dtype float64.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby" title="(in pandas v0.18.1)"><code class="xref py py-meth docutils literal"><span class="pre">pandas.DataFrame.groupby()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.zscore">
<code class="descname">zscore</code><span class="sig-paren">(</span><em>mask=sentinel('NotSpecified')</em>, <em>groupby=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Factor that Z-Scores each day&#8217;s results.</p>
<p>The Z-Score of a row is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">row</span><span class="o">.</span><span class="n">stddev</span><span class="p">()</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore values where <code class="docutils literal"><span class="pre">mask</span></code> returns False
when computing row means and standard deviations, and output NaN
anywhere the mask is False.</p>
<p>If <code class="docutils literal"><span class="pre">groupby</span></code> is supplied, compute by partitioning each row based on
the values produced by <code class="docutils literal"><span class="pre">groupby</span></code>, z-scoring the partitioned arrays,
and stitching the sub-results back together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter defining values to ignore when Z-Scoring.</li>
<li><strong>groupby</strong> (<em>zipline.pipeline.Classifier, optional</em>) &#8211; A classifier defining partitions over which to compute Z-Scores.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>zscored</strong> (<em>zipline.pipeline.Factor</em>) &#8211;
A Factor producing that z-scores the output of self.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Mean and standard deviation are sensitive to the magnitudes of
outliers. When working with factor that can potentially produce large
outliers, it is often useful to use the <code class="docutils literal"><span class="pre">mask</span></code> parameter to discard
values at the extremes of the distribution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">MyFactor</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalized</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">percentile_between</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">zscore()</span></code> is only supported on Factors of dtype float64.</p>
<p class="rubric">Example</p>
<p>See <code class="xref py py-meth docutils literal"><span class="pre">demean()</span></code> for an in-depth
example of the semantics for <code class="docutils literal"><span class="pre">mask</span></code> and <code class="docutils literal"><span class="pre">groupby</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby" title="(in pandas v0.18.1)"><code class="xref py py-meth docutils literal"><span class="pre">pandas.DataFrame.groupby()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>method='ordinal'</em>, <em>ascending=True</em>, <em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a new Factor representing the sorted rank of each column
within each row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>method</strong> (<em>str, {'ordinal', 'min', 'max', 'dense', 'average'}</em>) &#8211; The method used to assign ranks to tied elements. See
<cite>scipy.stats.rankdata</cite> for a full description of the semantics for
each ranking method. Default is &#8216;ordinal&#8217;.</li>
<li><strong>ascending</strong> (<em>bool, optional</em>) &#8211; Whether to return sorted rank in ascending or descending order.
Default is True.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter representing assets to consider when computing ranks.
If mask is supplied, ranks are computed ignoring any asset/date
pairs for which <cite>mask</cite> produces a value of False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ranks</strong> (<em>zipline.pipeline.factors.Rank</em>) &#8211;
A new factor that will compute the ranking of the data produced by
<cite>self</cite>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The default value for <cite>method</cite> is different from the default for
<cite>scipy.stats.rankdata</cite>.  See that function&#8217;s documentation for a full
description of the valid inputs to <cite>method</cite>.</p>
<p>Missing or non-existent data on a given day will cause an asset to be
given a rank of NaN for that day.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rankdata.html#scipy.stats.rankdata" title="(in SciPy v0.17.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.rankdata()</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">zipline.pipeline.factors.factor.Rank</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.quantiles">
<code class="descname">quantiles</code><span class="sig-paren">(</span><em>bins</em>, <em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Classifier computing quantiles of the output of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Every non-NaN data point the output is labelled with an integer value
from 0 to (bins - 1).  NaNs are labelled with -1.</p>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore data points in locations for which
<code class="docutils literal"><span class="pre">mask</span></code> produces False, and emit a label of -1 at those locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bins</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of bins labels to compute.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; Mask of values to ignore when computing quantiles.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>quantiles</strong> (<em>zipline.pipeline.classifiers.Quantiles</em>) &#8211;
A Classifier producing integer labels ranging from 0 to (bins - 1).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.quartiles">
<code class="descname">quartiles</code><span class="sig-paren">(</span><em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Classifier computing quartiles over the output of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Every non-NaN data point the output is labelled with a value of either
0, 1, 2, or 3, corresponding to the first, second, third, or fourth
quartile over each row.  NaN data points are labelled with -1.</p>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore data points in locations for which
<code class="docutils literal"><span class="pre">mask</span></code> produces False, and emit a label of -1 at those locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; Mask of values to ignore when computing quartiles.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>quartiles</strong> (<em>zipline.pipeline.classifiers.Quantiles</em>) &#8211;
A Classifier producing integer labels ranging from 0 to 3.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.quintiles">
<code class="descname">quintiles</code><span class="sig-paren">(</span><em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Classifier computing quintile labels on <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Every non-NaN data point the output is labelled with a value of either
0, 1, 2, or 3, 4, corresonding to quintiles over each row.  NaN data
points are labelled with -1.</p>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore data points in locations for which
<code class="docutils literal"><span class="pre">mask</span></code> produces False, and emit a label of -1 at those locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; Mask of values to ignore when computing quintiles.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>quintiles</strong> (<em>zipline.pipeline.classifiers.Quantiles</em>) &#8211;
A Classifier producing integer labels ranging from 0 to 4.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.deciles">
<code class="descname">deciles</code><span class="sig-paren">(</span><em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Classifier computing decile labels on <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Every non-NaN data point the output is labelled with a value from 0 to
9 corresonding to deciles over each row.  NaN data points are labelled
with -1.</p>
<p>If <code class="docutils literal"><span class="pre">mask</span></code> is supplied, ignore data points in locations for which
<code class="docutils literal"><span class="pre">mask</span></code> produces False, and emit a label of -1 at those locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; Mask of values to ignore when computing deciles.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>deciles</strong> (<em>zipline.pipeline.classifiers.Quantiles</em>) &#8211;
A Classifier producing integer labels ranging from 0 to 9.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.top">
<code class="descname">top</code><span class="sig-paren">(</span><em>N</em>, <em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Filter matching the top N asset values of self each day.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of assets passing the returned filter each day.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter representing assets to consider when computing ranks.
If mask is supplied, top values are computed ignoring any
asset/date pairs for which <cite>mask</cite> produces a value of False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>filter</strong> (<em>zipline.pipeline.filters.Filter</em>)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><em>N</em>, <em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Filter matching the bottom N asset values of self each day.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>N</strong> (<a class="reference external" href="https://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of assets passing the returned filter each day.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter representing assets to consider when computing ranks.
If mask is supplied, bottom values are computed ignoring any
asset/date pairs for which <cite>mask</cite> produces a value of False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>filter</strong> (<em>zipline.pipeline.Filter</em>)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.percentile_between">
<code class="descname">percentile_between</code><span class="sig-paren">(</span><em>min_percentile</em>, <em>max_percentile</em>, <em>mask=sentinel('NotSpecified')</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a new Filter representing entries from the output of this
Factor that fall within the percentile range defined by min_percentile
and max_percentile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>min_percentile</strong> (<em>float [0.0, 100.0]</em>) &#8211; Return True for assets falling above this percentile in the data.</li>
<li><strong>max_percentile</strong> (<em>float [0.0, 100.0]</em>) &#8211; Return True for assets falling below this percentile in the data.</li>
<li><strong>mask</strong> (<em>zipline.pipeline.Filter, optional</em>) &#8211; A Filter representing assets to consider when percentile
calculating thresholds.  If mask is supplied, percentile cutoffs
are computed each day using only assets for which <code class="docutils literal"><span class="pre">mask</span></code> returns
True.  Assets for which <code class="docutils literal"><span class="pre">mask</span></code> produces False will produce False
in the output of this Factor as well.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>out</strong> (<em>zipline.pipeline.filters.PercentileFilter</em>) &#8211;
A new filter that will compute the specified percentile-range mask.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">zipline.pipeline.filters.filter.PercentileFilter()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.isnan">
<code class="descname">isnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A Filter producing True for all values where this Factor is NaN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>nanfilter</strong> (<em>zipline.pipeline.filters.Filter</em>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.notnan">
<code class="descname">notnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A Filter producing True for values where this Factor is not NaN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>nanfilter</strong> (<em>zipline.pipeline.filters.Filter</em>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.Factor.isfinite">
<code class="descname">isfinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A Filter producing True for values where this Factor is anything but
NaN, inf, or -inf.</p>
</dd></dl>

</dd></dl>

<p><strong>Notes:</strong></p>
<ul class="simple">
<li>In addition to its named methods,
<a class="reference internal" href="help.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> implements the following binary
operators producing new factors: <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">**</span></code>, <code class="docutils literal"><span class="pre">%</span></code>.</li>
<li><a class="reference internal" href="help.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a> also implements the following
comparison operators producing filters: <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>.
For internal technical reasons, <a class="reference internal" href="help.html#quantopian.pipeline.factors.Factor" title="quantopian.pipeline.factors.Factor"><code class="xref py py-class docutils literal"><span class="pre">Factor</span></code></a>
does <strong>not</strong> override <code class="docutils literal"><span class="pre">==</span></code>. The <code class="docutils literal"><span class="pre">eq</span></code> method can be used to produce a
<a class="reference internal" href="help.html#quantopian.pipeline.filters.Filter" title="quantopian.pipeline.filters.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> that performs a direct equality
comparison against the output of a factor.</li>
</ul>
<dl class="class">
<dt id="quantopian.pipeline.filters.Filter">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.filters.</code><code class="descname">Filter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Pipeline expression computing a boolean output.</p>
<p>Filters are most commonly useful for describing sets of assets to include
or exclude for some particular purpose. Many Pipeline API functions accept
a <code class="docutils literal"><span class="pre">mask</span></code> argument, which can be supplied a Filter indicating that only
values passing the Filter should be considered when performing the
requested computation. For example, <code class="xref py py-meth docutils literal"><span class="pre">zipline.pipeline.Factor.top()</span></code>
accepts a mask indicating that ranks should be computed only on assets that
passed the specified Filter.</p>
<p>The most common way to construct a Filter is via one of the comparison
operators (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">eq</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>) of
<code class="xref py py-class docutils literal"><span class="pre">Factor</span></code>. For example, a natural way to construct
a Filter for stocks with a 10-day VWAP less than $20.0 is to first
construct a Factor computing 10-day VWAP and compare it to the scalar value
20.0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">zipline.pipeline.factors</span> <span class="kn">import</span> <span class="n">VWAP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vwap_10</span> <span class="o">=</span> <span class="n">VWAP</span><span class="p">(</span><span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vwaps_under_20</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwap_10</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Filters can also be constructed via comparisons between two Factors.  For
example, to construct a Filter producing True for asset/date pairs where
the asset&#8217;s 10-day VWAP was greater than it&#8217;s 30-day VWAP:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">short_vwap</span> <span class="o">=</span> <span class="n">VWAP</span><span class="p">(</span><span class="n">window_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">long_vwap</span> <span class="o">=</span> <span class="n">VWAP</span><span class="p">(</span><span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">higher_short_vwap</span> <span class="o">=</span> <span class="p">(</span><span class="n">short_vwap</span> <span class="o">&gt;</span> <span class="n">long_vwap</span><span class="p">)</span>
</pre></div>
</div>
<p>Filters can be combined via the <code class="docutils literal"><span class="pre">&amp;</span></code> (and) and <code class="docutils literal"><span class="pre">|</span></code> (or) operators.</p>
<p><code class="docutils literal"><span class="pre">&amp;</span></code>-ing together two filters produces a new Filter that produces True if
<strong>both</strong> of the inputs produced True.</p>
<p><code class="docutils literal"><span class="pre">|</span></code>-ing together two filters produces a new Filter that produces True if
<strong>either</strong> of its inputs produced True.</p>
<p>The <code class="docutils literal"><span class="pre">~</span></code> operator can be used to invert a Filter, swapping all True values
with Falses and vice-versa.</p>
<p>Filters may be set as the <code class="docutils literal"><span class="pre">screen</span></code> attribute of a Pipeline, indicating
asset/date pairs for which the filter produces False should be excluded
from the Pipeline&#8217;s output.  This is useful both for reducing noise in the
output of a Pipeline and for reducing memory consumption of Pipeline
results.</p>
<dl class="method">
<dt id="quantopian.pipeline.filters.Filter.__and__">
<code class="descname">__and__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd><p>Binary Operator: &#8216;&amp;&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.filters.Filter.__or__">
<code class="descname">__or__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd><p>Binary Operator: &#8216;|&#8217;</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.classifiers.Classifier">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.classifiers.</code><code class="descname">Classifier</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>A Pipeline expression computing a categorical output.</p>
<p>Classifiers are most commonly useful for describing grouping keys for
complex transformations on Factor outputs. For example, Factor.demean() and
Factor.zscore() can be passed a Classifier in their <code class="docutils literal"><span class="pre">groupby</span></code> argument,
indicating that means/standard deviations should be computed on assets for
which the classifier produced the same label.</p>
<dl class="method">
<dt id="quantopian.pipeline.classifiers.Classifier.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Filter returning True for asset/date pairs where the output
of <code class="docutils literal"><span class="pre">self</span></code> matches <a href="help.html#id1"><span class="problematic" id="id2">``</span></a>other.</p>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.classifiers.Classifier.eq">
<code class="descname">eq</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd><p>Construct a Filter returning True for asset/date pairs where the output
of <code class="docutils literal"><span class="pre">self</span></code> matches <a href="help.html#id3"><span class="problematic" id="id4">``</span></a>other.</p>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.classifiers.Classifier.isnull">
<code class="descname">isnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A Filter producing True for values where this term has missing data.</p>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.classifiers.Classifier.notnull">
<code class="descname">notnull</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>A Filter producing True for values where this term has complete data.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-quantopian.pipeline.factors">
<span id="built-in-factors"></span><h1>Built-in Factors</h1>
<p>All classes listed here are importable from <a class="reference internal" href="help.html#module-quantopian.pipeline.factors" title="quantopian.pipeline.factors"><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.factors</span></code></a>.</p>
<dl class="class">
<dt id="quantopian.pipeline.factors.Latest">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">Latest</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Factor producing the most recently-known value of <cite>inputs[0]</cite> on each day.</p>
<p>The <cite>.latest</cite> attribute of DataSet columns returns an instance of this
Factor.</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.MaxDrawdown">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">MaxDrawdown</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Max Drawdown</p>
<p><strong>Default Inputs:</strong> None</p>
<p><strong>Default Window Length:</strong> None</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.RSI">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">RSI</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Relative Strength Index</p>
<p><strong>Default Inputs</strong>: [USEquityPricing.close]</p>
<p><strong>Default Window Length</strong>: 15</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.SimpleMovingAverage">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">SimpleMovingAverage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Average Value of an arbitrary column</p>
<p><strong>Default Inputs</strong>: None</p>
<p><strong>Default Window Length</strong>: None</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.VWAP">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">VWAP</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Volume Weighted Average Price</p>
<p><strong>Default Inputs:</strong> [USEquityPricing.close, USEquityPricing.volume]</p>
<p><strong>Default Window Length:</strong> None</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.WeightedAverageValue">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">WeightedAverageValue</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Helper for VWAP-like computations.</p>
<p><strong>Default Inputs:</strong> None</p>
<p><strong>Default Window Length:</strong> None</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.Returns">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">Returns</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Calculates the percent change in close price over the given window_length.</p>
<p><strong>Default Inputs</strong>: [USEquityPricing.close]</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.AverageDollarVolume">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">AverageDollarVolume</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Average Daily Dollar Volume</p>
<p><strong>Default Inputs:</strong> [USEquityPricing.close, USEquityPricing.volume]</p>
<p><strong>Default Window Length:</strong> None</p>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingAverage">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">ExponentialWeightedMovingAverage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Exponentially Weighted Moving Average</p>
<p><strong>Default Inputs:</strong> None</p>
<p><strong>Default Window Length:</strong> None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputs</strong> (<em>length-1 list/tuple of BoundColumn</em>) &#8211; The expression over which to compute the average.</li>
<li><strong>window_length</strong> (<em>int &gt; 0</em>) &#8211; Length of the lookback window over which to compute the average.</li>
<li><strong>decay_rate</strong> (<em>float, 0 &lt; decay_rate &lt;= 1</em>) &#8211; <p>Weighting factor by which to discount past observations.</p>
<p>When calculating historical averages, rows are multiplied by the
sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">decay_rate</span><span class="p">,</span> <span class="n">decay_rate</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">decay_rate</span> <span class="o">**</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>This class can also be imported under the name <code class="docutils literal"><span class="pre">EWMA</span></code>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">pandas.ewma()</span></code></p>
</div>
<p><strong>Alternate Constructors:</strong></p>
<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingAverage.from_span">
<code class="descname">from_span</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>span</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <cite>decay_rate</cite> in terms of <cite>span</cite>.</p>
<p>Forwards <cite>decay_rate</cite> as <cite>1 - (2.0 / (1 + span))</cite>.  This provides the
behavior equivalent to passing <cite>span</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=(1 - (2.0 / (1 + 15.0))),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_span</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">span</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingAverage.from_center_of_mass">
<code class="descname">from_center_of_mass</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>center_of_mass</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <cite>decay_rate</cite> in terms of center of
mass.</p>
<p>Forwards <cite>decay_rate</cite> as <cite>1 - (1 / 1 + center_of_mass)</cite>.  This provides
behavior equivalent to passing <cite>center_of_mass</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=(1 - (1 / 15.0)),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_center_of_mass</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">center_of_mass</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingAverage.from_halflife">
<code class="descname">from_halflife</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>halflife</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <code class="docutils literal"><span class="pre">decay_rate</span></code> in terms of half
life.</p>
<p>Forwards <code class="docutils literal"><span class="pre">decay_rate</span></code> as <code class="docutils literal"><span class="pre">exp(log(.5)</span> <span class="pre">/</span> <span class="pre">halflife)</span></code>.  This provides
the behavior equivalent to passing <cite>halflife</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=np.exp(np.log(0.5) / 15),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_halflife</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">halflife</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.</code><code class="descname">ExponentialWeightedMovingStdDev</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Exponentially Weighted Moving Standard Deviation</p>
<p><strong>Default Inputs:</strong> None</p>
<p><strong>Default Window Length:</strong> None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputs</strong> (<em>length-1 list/tuple of BoundColumn</em>) &#8211; The expression over which to compute the average.</li>
<li><strong>window_length</strong> (<em>int &gt; 0</em>) &#8211; Length of the lookback window over which to compute the average.</li>
<li><strong>decay_rate</strong> (<em>float, 0 &lt; decay_rate &lt;= 1</em>) &#8211; <p>Weighting factor by which to discount past observations.</p>
<p>When calculating historical averages, rows are multiplied by the
sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">decay_rate</span><span class="p">,</span> <span class="n">decay_rate</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">decay_rate</span> <span class="o">**</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>This class can also be imported under the name <code class="docutils literal"><span class="pre">EWMSTD</span></code>.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">pandas.ewmstd()</span></code></p>
</div>
<p><strong>Alternate Constructors:</strong></p>
<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev.from_span">
<code class="descname">from_span</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>span</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <cite>decay_rate</cite> in terms of <cite>span</cite>.</p>
<p>Forwards <cite>decay_rate</cite> as <cite>1 - (2.0 / (1 + span))</cite>.  This provides the
behavior equivalent to passing <cite>span</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=(1 - (2.0 / (1 + 15.0))),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_span</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">span</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev.from_center_of_mass">
<code class="descname">from_center_of_mass</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>center_of_mass</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <cite>decay_rate</cite> in terms of center of
mass.</p>
<p>Forwards <cite>decay_rate</cite> as <cite>1 - (1 / 1 + center_of_mass)</cite>.  This provides
behavior equivalent to passing <cite>center_of_mass</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=(1 - (1 / 15.0)),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_center_of_mass</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">center_of_mass</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev.from_halflife">
<code class="descname">from_halflife</code><span class="sig-paren">(</span><em>inputs</em>, <em>window_length</em>, <em>halflife</em><span class="sig-paren">)</span></dt>
<dd><p>Convenience constructor for passing <code class="docutils literal"><span class="pre">decay_rate</span></code> in terms of half
life.</p>
<p>Forwards <code class="docutils literal"><span class="pre">decay_rate</span></code> as <code class="docutils literal"><span class="pre">exp(log(.5)</span> <span class="pre">/</span> <span class="pre">halflife)</span></code>.  This provides
the behavior equivalent to passing <cite>halflife</cite> to pandas.ewma.</p>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Equivalent to:</span>
<span class="c"># my_ewma = EWMA(</span>
<span class="c">#    inputs=[USEquityPricing.close],</span>
<span class="c">#    window_length=30,</span>
<span class="c">#    decay_rate=np.exp(np.log(0.5) / 15),</span>
<span class="c"># )</span>
<span class="n">my_ewma</span> <span class="o">=</span> <span class="n">EWMA</span><span class="o">.</span><span class="n">from_halflife</span><span class="p">(</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">USEquityPricing</span><span class="o">.</span><span class="n">close</span><span class="p">],</span>
    <span class="n">window_length</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">halflife</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This classmethod is provided by both
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingAverage" title="quantopian.pipeline.factors.ExponentialWeightedMovingAverage"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingAverage</span></code></a> and
<a class="reference internal" href="help.html#quantopian.pipeline.factors.ExponentialWeightedMovingStdDev" title="quantopian.pipeline.factors.ExponentialWeightedMovingStdDev"><code class="xref py py-class docutils literal"><span class="pre">ExponentialWeightedMovingStdDev</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-quantopian.pipeline.filters.morningstar">
<span id="built-in-filters"></span><h1>Built-in Filters</h1>
<p>All classes listed here are importable from
<a class="reference internal" href="help.html#module-quantopian.pipeline.filters.morningstar" title="quantopian.pipeline.filters.morningstar"><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.filters.morningstar</span></code></a>.</p>
<dl class="class">
<dt id="quantopian.pipeline.filters.morningstar.IsPrimaryShare">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.filters.morningstar.</code><code class="descname">IsPrimaryShare</code></dt>
<dd><p>A Filter indicating whether a given asset class is a primary share.</p>
<dl class="attribute">
<dt id="quantopian.pipeline.filters.morningstar.IsPrimaryShare.inputs">
<code class="descname">inputs</code><em class="property"> = (share_class_reference.is_primary_share::bool,)</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-quantopian.pipeline.classifiers.morningstar">
<span id="built-in-classifiers"></span><h1>Built-in Classifiers</h1>
<p>All classes listed here are importable from
<a class="reference internal" href="help.html#module-quantopian.pipeline.classifiers.morningstar" title="quantopian.pipeline.classifiers.morningstar"><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.classifiers.morningstar</span></code></a>.</p>
<dl class="class">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.classifiers.morningstar.</code><code class="descname">SuperSector</code></dt>
<dd><p>Classifier that groups assets by Morningstar Super Sector.</p>
<p>There are three possible classifications:</p>
<ul class="simple">
<li>1 - Cyclical</li>
<li>2 - Defensive</li>
<li>3 - Sensitive</li>
</ul>
<p>These values are provided as integer constants on the class.</p>
<p>For more information on morningstar classification codes, see:
<a class="reference external" href="https://www.quantopian.com/help/fundamentals#industry-sector">https://www.quantopian.com/help/fundamentals#industry-sector</a>.</p>
<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.CYCLICAL">
<code class="descname">CYCLICAL</code><em class="property"> = 1</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.DEFENSIVE">
<code class="descname">DEFENSIVE</code><em class="property"> = 2</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.SENSITIVE">
<code class="descname">SENSITIVE</code><em class="property"> = 3</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.dtype">
<code class="descname">dtype</code><em class="property"> = dtype('int64')</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.inputs">
<code class="descname">inputs</code><em class="property"> = (asset_classification.morningstar_economy_sphere_code::int64,)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.SuperSector.missing_value">
<code class="descname">missing_value</code><em class="property"> = -1</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.classifiers.morningstar.</code><code class="descname">Sector</code></dt>
<dd><p>Classifier that groups assets by Morningstar Sector Code.</p>
<p>There are 11 possible classifications:</p>
<ul class="simple">
<li>101 - Basic Materials</li>
<li>102 - Consumer Cyclical</li>
<li>103 - Financial Services</li>
<li>104 - Real Estate</li>
<li>205 - Consumer Defensive</li>
<li>206 - Healthcare</li>
<li>207 - Utilities</li>
<li>308 - Communication Services</li>
<li>309 - Energy</li>
<li>310 - Industrials</li>
<li>311 - Technology</li>
</ul>
<p>These values are provided as integer constants on the class.</p>
<p>For more information on morningstar classification codes, see:
<a class="reference external" href="https://www.quantopian.com/help/fundamentals#industry-sector">https://www.quantopian.com/help/fundamentals#industry-sector</a>.</p>
<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.BASIC_MATERIALS">
<code class="descname">BASIC_MATERIALS</code><em class="property"> = 101</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.COMMUNICATION_SERVICES">
<code class="descname">COMMUNICATION_SERVICES</code><em class="property"> = 308</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.CONSUMER_CYCLICAL">
<code class="descname">CONSUMER_CYCLICAL</code><em class="property"> = 102</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.CONSUMER_DEFENSIVE">
<code class="descname">CONSUMER_DEFENSIVE</code><em class="property"> = 205</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.ENERGY">
<code class="descname">ENERGY</code><em class="property"> = 309</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.FINANCIAL_SERVICES">
<code class="descname">FINANCIAL_SERVICES</code><em class="property"> = 103</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.HEALTHCARE">
<code class="descname">HEALTHCARE</code><em class="property"> = 206</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.INDUSTRIALS">
<code class="descname">INDUSTRIALS</code><em class="property"> = 310</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.REAL_ESTATE">
<code class="descname">REAL_ESTATE</code><em class="property"> = 104</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.TECHNOLOGY">
<code class="descname">TECHNOLOGY</code><em class="property"> = 311</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.UTILITIES">
<code class="descname">UTILITIES</code><em class="property"> = 207</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.dtype">
<code class="descname">dtype</code><em class="property"> = dtype('int64')</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.inputs">
<code class="descname">inputs</code><em class="property"> = (asset_classification.morningstar_sector_code::int64,)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.classifiers.morningstar.Sector.missing_value">
<code class="descname">missing_value</code><em class="property"> = -1</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="earnings-calendars">
<h1>Earnings Calendars</h1>
<p>Zipline implements an abstract definition for working with
<a class="reference external" href="http://www.zipline.io/appendix.html#zipline.pipeline.data.EarningsCalendar" title="(in Zipline v0.9.0+6.gc207667)"><code class="xref py py-class docutils literal"><span class="pre">EarningsCalendar</span></code></a> datasets. Since more than one
of Quantopian&#8217;s data partners can provide earnings announcement dates,
Quantopian implements multiple distinct calendar datasets, as well as multiple
distinct versions of the
<code class="xref py py-class docutils literal"><span class="pre">BusinessDaysUntilNextEarnings</span></code>,
<code class="xref py py-class docutils literal"><span class="pre">BusinessDaysSincePreviousEarnings</span></code>
factors, which rely in the columns provided by each calendar.</p>
<p>In general, datasets specific to a particular vendor are imported from
<code class="docutils literal"><span class="pre">quantopian.pipeline.data.&lt;vendor&gt;</span></code>, while factors that depend on data
from a specific vendor are imported from
<code class="docutils literal"><span class="pre">quantopian.pipeline.factors.&lt;vendor&gt;</span></code>.</p>
<div class="section" id="module-quantopian.pipeline.data.eventvestor">
<span id="eventvestor"></span><h2>EventVestor</h2>
<p>All datasets listed here are importable from
<a class="reference internal" href="help.html#module-quantopian.pipeline.data.eventvestor" title="quantopian.pipeline.data.eventvestor"><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.data.eventvestor</span></code></a>.</p>
<dl class="class">
<dt id="quantopian.pipeline.data.eventvestor.EarningsCalendar">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.data.eventvestor.</code><code class="descname">EarningsCalendar</code></dt>
<dd><p>Dataset representing dates of upcoming or recently announced earnings.</p>
<dl class="attribute">
<dt id="quantopian.pipeline.data.eventvestor.EarningsCalendar.next_announcement">
<code class="descname">next_announcement</code><em class="property"> = EarningsCalendar.next_announcement::datetime64[ns]</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="quantopian.pipeline.data.eventvestor.EarningsCalendar.previous_announcement">
<code class="descname">previous_announcement</code><em class="property"> = EarningsCalendar.previous_announcement::datetime64[ns]</em></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-quantopian.pipeline.factors.eventvestor"></span><p>All factors listed here are importable from
<a class="reference internal" href="help.html#module-quantopian.pipeline.factors.eventvestor" title="quantopian.pipeline.factors.eventvestor"><code class="xref py py-mod docutils literal"><span class="pre">quantopian.pipeline.factors.eventvestor</span></code></a>.</p>
<dl class="class">
<dt id="quantopian.pipeline.factors.eventvestor.BusinessDaysUntilNextEarnings">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.eventvestor.</code><code class="descname">BusinessDaysUntilNextEarnings</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Factor returning the number of <strong>business days</strong> (not trading days!) until
the next known earnings date for each asset.</p>
<p>Assets that announced or will announce earnings on the day of <code class="docutils literal"><span class="pre">compute</span></code>
will produce a value of 0.0.  Assets that will announce the event on the
next upcoming business day will produce a value of 1.0.</p>
<p>Assets for which the date of the next earnings announcement is <code class="docutils literal"><span class="pre">NaT</span></code> will
produce a value of <code class="docutils literal"><span class="pre">NaN</span></code>.  This most commonly occurs because many
companies do not publish the exact date of their upcoming earnings
announcements until a few weeks before the announcement.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="help.html#quantopian.pipeline.factors.eventvestor.BusinessDaysSincePreviousEarnings" title="quantopian.pipeline.factors.eventvestor.BusinessDaysSincePreviousEarnings"><code class="xref py py-class docutils literal"><span class="pre">BusinessDaysSincePreviousEarnings</span></code></a></p>
</div>
</dd></dl>

<dl class="class">
<dt id="quantopian.pipeline.factors.eventvestor.BusinessDaysSincePreviousEarnings">
<em class="property">class </em><code class="descclassname">quantopian.pipeline.factors.eventvestor.</code><code class="descname">BusinessDaysSincePreviousEarnings</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Factor returning the number of <strong>business days</strong> (not trading days!) since
the most recent earnings date for each asset.</p>
<p>Assets that announced or will announce earnings on the day of <code class="docutils literal"><span class="pre">compute</span></code>
will produce a value of 0.0.  Assets that will announce the event on the
next upcoming business day will produce a value of 1.0.</p>
<p>Assets which announced or will announce the earnings today will produce a
value of 0.0. Assets that announced the on the previous business day will
produce a value of 1.0.</p>
<p>Assets for which the previous earnings date is <cite>NaT</cite> will produce a value
of <cite>NaN</cite>.  This will happen in the interval between IPO and first earnings
for most companies.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="help.html#quantopian.pipeline.factors.eventvestor.BusinessDaysUntilNextEarnings" title="quantopian.pipeline.factors.eventvestor.BusinessDaysUntilNextEarnings"><code class="xref py py-class docutils literal"><span class="pre">BusinessDaysUntilNextEarnings</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
</div>
<h3 class='margin_30t' id='api-other'>Other Methods</h3>
<p>Within your algorithm, there are some other methods you can use:</p>
<div class='api-method fetch-csv-section'>
<pre class='fetch-csv' id='api-fetchcsv'>fetch_csv(url, pre_func=None, post_func=None, date_column='date',
           date_format='%m/%d/%y', timezone='UTC', symbol=None, mask=True, **kwargs)</pre>
<p>Loads the given CSV file (specified by <strong>url</strong>) to be used in a backtest.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>url</span>:
<span class='parameter-payload'>A well-formed http or https url pointing to a CSV file that has a header, a date column, and a symbol column (symbol column required to match data to securities).</span>
</p>
<p>
<span class='parameter'>pre_func</span>:
<span class='parameter-payload'>(optional) A function that takes a pandas dataframe parameter (the result of pandas.io.parsers.read_csv) and returns another pandas dataframe.</span>
</p>
<p>
<span class='parameter'>post_func</span>:
<span class='parameter-payload'>(optional) A function that takes a pandas dataframe parameter and returns a dataframe.</span>
</p>
<p>
<span class='parameter'>date_column</span>:
<span class='parameter-payload'>(optional) A string identifying the column in the CSV file's header row that holds the parseable dates. Data is only imported when the date is reached in the backtest to avoid look-ahead bias.</span>
</p>
<p>
<span class='parameter'>date_format</span>:
<span class='parameter-payload'>(optional) A string defining the format of the date/time information held in the date_column.</span>
</p>
<p>
<span class='parameter'>timezone</span>:
<span class='parameter-payload'>(optional) Either a pytz timezone object or a string conforming to the pytz timezone database.</span>
</p>
<p>
<span class='parameter'>symbol</span>:
<span class='parameter-payload'>(optional) If specified, the fetcher data will be treated as a signal source, and all of the data in each row will be added to the data parameter of the handle_data method.  You can access all the CSV data from this source as data['symbol'].</span>
</p>
<p>
<span class='parameter'>mask</span>:
<span class='parameter-payload'>(optional) This is a boolean whose default is True. By default it will import information only for sids initialized in your algo. If set to False, it will import information for all securities in the CSV file.</span>
</p>
<p>
<span class='parameter'>**kwargs</span>:
<span class='parameter-payload'>(optional) Additional keyword arguments that are passed to the <code>requests.get</code> and pandas <code>read_csv</code> calls.  <a href='help.html#fetchcsv-modal' data-toggle='modal'>Click here</a> to see the valid arguments.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-get-datetime'><code>get_datetime(timezone)</code></p>
<p>Returns the current algorithm time. By default this is set to UTC, and you can pass an optional parameter to change the timezone.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>timezone</span>:
<span>(Optional) Timezone string that specifies in which timezone to output the result. For example, to get the current algorithm time in US Eastern time, set this parameter to 'US/Eastern'.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>Returns a Python datetime object with the current time in the algorithm. For daily data, the hours, minutes, and seconds are all 0.  For minute data, it's the end of the minute bar.</span>
</p>
</div>
<div class='api-method fetch-csv-section'>
<p class='api-code' id='api-get-environment'><code>get_environment(field='platform')</code></p>
<p>Returns information about the environment in which the backtest or live algorithm is running.</p>
<p>If no parameter is passed, the <code>platform</code> value is returned. Pass <code>*</code> to get all the values returned in a dictionary.</p>
<p>To use this method when running Zipline standalone, import get_environment from the zipline.api library.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>arena</span>:
<span class='parameter-payload'>Returns <code>IB</code>, <code>ROBINHOOD</code>, <code>live</code> (paper trading), or <code>backtest</code>.</span>
</p>
<p>
<span class='parameter'>data_frequency</span>:
<span class='parameter-payload'>Returns <code>minute</code> or <code>daily</code>.</span>
</p>
<p>
<span class='parameter'>start</span>:
<span class='parameter-payload'>Returns the UTC datetime for start of backtest. In <code>IB</code> and <code>live</code> arenas, this is when the live algorithm was deployed.</span>
</p>
<p>
<span class='parameter'>end</span>:
<span class='parameter-payload'>Returns the UTC datetime for end of backtest. In <code>IB</code> and <code>live</code> arenas, this is the trading day's close datetime.</span>
</p>
<p>
<span class='parameter'>capital_base</span>:
<span class='parameter-payload'>Returns the float of the original capital in USD.</span>
</p>
<p>
<span class='parameter'>platform</span>:
<span class='parameter-payload'>Returns the platform running the algorithm: <code>quantopian</code> or <code>zipline</code>.</span>
</p>
<br>
<p>Below is an example showing the parameter syntax.</p>
</div>
<div class='markdown-generated'>
<pre><code>from zipline.api import get_environment&#x000A;&#x000A;def handle_data(context, data):&#x000A;  # execute this code when algorithm is running with an&#x000A;  # Interactive Brokers account&#x000A;  if get_environment(&#39;arena&#39;) == &#39;IB&#39;:&#x000A;    pass&#x000A;&#x000A;  # execute this code when algorithm is running with a&#x000A;  # Robinhood account&#x000A;  if get_environment(&#39;arena&#39;) == &#39;ROBINHOOD&#39;:&#x000A;    pass&#x000A;&#x000A;  # execute this code when paper trading in Quantopian&#x000A;  if get_environment(&#39;arena&#39;) == &#39;live&#39;:&#x000A;    pass  &#x000A;&#x000A;  # execute this code if the backtest is in minute mode&#x000A;  if get_environment(&#39;data_frequency&#39;) == &#39;minute&#39;:&#x000A;    pass&#x000A;&#x000A;  # retrieve the start date of the backtest or live algorithm&#x000A;  print get_environment(&#39;start&#39;)  &#x000A;&#x000A;  # code that will only execute in Zipline environment.&#x000A;  # this is equivalent to get_environment() == &#39;zipline&#39;&#x000A;  if get_environment(&#39;platform&#39;) == &#39;zipline&#39;:&#x000A;    pass&#x000A;&#x000A;  # Code that will only execute in Quantopian IDE&#x000A;  # this is equivalent to get_environment() == &#39;quantopian&#39;&#x000A;  if get_environment(&#39;platform&#39;) == &#39;quantopian&#39;: &#x000A;   pass&#x000A;&#x000A;  # show the starting cash in the algorithm&#x000A;  print get_environment(&#39;capital_base&#39;)&#x000A;&#x000A;  # get all the current parameters of the environment    &#x000A;  print get_environment(&#39;*&#39;)              &#x000A;</code></pre>

</div>
<div class='api-method'>
<p class='api-code' id='api-log'><code>log.error(message), log.info(message), log.warn(message), log.debug(message)</code></p>
<p>Logs a message with the desired log level.  Log messages are displayed in the backtest output screen, and we only persist the last 512 of them.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>message</span>:
<span>The message to log.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-record'><code>record(series1_name=value1,
 series2_name=value2, ...)</code></p>
<p>Records the given series and values.  Generates a chart for all recorded series.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>values</span>:
<span>Keyword arguments (up to 5) specifying series and their values.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-record2'><code>record('series1_name', value1,
 'series2_name', value2, ...)</code></p>
<p>Records the given series and values.  Generates a chart for all recorded series.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>values</span>:
<span>Variables or securities (up to 5) specifying series and their values.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span class='parameter'>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-schedulefunction'><code>schedule_function(func=myfunc, date_rule=date_rule, time_rule=time_rule, half_days=True)</code></p>
<p>Automatically run a function on a predetermined schedule.  Can only be called from inside <code>initialize</code>.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>func</span>:
<span>The name of the function to run. This function must accept <code>context</code> and <code>data</code> as parameters, which will be the same as those passed to <code>handle_data</code>.</span>
</p>
<p>
<span class='parameter'>date_rule</span>:
<span>Specifies the date portion of the schedule. This can be every day, week, or month and has an offset parameter to indicate days from the first or last of the month. The <strong>default is daily</strong>, and the default <strong>offset is 0 days</strong>. In other words, if no date rule is specified, the function will run every day.</span>
<div class='margin_10l'>
<p>The valid values for date_rule are:</p>
<ul class='margin_50l'>
<li><code>date_rules.every_day()</code></li>
<li><code>date_rules.week_start(days_offset=0)</code></li>
<li><code>date_rules.week_end(days_offset=0)</code></li>
<li><code>date_rules.month_start(days_offset=0)</code></li>
<li><code>date_rules.month_end(days_offset=0)</code></li>
</ul>
</div>
</p>
<p>
<span class='parameter'>time_rule</span>:
<span>Specifies the time portion of the schedule. This can be set as market_open or market_close and has an offset parameter to indicate how many hours or minutes from the market open or close. The <strong>default is market open</strong>, and <strong>1 minute before close</strong>.</span>
<div class='margin_10l'>
<p>The valid values for date_rule are:</p>
<ul class='margin_50l'>
<li><code>time_rules.market_open(hours=0, minutes=1)</code></li>
<li><code>time_rules.market_close(hours=0, minutes=1)</code></li>
</ul>
</div>
</p>
<p>
<span class='parameter'>half_days</span>:
<span>Boolean value specifying whether half-days should be included in the schedule.  If false, the function will not be called on days with an early market close. The default is <code>True</code>.  If your function execution lands on a half day and this value is false, your function will not get run during that week or month cycle.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-symbollookupdate'><code>set_symbol_lookup_date('YYYY-MM-DD')</code></p>
<p>Globally sets the date to use when performing a symbol lookup (either by using <code>symbol</code> or <code>symbols</code>). This helps disambiguate cases where a symbol historically referred to different securities. If you only want symbols that are active today, set this to a recent date (e.g. '2014-10-21'). Needs to be set in <code>initialize</code> before calling any <code>symbol</code> or <code>symbols</code> functions.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>date</span>:
<span>The YYYY-MM-DD string format of a date.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>None</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-sid'><code>sid(int)</code></p>
<p>Convenience method that accepts an integer literal to look up a security by its id. A dynamic variable cannot be passed as a parameter. Within the IDE, an inline search box appears showing you matches on security id, symbol, and company name.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>int</span>:
<span>The id of a security.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>A security object.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-symbol'><code>symbol('symbol1')</code></p>
<p>Convenience method that accepts a string literal to look up a security by its symbol. A dynamic variable cannot be passed as a parameter. Within the IDE, an inline search box appears showing you matches on security id, symbol, and company name.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>'symbol1'</span>:
<span>The string symbol of a security.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>A security object.</span>
</p>
</div>
<div class='api-method'>
<p class='api-code' id='api-symbols'><code>symbols('symbol1', 'symbol2', ...)</code></p>
<p>Convenience method to initialize several securities by their symbol. Each parameter must be a string literal and separated by a comma.</p>
<div class='section-title'>Parameters</div>
<p>
<span class='parameter'>'symbol1', 'symbol2', ...</span>:
<span>Several string symbols.</span>
</p>
<div class='section-title'>Returns</div>
<p>
<span>A list of security objects.</span>
</p>
</div>
<h3 class='margin_30t' id='api-orderobj'>Order object</h3>
<p>If you have a reference to an order object, there are several properties that might be useful:</p>
<div class='api-method'>
<p class='api-code'>
<code>status</code>
</p>
<p>
<span class='parameter'>Integer:</span>
The status of the order.
</p>
<p class='margin_80l'>0 = Open</p>
<p class='margin_80l'>1 = Filled</p>
<p class='margin_80l'>2 = Cancelled</p>
<p class='margin_80l'>3 = Rejected</p>
<p class='margin_80l'>4 = Held</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>created</code>
</p>
<p>
<span class='parameter'>Datetime:</span>
The date and time the order was created, in UTC timezone.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>stop</code>
</p>
<p>
<span class='parameter'>Float:</span>
Optional stop price.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>limit</code>
</p>
<p>
<span class='parameter'>Float:</span>
Optional limit price.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>amount</code>
</p>
<p>
<span class='parameter'>Integer:</span>
Total shares ordered.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>sid</code>
</p>
<p>
<span class='parameter'>Security object:</span>
The security being ordered.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>filled</code>
</p>
<p>
<span class='parameter'>Integer:</span>
Total shares bought or sold for this order so far.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>stop_reached</code>
</p>
<p>
<span class='parameter'>Boolean:</span>
Variable if stop price has been reached.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>limit_reached</code>
</p>
<p>
<span class='parameter'>Boolean:</span>
Variable if limit price has been reached.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>Commission</code>
</p>
<p>
<span class='parameter'>Integer:</span>
Commission for transaction.
</p>
</div>
<h3 class='margin_30t' id='api-portfolio'>Portfolio object</h3>
<p>The portfolio object is accessed using <code>context.portfolio</code> and has the following properties:</p>
<div class='api-method'>
<p class='api-code'>
<code>capital_used</code>
</p>
<p>
<span class='parameter'>Float:</span>
The net capital consumed (positive means spent) by buying and selling securities up to this point.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>cash</code>
</p>
<p>
<span class='parameter'>Float:</span>
The current amount of cash in your portfolio.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>pnl</code>
</p>
<p>
<span class='parameter'>Float:</span>
Dollar value profit and loss, for both realized and unrealized gains.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>positions</code>
</p>
<p>
<span class='parameter'>Dictionary:</span>
A dictionary of all the open positions, keyed by security ID.  More information about each position object can be found in the next section.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>portfolio_value</code>
</p>
<p>
<span class='parameter'>Float:</span>
Sum value of all open positions and ending cash balance.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>positions_value</code>
</p>
<p>
<span class='parameter'>Float:</span>
Sum value of all open positions.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>returns</code>
</p>
<p>
<span class='parameter'>Float:</span>
Cumulative percentage returns for the entire portfolio up to this point. Calculated as a fraction of the starting value of the portfolio. The returns calculation includes cash and portfolio value.  The number is not formatted as a percentage, so a 10% return is formatted as 0.1.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>starting_cash</code>
</p>
<p>
<span class='parameter'>Float:</span>
Initial capital base for this backtest or live execution.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>start_date</code>
</p>
<p>
<span class='parameter'>DateTime:</span>
UTC datetime of the beginning of this backtest's period.  For live trading, this marks the UTC datetime that this algorithm started executing.
</p>
</div>
<h3 class='margin_30t' id='api-position'>Position object</h3>
<p>The position object represents a current open position, and is contained inside the positions dictionary.  For example, if you had an open AAPL position, you'd access it using <code>context.portfolio.positions[symbol('AAPL')]</code>.  The position object has the following properties:</p>
<div class='api-method'>
<p class='api-code'>
<code>amount</code>
</p>
<p>
<span class='parameter'>Integer:</span>
Whole number of shares in this position.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>cost_basis</code>
</p>
<p>
<span class='parameter'>Float:</span>
The volume-weighted average price paid (price and commission) per share in this position.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>last_sale_price</code>
</p>
<p>
<span class='parameter'>Float:</span>
Price at last sale of this security. This is identical to <code>close_price</code> and <code>price</code>.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>sid</code>
</p>
<p>
<span class='parameter'>Integer:</span>
The ID of the security.
</p>
</div>
<h3 class='margin_30t' id='api-sidinfo'>Equity object</h3>
<p>If you have a reference to an equity object, there are several properties that might be useful:</p>
<div class='api-method'>
<p class='api-code'>
<code>sid</code>
</p>
<p>
<span class='parameter'>Integer:</span>
The id of this equity.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>symbol</code>
</p>
<p>
<span class='parameter'>String:</span>
The ticker symbol of this equity.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>asset_name</code>
</p>
<p>
<span class='parameter'>String:</span>
The full name of this equity.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>start_date</code>
</p>
<p>
<span class='parameter'>Datetime:</span>
The date when this equity first started trading.
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>end_date</code>
</p>
<p>
<span class='parameter'>Datetime:</span>
The date when this equity stopped trading (= today for equities that are trading normally).
</p>
</div>
<h3 id='api-account'>Account object</h3>
<p>Below is a table of account fields available to reference in a live trading algorithm with Interactive Brokers. In backtesting, the field will take a default value from the simulated portfolio.</p>
<div class='account-fields'>
<div class='api-method'>
<p class='api-code'>
<code>context.account.accrued_interest</code>
(IB: <strong>AccruedCash</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Interest that has accumulated but has not been paid or charged.
<div class='backtest-default'>
Backtest value: <code>0</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.available_funds</code>
(IB: <strong>AvailableFunds</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Equity with loan value less the initial margin requirement.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.cash</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.buying_power</code>
(IB: <strong>BuyingPower</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
<div class='desc'>IB Cash Account: Minimum (Equity with Loan Value, Previous Day Equity with Loan Value)-Initial Margin.</div>
<div class='desc2'>IB Margin Account: Available Funds * 4.</div>
<div class='backtest-default'>
Backtest value: <code>Infinity</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.cushion</code>
(IB: <strong>Cushion</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Excess liquidity as a percentage of net liquidation.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.cash / context.portfolio.portfolio_value</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.day_trades_remaining</code>
(IB: <strong>DayTradesRemaining</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The number of open/close trades a user can place before pattern day trading is detected.
<div class='backtest-default'>
Backtest value: <code>Infinity</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.equity_with_loan</code>
(IB: <strong>EquityWithLoanValue</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
<div class='desc'>IB Cash Account: Settled Cash.</div>
<div class='desc2'>IB Margin Account: Total cash value + stock value + bond value + (non-U.S. &amp; Canada securities options value).</div>
<div class='backtest-default'>
Backtest value: <code>context.portfolio.portfolio_value</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.excess_liquidity</code>
(IB: <strong>ExcessLiquidity</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Equity with loan value less the maintenance margin.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.cash</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.initial_margin_requirement</code>
(IB: <strong>InitMarginReq</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The minimum portion of a new security purchase that an investor must pay for in cash.
<div class='backtest-default'>
Backtest value: <code>0</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.leverage</code>
(IB: <strong>GrossLeverage</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Gross position value divided by net liquidation.
<div class='backtest-default'>
Backtest value: <code>(long value + abs(short_value)) / context.portfolio.portfolio_value</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.maintenance_margin_requirement</code>
(IB: <strong>MaintMarginReq</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The amount of equity which must be maintained in order to continue holding a position.
<div class='backtest-default'>
Backtest value: <code>0</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.net_leverage</code>
(IB: <strong>NetLeverage</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The default value is also used for live trading.
<div class='backtest-default'>
Backtest value: <code>Net exposure value divided by net liquidation.</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.net_liquidation</code>
(IB: <strong>NetLiquidation</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Total cash, stock, securities options, bond, and fund value.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.portfolio_value</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.regt_equity</code>
(IB: <strong>RegTEquity</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
<div class='desc'>IB Cash Account: Settled Cash.</div>
<div class='desc2'>IB Margin Account: Total cash value + stock value + bond value +  (non-U.S. &amp; Canada securities options value).</div>
<div class='backtest-default'>
Backtest value: <code>context.portfolio.cash</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.regt_margin</code>
(IB: <strong>RegTMargin</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The margin requirement calculated under US Regulation T rules.
<div class='backtest-default'>
Backtest value: <code>Infinity</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.settled_cash</code>
(IB: <strong>SettledCash</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
Cash recognized at the time of settlement less purchases at the time of trade, commissions, taxes, and fees.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.cash</code>
</div>
</p>
</div>
<div class='api-method'>
<p class='api-code'>
<code>context.account.total_positions_value</code>
(IB: <strong>GrossPositionValue</strong>)
</p>
<p>
<span class='parameter'>
(Float)
</span>
The sum of the absolute value of all stock and equity option positions.
<div class='backtest-default'>
Backtest value: <code>context.portfolio.positions_value</code>
</div>
</p>
</div>
</div>
<h3 id='api-talib'>TA-Lib methods</h3>
<p>TA-Lib is an <a href='http://www.ta-lib.org'>open-source library</a> to process financial data.  The methods are available to use in the Quantopian API and you can see here for the <a href='http://ta-lib.org/function.html'>full list of available functions</a>. </p>
<p>When using TA-Lib methods, import the library at the beginning of your algorithm.</p>
<img alt="Help-talib" class="help-image" height="238px" src="assets/help-talib-e30d439aac8ea6b15ee802de6a011903.png" />
<p>You can look at the <a href='help.html#talib-examples'>examples of commonly-used TA-Lib functions</a> and at our <a href='help.html#sample-talib'>sample TA-Lib algorithm</a>.</p>
<h4>Daily vs minute data</h4>
<p>The talib library respects the data frequency being passed in to it. If you pass in daily data into the library, then all the time periods are calculated in days. If you pass in minutes, then all the time periods are in minutes.</p>
<h4>Moving average types</h4>
<o>Some of the TA-Lib methods have an integer <code>matype</code> parameter.  Here's the list of moving average types:</o>
<pre class='ta-lib-pre'>0: SMA (simple)&#x000A;1: EMA (exponential)&#x000A;2: WMA (weighted)&#x000A;3: DEMA (double exponential)&#x000A;4: TEMA (triple exponential)&#x000A;5: TRIMA (triangular) &#x000A;6: KAMA (Kaufman adaptive)&#x000A;7: MAMA (Mesa adaptive)&#x000A;8: T3 (triple exponential T3)</pre>
<h4 id='talib-examples'>Examples of Commonly Used Talib Functions</h4>
<ul>
<li><a href='help.html#atr'>ATR</a></li>
<li><a href='help.html#bollinger-bands'>Bollinger Bands</a></li>
<li><a href='help.html#macd'>MACD</a></li>
<li><a href='help.html#rsi'>RSI</a></li>
<li><a href='help.html#stoch'>STOCH</a></li>
</ul>
<br>
<h5 id='atr'>ATR</h5>
<p>This algorithm uses ATR as a momentum strategy to identify price breakouts.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_talib_atr'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This strategy was taken from http://www.investopedia.com/articles/trading/08/atr.asp&#x000A;&#x000A;# The idea is to use ATR to identify breakouts, if the price goes higher than&#x000A;# the previous close + ATR, a price breakout has occurred. The position is closed when&#x000A;# the price goes 1 ATR below the previous close. &#x000A;&#x000A;# This algorithm uses ATR as a momentum strategy, but the same signal can be used for &#x000A;# a reversion strategy, since ATR doesn't indicate the price direction.&#x000A;&#x000A;import talib&#x000A;import numpy as np&#x000A;import pandas as pd&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    # SPY&#x000A;    context.spy = sid(8554)&#x000A;    &#x000A;    # Algorithm will only take long positions.&#x000A;    # It will stop if encounters a short position. &#x000A;    set_long_only()&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;# Rebalance daily.&#x000A;def rebalance(context, data):&#x000A;    &#x000A;    # Track our position&#x000A;    current_position = context.portfolio.positions[context.spy].amount&#x000A;    record(position_size=current_position)&#x000A;    &#x000A;    &#x000A;    # Load historical data for the stocks&#x000A;    hist = data.history(context.spy, ['high', 'low', 'close'], 30, '1d')&#x000A;    &#x000A;    # Calculate the ATR for the stock&#x000A;    atr = talib.ATR(hist['high'],&#x000A;                    hist['low'],&#x000A;                    hist['close'],&#x000A;                    timeperiod=14)[-1]&#x000A;    &#x000A;    price = data.current(context.spy, 'price')&#x000A;    &#x000A;    # Use the close price from yesterday because we trade at market open&#x000A;    prev_close = hist['close'][-2]&#x000A;    &#x000A;    # An upside breakout occurs when the price goes 1 ATR above the previous close&#x000A;    upside_signal = price - (prev_close + atr)&#x000A;    &#x000A;    # A downside breakout occurs when the previous close is 1 ATR above the price&#x000A;    downside_signal = prev_close - (price + atr)&#x000A;    &#x000A;    # Enter position when an upside breakout occurs. Invest our entire portfolio to go long.&#x000A;    if upside_signal > 0 and current_position <= 0 and data.can_trade(context.spy):&#x000A;        order_target_percent(context.spy, 1.0)&#x000A;    &#x000A;    # Exit position if a downside breakout occurs&#x000A;    elif downside_signal > 0 and current_position >= 0 and data.can_trade(context.spy):&#x000A;        order_target_percent(context.spy, 0.0)&#x000A;        &#x000A;    &#x000A;    record(upside_signal=upside_signal,&#x000A;           downside_signal=downside_signal,&#x000A;           ATR=atr)&#x000A;&#x000A;</pre>
<h5 id='bollinger-bands'>Bollinger Bands</h5>
<p>This example uses the talib Bollinger Bands function to determine entry points for long and short positions. When the the price breaks out of the upper Bollinger band, a short position is opened. A long position is created when the price dips below the lower band.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_talib_bollinger_bands'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This algorithm uses the talib Bollinger Bands function to determine entry entry &#x000A;# points for long and short positions.&#x000A;&#x000A;# When the price breaks out of the upper Bollinger band, a short position&#x000A;# is opened. A long position is opened when the price dips below the lower band.&#x000A;&#x000A;import talib&#x000A;import numpy as np&#x000A;import pandas as pd&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    # SPY&#x000A;    context.spy = sid(8554)&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;# Rebalance daily.&#x000A;def rebalance(context, data):&#x000A;    current_position = context.portfolio.positions[context.spy].amount&#x000A;    price=data.current(context.spy, 'price')&#x000A;    &#x000A;    # Load historical data for the stocks&#x000A;    prices = data.history(context.spy, 'price', 15, '1d')&#x000A;    &#x000A;    upper, middle, lower = talib.BBANDS(&#x000A;        prices, &#x000A;        timeperiod=10,&#x000A;        # number of non-biased standard deviations from the mean&#x000A;        nbdevup=2,&#x000A;        nbdevdn=2,&#x000A;        # Moving average type: simple moving average here&#x000A;        matype=0)&#x000A;    &#x000A;    # If price is below the recent lower band and we have&#x000A;    # no long positions then invest the entire&#x000A;    # portfolio value into SPY&#x000A;    if price <= lower[-1] and current_position <= 0 and data.can_trade(context.spy):&#x000A;        order_target_percent(context.spy, 1.0)&#x000A;    &#x000A;    # If price is above the recent upper band and we have&#x000A;    # no short positions then invest the entire&#x000A;    # portfolio value to short SPY&#x000A;    elif price >= upper[-1] and current_position >= 0 and data.can_trade(context.spy):&#x000A;        order_target_percent(context.spy, -1.0)&#x000A;        &#x000A;    record(upper=upper[-1],&#x000A;           lower=lower[-1],&#x000A;           mean=middle[-1],&#x000A;           price=price,&#x000A;           position_size=current_position)&#x000A;&#x000A;</pre>
<h5 id='macd'>MACD</h5>
<p>In this example, when the MACD signal less than 0, the stock price is trending down and it's time to sell the security. When the MACD signal greater than 0, the stock price is trending up it's time to buy.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_talib_macd'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This example algorithm uses the Moving Average Crossover Divergence (MACD) indicator as a buy/sell signal.&#x000A;&#x000A;# When the MACD signal less than 0, the stock price is trending down and it's time to sell.&#x000A;# When the MACD signal greater than 0, the stock price is trending up it's time to buy.&#x000A;&#x000A;# Because this algorithm uses the history function, it will only run in minute mode. &#x000A;# We will constrain the trading to once per day at market open in this example.&#x000A;&#x000A;import talib&#x000A;import numpy as np&#x000A;import pandas as pd&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    context.stocks = symbols('MMM', 'SPY', 'GOOG_L', 'PG', 'DIA')&#x000A;    context.pct_per_stock = 1.0 / len(context.stocks)&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;# Rebalance daily.&#x000A;def rebalance(context, data):&#x000A;    &#x000A;    # Load historical data for the stocks&#x000A;    prices = data.history(context.stocks, 'price', 40, '1d')&#x000A;    &#x000A;    macds = {}&#x000A;    &#x000A;    # Iterate over the list of stocks&#x000A;    for stock in context.stocks:&#x000A;        # Create the MACD signal and pass in the three parameters: fast period, slow period, and the signal.&#x000A;        macd_raw, signal, hist = talib.MACD(prices[stock], fastperiod=12, &#x000A;                                        slowperiod=26, signalperiod=9)&#x000A;        macd = macd_raw[-1] - signal[-1]&#x000A;        macds[stock] = macd&#x000A;        &#x000A;        current_position = context.portfolio.positions[stock].amount&#x000A;        &#x000A;        # Close position for the stock when the MACD signal is negative and we own shares.&#x000A;        if macd < 0 and current_position > 0 and data.can_trade(stock):&#x000A;            order_target(stock, 0)&#x000A;            &#x000A;        # Enter the position for the stock when the MACD signal is positive and &#x000A;        # our portfolio shares are 0.&#x000A;        elif macd > 0 and current_position == 0 and data.can_trade(stock):&#x000A;            order_target_percent(stock, context.pct_per_stock)&#x000A;           &#x000A;        &#x000A;    record(goog=macds[symbol('GOOG_L')],&#x000A;           spy=macds[symbol('SPY')],&#x000A;           mmm=macds[symbol('MMM')])&#x000A;&#x000A;&#x000A;&#x000A;</pre>
<h5 id='rsi'>RSI</h5>
<p>Use the RSI signal to drive algorithm buying and selling decisions. When the RSI is over 70, a stock can be seen as overbought and it's time to sell. On the other hand, when the RSI is below 30, a stock can be seen as underbought and it's time to buy.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_talib_rsi'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This example algorithm uses the Relative Strength Index indicator as a buy/sell signal.&#x000A;# When the RSI is over 70, a stock can be seen as overbought and it's time to sell.&#x000A;# When the RSI is below 30, a stock can be seen as oversold and it's time to buy.&#x000A;&#x000A;import talib&#x000A;&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    context.stocks = symbols('MMM', 'SPY', 'GE')&#x000A;    context.target_pct_per_stock = 1.0 / len(context.stocks)&#x000A;    context.LOW_RSI = 30&#x000A;    context.HIGH_RSI = 70&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;# Rebalance daily.&#x000A;def rebalance(context, data):&#x000A;    &#x000A;    # Load historical data for the stocks&#x000A;    prices = data.history(context.stocks, 'price', 20, '1d')&#x000A;    &#x000A;    rsis = {}&#x000A;    &#x000A;    # Loop through our list of stocks&#x000A;    for stock in context.stocks:&#x000A;        # Get the rsi of this stock.&#x000A;        rsi = talib.RSI(prices[stock], timeperiod=14)[-1]&#x000A;        rsis[stock] = rsi&#x000A;        &#x000A;        current_position = context.portfolio.positions[stock].amount&#x000A;        &#x000A;        # RSI is above 70 and we own shares, time to sell&#x000A;        if rsi > context.HIGH_RSI and current_position > 0 and data.can_trade(stock):&#x000A;            order_target(stock, 0)&#x000A;   &#x000A;        # RSI is below 30 and we don't have any shares, time to buy&#x000A;        elif rsi < context.LOW_RSI and current_position == 0 and data.can_trade(stock):&#x000A;            order_target_percent(stock, context.target_pct_per_stock)&#x000A;&#x000A;    # record the current RSI values of each stock&#x000A;    record(ge_rsi=rsis[symbol('GE')],&#x000A;           spy_rsi=rsis[symbol('SPY')],&#x000A;           mmm_rsi=rsis[symbol('MMM')])&#x000A;&#x000A;&#x000A;&#x000A;&#x000A;</pre>
<h5 id='stoch'>STOCH</h5>
<p>Below is an algorithm that uses the talib STOCH function. When the stochastic oscillator dips below 10, the stock is determined to be oversold and a long position is opened. The position is exited when the indicator rises above 90 because the stock is considered to be overbought.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_talib_stoch'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This algorithm uses talib's STOCH function to determine entry and exit points.&#x000A;&#x000A;# When the stochastic oscillator dips below 10, the stock is determined to be oversold&#x000A;# and a long position is opened. The position is exited when the indicator rises above 90&#x000A;# because the stock is thought to be overbought.&#x000A;&#x000A;import talib&#x000A;import numpy as np&#x000A;import pandas as pd&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    context.stocks = symbols('SPY', 'AAPL', 'GLD', 'AMZN')&#x000A;    &#x000A;    # Set the percent of the account to be invested per stock&#x000A;    context.long_pct_per_stock = 1.0 / len(context.stocks)&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;# Rebalance daily.&#x000A;def rebalance(context, data):&#x000A;    &#x000A;    # Load historical data for the stocks&#x000A;    hist = data.history(context.stocks, ['high', 'low', 'close'], 30, '1d')&#x000A;    &#x000A;    # Iterate over our list of stocks&#x000A;    for stock in context.stocks:&#x000A;        current_position = context.portfolio.positions[stock].amount&#x000A;        slowk, slowd = talib.STOCH(hist['high'][stock],&#x000A;                                   hist['low'][stock],&#x000A;                                   hist['close'][stock],&#x000A;                                   fastk_period=5,&#x000A;                                   slowk_period=3,&#x000A;                                   slowk_matype=0,&#x000A;                                   slowd_period=3,&#x000A;                                   slowd_matype=0)&#x000A;&#x000A;        # get the most recent value&#x000A;        slowk = slowk[-1]&#x000A;        slowd = slowd[-1]&#x000A;        &#x000A;        # If either the slowk or slowd are less than 10, the stock is &#x000A;        # 'oversold,' a long position is opened if there are no shares&#x000A;        # in the portfolio.&#x000A;        if slowk < 10 or slowd < 10 and current_position <= 0 and data.can_trade(stock):&#x000A;            order_target_percent(stock, context.long_pct_per_stock)&#x000A;        &#x000A;        # If either the slowk or slowd are larger than 90, the stock is &#x000A;        # 'overbought' and the position is closed. &#x000A;        elif slowk > 90 or slowd > 90 and current_position >= 0 and data.can_trade(stock):&#x000A;            order_target(stock, 0)&#x000A;&#x000A;</pre>
<h3 id='api-common-errors'>Common Error Messages</h3>
<p>Below are examples and sample solutions to commonly-encountered errors while coding your strategy. If you need assistance, <a class='open-feedback-link'>contact us</a> and we can help you debug the algorithm.</p>
<div class='api-method large'>
<p class='api-code'>
<code>ExecutionTimeout</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Request took too long to execute. Possible messages include HandleDataTimeoutException, InitializeTimoutException, TimeoutException, ExecutionTimeout.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>
<ul>
<li>Optimize your code to use faster functions. For example, make sure you aren't making redundant calls to <a href='help.html#ide-history'>history()</a>.</li>
<li>Use a smaller universe of securities. Every security you include in the algorithm increases memory and CPU requirements of the algorithm.</li>
<li>Backtest over a small time period.</li>
</ul>
</div>
</div>
</p>
<p class='api-code margin_30t' id='api-common-errors-key-error'>
<code>KeyError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Causes:</div>
<div class='span10'>
<ul>
<li>Incorrect use of a dictionary. Mapping key is not found in the set of existing keys.</li>
<li>Security price data is missing for the given bar, since every stock doesn't trade each minute. This often happens in the case of illiquid securities.</li>
<li><a href='help.html#overview-fetcher'>Fetcher</a> data is missing for the given bar, since Fetcher will populate your <a href='help.html#api-handle_data'>data</a> object only when there is data for the given date.</li>
</ul>
</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solutions:</div>
<div class='span10'>
<ul>
<li>For missing keys in a dictionary, check that the key exists within the dictionary object. For example:</li>
<pre>if 'blank' in dict_obj:
    value = dict_obj['blank']</pre>
</ul>
</div>
</div>
</p>
<p class='api-code margin_30t'>
<code>LinAlgError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Illegal matrix operation. For example, trying to take the determinant of a singular matrix.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>Update matrix values to perform desired operation.</div>
</div>
</p>
<p class='api-code margin_30t'>
<code>MemoryError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Backtest ran out of memory on server.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>
<ul>
<li>Avoid creating too many objects or unusually large objects in your algorithm. An object can be a variable, function, or data structure.</li>
<li>Use a smaller universe of securities. Every security you include in the algorithm increases memory and CPU requirements of the algorithm.</li>
<li>Avoid accumulating an increasing amount of data in each bar of the backtest.</li>
<li>Backtest over a shorter time period.</li>
</ul>
</div>
</div>
</p>
<p class='api-code margin_30t'>
<code>Something went wrong on our end. Sorry for the inconvenience.</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Unknown error.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>Please contact <a class='open-feedback-link'>feedback</a> so we can help debug your code.</div>
</div>
</p>
<p class='api-code error margin_30t'>
<code>SyntaxError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Invald Python or Quantopian syntax. May be due to missing colon, bracket, parenthesis, or quote.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>Insert or remove extra notation in function.</div>
</div>
</p>
<p class='api-code error margin_30t'>
<code>TypeError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Raised when encountering an object that is not of the expected type.</div>
</div>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solution:</div>
<div class='span10'>Insert or remove extra notation in function.</div>
</div>
</p>
<p class='api-code error margin_30t'>
<code>ValueError</code>
</p>
<p>
<div class='row-fluid'>
<div class='span1 min_width_70'>Cause:</div>
<div class='span10'>Raised when a function receives an argument that has the right type but an inappropriate value. For example, if you try to take the square root of a negative number.</div>
</div>
</p>
<p>
<div class='row-fluid margin_10t'>
<div class='span1 min_width_70'>Solutions:</div>
<div class='span10'>
<ul>
<li>Perform legal operations on expected values.</li>
<li>If you run into the following error, then your code needs to specify which elements in the array are being compared. <code> ValueError: The truth value of a DataFrame is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().</code>. In the example below, the last elements in two lists are being compared.</li>
<pre class='prettyprint margin_50l'>if list_one[-1] > list_two[-1]:&#x000A;   #ordering logic</pre>
</ul>
</div>
</div>
</p>
</div>
<h3 id='api-ide-tips'>IDE Tips and Shortcuts</h3>
<p> You can customize the color and text size of the IDE for your algorithms. Simply click on the gear button in the top right corner and choose your settings.</p>
<img alt="Help-settings" class="help-image" height="153px" src="assets/help-settings-6b5249fb2d972d84c66f69cedb37da62.png" />
<p>Below are keyboard shortcuts you can use in the IDE.</p>
<table class='table table-bordered table-condensed table-striped'>
<thead>
<tr class='white-container'>
<th>Action</th>
<th>Windows Keystroke</th>
<th>Apple Keystroke</th>
</tr>
</thead>
<tr>
<td>Build Algorithm</td>
<td>Ctrl + B</td>
<td>Cmd + B</td>
</tr>
<tr>
<td>Indent</td>
<td>Ctrl + ]</td>
<td>Cmd + ]</td>
</tr>
<tr>
<td>Outdent</td>
<td>Ctrl + [</td>
<td>Cmd + [</td>
</tr>
<tr>
<td>Create/Remove Comment</td>
<td>Ctrl + /</td>
<td>Cmd + /</td>
</tr>
<tr>
<td>Search Code</td>
<td>Ctrl + F</td>
<td>Cmd + F</td>
</tr>
<tr>
<td>Undo</td>
<td>Ctrl + Z</td>
<td>Cmd + Z</td>
</tr>
<tr>
<td>Redo</td>
<td>Ctrl + Y</td>
<td>Cmd + Y</td>
</tr>
</table>
<p>Need more space to see your code? Drag the bar all the way to the right to expand the code window.</p>
<img alt="Help-expandwindow" class="help-image" height="200px" src="assets/help-expandwindow-93652f2605b43cd431f0ba98fa6df547.png" />
<p>If you are building a custom graph you can <code>record</code> up to five variables. To view only certain variables, click on the variable name to remove it from the chart. Click it again to add it back to the graph. Want to zoom in on a certain timeperiod? Use the bar underneath the graph to select a specific time window.</p>
<p>Below is an example of a custom graph with all the variables selected. The following graph displays only the recorded cash value.</p>
<img alt="Help-customgraph" class="help-image" height="200px" src="assets/help-customgraph-168254bec4d68cef9996f1cba6c226bf.png" />
<img alt="Help-customgraph-cash" class="help-image" height="200px" src="assets/help-customgraph-cash-30a7a2cd7b22f92eade9891145008a38.png" />
<div id='research-env'>
<h2>Research Environment API</h2>
<p>
The research environment and the IDE/backtester currently have different APIs.  The following sections describe
the functions that are available in research.  Take a look at the
<a href='https://www.quantopian.com/research/notebooks/Tutorials%20and%20Documentation/0.%20API%20Reference.ipynb'>API Reference</a> sample
notebook to try these functions out for yourself.
</p>
<!-- / The _qexec_research.html file which is included below was generated from the numpy-style doc strings -->
<!-- / in qexec (using sphinx).  Ideally updating that file would happen automatically as part of the -->
<!-- / qexec build, but for now we have to build the docs from the command line and copy the file over. -->
<div id='research-api-docs'>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <span class="target" id="module-quantopian.research"></span><dl class="function">
<dt id="quantopian.research.get_pricing">
<code class="descclassname">quantopian.research.</code><code class="descname">get_pricing</code><span class="sig-paren">(</span><em>symbols</em>, <em>start_date='2013-01-03'</em>, <em>end_date='2014-01-03'</em>, <em>symbol_reference_date=None</em>, <em>frequency='daily'</em>, <em>fields=None</em>, <em>handle_missing='raise'</em><span class="sig-paren">)</span></dt>
<dd><p>Load a table of historical trade data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>symbols</strong> (<em>Object (or iterable of objects) convertible to Asset</em>) &#8211; Valid input types are Asset, Integral, or basestring.  In the case that
the passed objects are strings, they are interpreted
as ticker symbols and resolved relative to the date specified by
symbol_reference_date.</li>
<li><strong>start_date</strong> (<em>str or pd.Timestamp, optional</em>) &#8211; String or Timestamp representing a start date for the returned data.
Defaults to &#8216;2013-01-03&#8217;.</li>
<li><strong>end_date</strong> (<em>str or pd.Timestamp, optional</em>) &#8211; String or Timestamp representing an end date for the returned data.
Defaults to &#8216;2014-01-03&#8217;.</li>
<li><strong>symbol_reference_date</strong> (<em>str or pd.Timestamp, optional</em>) &#8211; String or Timestamp representing a date used to resolve symbols that
have been held by multiple companies. Defaults to the current time.</li>
<li><strong>frequency</strong> (<em>{&#8216;daily&#8217;, &#8216;minute&#8217;}, optional</em>) &#8211; Resolution of the data to be returned.</li>
<li><strong>fields</strong> (<em>str or list, optional</em>) &#8211; String or list drawn from {&#8216;price&#8217;, &#8216;open_price&#8217;, &#8216;high&#8217;, &#8216;low&#8217;,
&#8216;close_price&#8217;, &#8216;volume&#8217;}.  Default behavior is to return all fields.</li>
<li><strong>handle_missing</strong> (<em>{&#8216;raise&#8217;, &#8216;log&#8217;, &#8216;ignore&#8217;}, optional</em>) &#8211; String specifying how to handle unmatched securities.
Defaults to &#8216;raise&#8217;.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>pandas Panel/DataFrame/Series</em> &#8211;
The pricing data that was requested.  See note below.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If a list of symbols is provided, data is returned in the form of a pandas
Panel object with the following indices:</p>
<div class="highlight-python"><div class="highlight"><pre>items = fields
major_axis = TimeSeries (start_date -&gt; end_date)
minor_axis = symbols
</pre></div>
</div>
<p>If a string is passed for the value of <cite>symbols</cite> and <cite>fields</cite> is None or a
list of strings, data is returned as a DataFrame with a DatetimeIndex and
columns given by the passed fields.</p>
<p>If a list of symbols is provided, and <cite>fields</cite> is a string, data is
returned as a DataFrame with a DatetimeIndex and a columns given by the
passed <cite>symbols</cite>.</p>
<p>If both parameters are passed as strings, data is returned as a Series.</p>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.symbols">
<code class="descclassname">quantopian.research.</code><code class="descname">symbols</code><span class="sig-paren">(</span><em>symbols</em>, <em>symbol_reference_date=None</em>, <em>handle_missing='log'</em><span class="sig-paren">)</span></dt>
<dd><p>Convert a string or a list of strings into Asset objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>symbols</strong> (<em>String or iterable of strings.</em>) &#8211; Passed strings are interpreted as ticker symbols and resolved relative
to the date specified by symbol_reference_date.</li>
<li><strong>symbol_reference_date</strong> (<em>str or pd.Timestamp, optional</em>) &#8211; String or Timestamp representing a date used to resolve symbols that
have been held by multiple companies.  Defaults to the current time.</li>
<li><strong>handle_missing</strong> (<em>{&#8216;raise&#8217;, &#8216;log&#8217;, &#8216;ignore&#8217;}, optional</em>) &#8211; String specifying how to handle unmatched securities.
Defaults to &#8216;log&#8217;.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>list of Asset objects</em> &#8211;
The symbols that were requested.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.local_csv">
<code class="descclassname">quantopian.research.</code><code class="descname">local_csv</code><span class="sig-paren">(</span><em>path</em>, <em>symbol_column=None</em>, <em>date_column=None</em>, <em>use_date_column_as_index=True</em>, <em>timezone='UTC'</em>, <em>symbol_reference_date=None</em>, <em>**read_csv_kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Load a CSV from the /data directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) &#8211; Path of file to load, relative to /data.</li>
<li><strong>symbol_column</strong> (<em>string, optional</em>) &#8211; Column containing strings to convert to Asset objects.</li>
<li><strong>date_column</strong> (<em>str, optional</em>) &#8211; Column to parse as Datetime.  Ignored if <cite>parse_dates</cite> is passed as
an additional keyword argument.</li>
<li><strong>use_date_column_as_index</strong> (<em>bool, optional</em>) &#8211; If True and date_column is supplied, set it as the frame index.</li>
<li><strong>timezone</strong> (<em>str or pytz.timezone object, optional</em>) &#8211; Interpret date_column as this timezone.</li>
<li><strong>read_csv_kwargs</strong> (<em>optional</em>) &#8211; Extra parameters to forward to pandas.read_csv.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>pandas.DataFrame</em> &#8211;
DataFrame with data from the loaded file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.get_backtest">
<code class="descclassname">quantopian.research.</code><code class="descname">get_backtest</code><span class="sig-paren">(</span><em>backtest_id</em><span class="sig-paren">)</span></dt>
<dd><p>Get the results of a backtest that was run on Quantopian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>backtest_id</strong> (<em>str</em>) &#8211; The id of the backtest for which results should be returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>BacktestResult</em> &#8211;
An object containing all the information stored by Quantopian about the
performance of a given backtest run, as well as some additional
metadata.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>You can find the ID of a backtest in the URL of its full results page,
which will be of the form:</p>
<div class="highlight-python"><div class="highlight"><pre>https://www.quantopian.com/algorithms/&lt;algorithm_id&gt;/&lt;backtest_id&gt;
</pre></div>
</div>
<p>Once you have your BacktestResult object, you can call
<code class="docutils literal"><span class="pre">create_full_tear_sheet()</span></code> on it to get an in-depth analysis of your
backtest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bt</span> <span class="o">=</span> <span class="n">get_backtest</span><span class="p">(</span><span class="s">&#39;&lt;backtest_id&gt;&#39;</span><span class="p">)</span>
<span class="n">bt</span><span class="o">.</span><span class="n">create_full_tear_sheet</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">results.AlgorithmResult.create_full_tear_sheet()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.get_live_results">
<code class="descclassname">quantopian.research.</code><code class="descname">get_live_results</code><span class="sig-paren">(</span><em>live_algo_id</em><span class="sig-paren">)</span></dt>
<dd><p>Get the results of a live algorithm running on Quantopian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>live_algo_id</strong> (<em>str</em>) &#8211; The id of the algorithm for which results should be returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>LiveAlgorithmResult</em> &#8211;
An object containing all the information stored by Quantopian about the
performance of a given live algorithm, as well as some additional
metadata.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>You can find the ID of a live algorithm in the URL of its full results
page, which will be of the form:</p>
<div class="highlight-python"><div class="highlight"><pre>https://www.quantopian.com/live_algorithms/&lt;algorithm_id&gt;
</pre></div>
</div>
<p>Once you have your LiveAlgorithmResult object, you can call
<code class="docutils literal"><span class="pre">create_full_tear_sheet()</span></code> on it to get an in-depth analysis of your
live algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lr</span> <span class="o">=</span> <span class="n">get_live_results</span><span class="p">(</span><span class="s">&#39;&lt;algorithm_id&gt;&#39;</span><span class="p">)</span>
<span class="n">lr</span><span class="o">.</span><span class="n">create_full_tear_sheet</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-func docutils literal"><span class="pre">results.AlgorithmResult.create_full_tear_sheet()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.get_fundamentals">
<code class="descclassname">quantopian.research.</code><code class="descname">get_fundamentals</code><span class="sig-paren">(</span><em>query</em>, <em>base_date</em>, <em>range_specifier=None</em>, <em>filter_ordered_nulls=None</em><span class="sig-paren">)</span></dt>
<dd><p>Load a table of historical fundamentals data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>query</strong> (<em>SQLAlchemy Query object</em>) &#8211; An SQLAlchemy Query representing the fundamentals data desired.
Full documentation of the available fields for use in the query
function can be found at <a class="reference external" href="http://quantopian.com/help/fundamentals">http://quantopian.com/help/fundamentals</a></li>
<li><strong>base_date</strong> (<em>str in the format &#8220;YYYY-MM-DD&#8221;</em>) &#8211; Represents the date on which data is to be queried.  This simulates
the backtester making the same query on this date.</li>
<li><strong>range_specifier</strong> (<em>str, optional</em>) &#8211; String in the format {number}{One of &#8216;m&#8217;, &#8216;d&#8217;, &#8216;y&#8217;, &#8216;w&#8217;, &#8216;q&#8217;}.
Represents the interval at which to query data.
For example, a base_date of &#8220;2014-01-01&#8221; with a range_specifier of
&#8220;4y&#8221; will return 4 data values at yearly intervals, from
2014-01-01 going backwards.</li>
<li><strong>filter_ordered_nulls</strong> (<em>bool, optional</em>) &#8211; When True, if you are sorting the query results via an
<cite>order_by</cite> method, any row with a NULL value in the sorted column
will be filtered out. Setting to False overrides this behavior and
provides you with rows with a NULL value for the sorted column.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>pandas.Panel</em> &#8211;
A Pandas panel containing the requested fundamentals data.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The query argument must be built from attributes of the fundamentals
namespace returned by init_fundamentals().</p>
<p>When querying for a time series, the dates in the major axis of the
returned panel are algo dates. This data matches the results of the
backtester&#8217;s get_fundamentals function being called on each of those dates.
This is the best data known to the backtester &#8220;before trading starts.&#8221;</p>
<p>Querying of quarterly data is still under development and
may sometimes return inaccurate values.</p>
</dd></dl>

<dl class="function">
<dt id="quantopian.research.run_pipeline">
<code class="descclassname">quantopian.research.</code><code class="descname">run_pipeline</code><span class="sig-paren">(</span><em>pipeline</em>, <em>start_date</em>, <em>end_date</em><span class="sig-paren">)</span></dt>
<dd><p>Compute values for <cite>pipeline</cite> between <cite>start_date</cite> and <cite>end_date</cite>.</p>
<p>Returns a DataFrame with a MultiIndex of (date, asset) pairs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pipeline</strong> (<em>zipline.pipeline.Pipeline</em>) &#8211; The pipeline to run.</li>
<li><strong>start_date</strong> (<em>pd.Timestamp</em>) &#8211; Start date of the computed matrix.</li>
<li><strong>end_date</strong> (<em>pd.Timestamp</em>) &#8211; End date of the computed matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p><strong>result</strong> (<em>pd.DataFrame</em>) &#8211;
A frame of computed results.</p>
<p>The columns <cite>result</cite> correspond will be the computed results of
<cite>pipeline.columns</cite>, which should be a dictionary mapping strings to
instances of <cite>zipline.pipeline.term.Term</cite>.</p>
<p>For each date between <cite>start_date</cite> and <cite>end_date</cite>, <cite>result</cite> will
contain a row for each asset that passed <cite>pipeline.screen</cite>.  A
screen of None indicates that a row should be returned for each
asset that existed each day.</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qexec.research.results.AlgorithmResult">
<em class="property">class </em><code class="descclassname">qexec.research.results.</code><code class="descname">AlgorithmResult</code><span class="sig-paren">(</span><em>result_iterator</em>, <em>progress_bar</em>, <em>algo_id</em><span class="sig-paren">)</span></dt>
<dd><p>Container for results of backtest/live algo run. BacktestResult and
LiveAlgorithmResult inherit from this class.</p>
<dl class="method">
<dt id="qexec.research.results.AlgorithmResult.create_full_tear_sheet">
<code class="descname">create_full_tear_sheet</code><span class="sig-paren">(</span><em>benchmark_rets=None</em>, <em>live_start_date=None</em>, <em>bayesian=False</em>, <em>hide_positions=False</em>, <em>cone_std=1.0</em><span class="sig-paren">)</span></dt>
<dd><p>Render the full pyfolio tear sheet for this algorithm result.</p>
</dd></dl>

</dd></dl>



        </div>
      </div>
    </div>

  </body>
</html>
</div>
</div>
<h2 id='sample-algos'>Sample Algorithms</h2>
<p>Below are examples to help you learn the Quantopian functions and backtest in the IDE. Clone an algorithm to get your own copy.</p>
<h3 id='sample-basic'>Basic Algorithm</h3>
<p>This example demonstrates all of the basic concepts you need to write a simple algorithm that tries to capitalize on a stock's momentum.  This shows you the symbol function, logging, volume-weighted average price, price, and placing orders. You clone this algorithm below or from the <a href='https://www.quantopian.com/posts/discuss-the-sample-algorithm-1'>community discussion of this post</a>.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_algo'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>"""&#x000A;For this example, we're going to write a simple momentum script.  &#x000A;When the stock goes up quickly, we're going to buy; &#x000A;when it goes down we're going to sell.  &#x000A;Hopefully we'll ride the waves.&#x000A;&#x000A;To run an algorithm in Quantopian, you need to define two functions: &#x000A;initialize and handle_data.&#x000A;&#x000A;Note: AAPL had a 7:1 split in June 2014, which is reflected in the &#x000A;recorded variables plot.&#x000A;"""&#x000A;&#x000A;"""&#x000A;The initialize function sets any data or variables that &#x000A;you'll use in your algorithm. &#x000A;It's only called once at the beginning of your algorithm.&#x000A;"""&#x000A;def initialize(context):&#x000A;    # In our example, we're looking at Apple.  If you re-type &#x000A;    # this line you'll see the auto-complete popup after `sid(`.&#x000A;    context.security = sid(24)&#x000A;&#x000A;    # Specify that we want the 'rebalance' method to run once a day&#x000A;    schedule_function(rebalance, date_rule=date_rules.every_day())&#x000A;&#x000A;"""&#x000A;Rebalance function scheduled to run once per day (at market open).&#x000A;"""&#x000A;def rebalance(context, data):&#x000A;    # To make market decisions, we're calculating the stock's &#x000A;    # moving average for the last 5 days.&#x000A;&#x000A;    # We get the price history for the last 5 days. &#x000A;    price_history = data.history(&#x000A;        context.security,&#x000A;        fields='price',&#x000A;        bar_count=5,&#x000A;        frequency='1d'&#x000A;    )&#x000A;&#x000A;    # Then we take an average of those 5 days.&#x000A;    average_price = price_history.mean()&#x000A;    &#x000A;    # We also get the stock's current price. &#x000A;    current_price = data.current(context.security, 'price') &#x000A;    &#x000A;    # If our stock is currently listed on a major exchange&#x000A;    if data.can_trade(context.security):&#x000A;        # If the current price is 1% above the 5-day average price, &#x000A;        # we open a long position. If the current price is below the &#x000A;        # average price, then we want to close our position to 0 shares.&#x000A;        if current_price > (1.01 * average_price):&#x000A;            # Place the buy order (positive means buy, negative means sell)&#x000A;            order_target_percent(context.security, 1)&#x000A;            log.info("Buying %s" % (context.security.symbol))&#x000A;        elif current_price < average_price:&#x000A;            # Sell all of our shares by setting the target position to zero&#x000A;            order_target_percent(context.security, 0)&#x000A;            log.info("Selling %s" % (context.security.symbol))&#x000A;    &#x000A;    # Use the record() method to track up to five custom signals. &#x000A;    # Record Apple's current price and the average price over the last &#x000A;    # five days.&#x000A;    record(current_price=current_price, average_price=average_price)&#x000A;&#x000A;</pre>
<h3 id='sample-schedule-function'>Schedule Function</h3>
<p>This example uses <code>schedule_function()</code> to rebalance at 11:00AM once per week on the first trading day of that week. Clone the algorithm to get your own copy where you can change the securitites and rebalancing window.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_schedule_function'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>"""&#x000A;This algorithm defines a long-only equal weight portfolio and &#x000A;rebalances it at a user-specified frequency.&#x000A;"""&#x000A;&#x000A;# Import the libraries we will use here&#x000A;import datetime&#x000A;import pandas as pd&#x000A;&#x000A;def initialize(context):&#x000A;    # In this example, we're looking at 9 sector ETFs.  &#x000A;    context.security_list = symbols('XLY',  # XLY Consumer Discretionary SPDR Fund   &#x000A;                           'XLF',  # XLF Financial SPDR Fund  &#x000A;                           'XLK',  # XLK Technology SPDR Fund  &#x000A;                           'XLE',  # XLE Energy SPDR Fund  &#x000A;                           'XLV',  # XLV Health Care SPRD Fund  &#x000A;                           'XLI',  # XLI Industrial SPDR Fund  &#x000A;                           'XLP',  # XLP Consumer Staples SPDR Fund   &#x000A;                           'XLB',  # XLB Materials SPDR Fund  &#x000A;                           'XLU')  # XLU Utilities SPRD Fund&#x000A;&#x000A;    # This variable is used to manage leverage&#x000A;    context.weights = 0.99/len(context.security_list)&#x000A;&#x000A;    # These are the default commission and slippage settings.  Change&#x000A;    # them to fit your brokerage fees. These settings only matter for &#x000A;    # backtesting.  When you live trade this algorithm, they are moot - &#x000A;    # the brokerage and real market takes over.&#x000A;    set_commission(commission.PerShare(cost=0.0075, min_trade_cost=1))&#x000A;    set_slippage(slippage.VolumeShareSlippage(volume_limit=0.025, price_impact=0.1))&#x000A;&#x000A;    # Rebalance every day (or the first trading day if it's a holiday).&#x000A;    # At 11AM ET, which is 1 hour and 30 minutes after market open.&#x000A;    schedule_function(rebalance, &#x000A;                      date_rules.week_start(days_offset=0),&#x000A;                      time_rules.market_open(hours = 1, minutes = 30))  &#x000A;&#x000A;def rebalance(context, data):&#x000A;&#x000A;    # Do the rebalance. Loop through each of the stocks and order to&#x000A;    # the target percentage.  If already at the target, this command &#x000A;    # doesn't do anything. A future improvement could be to set rebalance&#x000A;    # thresholds.&#x000A;    for sec in context.security_list:&#x000A;        if data.can_trade(sec):&#x000A;            order_target_percent(sec, context.weights)&#x000A;&#x000A;    # Get the current exchange time, in the exchange timezone &#x000A;    exchange_time = get_datetime('US/Eastern')&#x000A;    log.info("Rebalanced to target portfolio weights at %s" % str(exchange_time))&#x000A;&#x000A;</pre>
<div id='pipeline-samples'>
<h3 id='sample-pipeline-api'>Pipeline</h3>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="using-pipelines">
<h1>Using Pipelines</h1>
<p>In this algo, you will learn about creating and attaching a pipeline, adding
factors and filters, setting screens and accessing the output of your pipeline.</p>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='pipeline_built_in_factors'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># The pipeline API requires imports.&#x000A;from quantopian.pipeline import Pipeline&#x000A;from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline.data.builtin import USEquityPricing&#x000A;from quantopian.pipeline.factors import SimpleMovingAverage, AverageDollarVolume&#x000A;&#x000A;&#x000A;def initialize(context):&#x000A;&#x000A;    # Create, register and name a pipeline in initialize.&#x000A;    pipe = Pipeline()&#x000A;    attach_pipeline(pipe, 'example')&#x000A;&#x000A;    # Construct a simple moving average factor and add it to the pipeline.&#x000A;    sma = SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=10)&#x000A;    pipe.add(sma, 'sma')&#x000A;&#x000A;    # Construct a 30-day average dollar volume factor and add it to the&#x000A;    # pipeline.&#x000A;    dollar_volume = AverageDollarVolume(window_length=30)&#x000A;    pipe.add(dollar_volume, 'dollar_volume')&#x000A;&#x000A;    # Define high dollar-volume filter to be the top 2% of stocks by dollar volume.&#x000A;    high_dollar_volume = dollar_volume.percentile_between(98, 100)&#x000A;&#x000A;    # Set a screen on the pipelines to filter out securities.&#x000A;    pipe.set_screen((sma > 1.0) & high_dollar_volume)&#x000A;&#x000A;&#x000A;def before_trading_start(context, data):&#x000A;    # Pipeline_output returns the constructed dataframe.&#x000A;    output = pipeline_output('example')&#x000A;&#x000A;    # Select and update your universe.&#x000A;    context.my_securities = output.sort('sma', ascending=False).iloc[:50]&#x000A;    print len(context.my_securities)&#x000A;&#x000A;    context.security_list = context.my_securities.index&#x000A;&#x000A;    log.info("\n" + str(context.my_securities.head(5)))&#x000A;&#x000A;</pre>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="combining-and-ranking">
<h1>Combining and Ranking</h1>
<p>This example shows that factors can be combined to create new factors, that
factors can be ranked using masks, and how you can use the pipeline API to
create long and short lists.</p>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='pipeline_ranking'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline import Pipeline&#x000A;from quantopian.pipeline.data.builtin import USEquityPricing&#x000A;from quantopian.pipeline.factors import SimpleMovingAverage&#x000A;&#x000A;def initialize(context):&#x000A;    pipe = Pipeline()&#x000A;    attach_pipeline(pipe, 'example')&#x000A;&#x000A;    sma_short = SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=30)&#x000A;    sma_long = SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=100)&#x000A;&#x000A;    # Combined factors to create new factors&#x000A;    sma_quotient = sma_short / sma_long&#x000A;&#x000A;    # Create and apply a screen to remove penny stocks&#x000A;    remove_penny_stocks = sma_short > 1.0&#x000A;&#x000A;    sma_rank = sma_quotient.rank(mask=remove_penny_stocks)&#x000A;&#x000A;    # Rank a factor using a mask to ignore the values we're&#x000A;    # filtering out by passing mask=remove_penny_stocks to rank.&#x000A;    pipe.add(sma_rank, 'sma_rank')&#x000A;&#x000A;    longs = sma_rank.top(200, mask=remove_penny_stocks)&#x000A;    shorts = sma_rank.bottom(200, mask=remove_penny_stocks)&#x000A;&#x000A;    pipe.add(longs, 'longs')&#x000A;    pipe.add(shorts, 'shorts')&#x000A;&#x000A;    # Use multiple screens to narrow the universe&#x000A;    pipe.set_screen(longs | shorts)&#x000A;&#x000A;def before_trading_start(context, data):&#x000A;    context.output = pipeline_output('example')&#x000A;&#x000A;    context.longs = context.output[context.output.longs]&#x000A;    context.shorts = context.output[context.output.shorts]&#x000A;&#x000A;    context.security_list = context.shorts.index.union(context.longs.index)&#x000A;&#x000A;    # Print the 5 securities with the lowest sma_rank.&#x000A;    print "SHORT LIST"&#x000A;    log.info("\n" + str(context.shorts.sort(['sma_rank'], ascending=True).head()))&#x000A;&#x000A;    # Print the 5 securities with the highest sma_rank.&#x000A;    print "LONG LIST"&#x000A;    log.info("\n" + str(context.longs.sort(['sma_rank'], ascending=False).head()))&#x000A;&#x000A;</pre>
<html xmlns="http://www.w3.org/1999/xhtml">
  <body role="document">
    <div class="document">
      <div class="documentwrapper">
        <div class="body" role="main">
          
  <div class="section" id="creating-custom-factors">
<h1>Creating Custom Factors</h1>
<p>This example shows how custom factors can be defined and used. It also shows
how pricing data and Morningstar fundamentals data can be used together.</p>
</div>


        </div>
      </div>
    </div>

  </body>
</html>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='pipeline_custom_factors'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline import Pipeline&#x000A;from quantopian.pipeline import CustomFactor&#x000A;from quantopian.pipeline.data.builtin import USEquityPricing&#x000A;from quantopian.pipeline.data import morningstar&#x000A;from quantopian.pipeline.factors import SimpleMovingAverage, AverageDollarVolume&#x000A;&#x000A;&#x000A;# Create custom factor subclass to calculate a market cap based on yesterday's&#x000A;# close&#x000A;class MarketCap(CustomFactor):&#x000A;    # Pre-declare inputs and window_length&#x000A;    inputs = [USEquityPricing.close, morningstar.valuation.shares_outstanding]&#x000A;    window_length = 1&#x000A;&#x000A;    # Compute market cap value&#x000A;    def compute(self, today, assets, out, close, shares):&#x000A;        out[:] = close[-1] * shares[-1]&#x000A;&#x000A;&#x000A;def initialize(context):&#x000A;    pipe = Pipeline()&#x000A;    attach_pipeline(pipe, 'example')&#x000A;&#x000A;    # Note that we don't call add_factor on these Factors.&#x000A;    # We don't need to store intermediate values if we're not going to use them&#x000A;    sma_short = SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=30)&#x000A;    sma_long = SimpleMovingAverage(inputs=[USEquityPricing.close], window_length=100)&#x000A;&#x000A;    sma_quotient = sma_short / sma_long&#x000A;&#x000A;    # Construct the custom factor&#x000A;    mkt_cap = MarketCap()&#x000A;&#x000A;    # Create and apply a filter representing the top 500 equities by MarketCap&#x000A;    # every day.&#x000A;    mkt_cap_top_500 = mkt_cap.top(500)&#x000A;&#x000A;    # Construct an average dollar volume factor and add it to the pipeline.&#x000A;    dollar_volume = AverageDollarVolume(window_length=30)&#x000A;    pipe.add(dollar_volume, 'dollar_volume')&#x000A;&#x000A;    # Define high dollar-volume filter to be the top 10% of stocks by dollar&#x000A;    # volume.&#x000A;    high_dollar_volume = dollar_volume.percentile_between(90, 100)&#x000A;&#x000A;    high_cap_high_dv = mkt_cap_top_500 & high_dollar_volume&#x000A;&#x000A;    pipe.add(sma_quotient, 'sma_quotient')&#x000A;    pipe.add(mkt_cap, 'mkt_cap')&#x000A;&#x000A;    # Create and add filters for our long and short portfolios.&#x000A;    longs = sma_quotient.top(200, mask=high_cap_high_dv)&#x000A;    shorts = sma_quotient.bottom(200, mask=high_cap_high_dv)&#x000A;&#x000A;    pipe.add(longs, 'longs')&#x000A;    pipe.add(shorts, 'shorts')&#x000A;&#x000A;    # Use multiple screens to narrow the universe&#x000A;    pipe.set_screen(longs | shorts)&#x000A;&#x000A;def before_trading_start(context, data):&#x000A;    context.output = pipeline_output('example')&#x000A;    context.longs = context.output[context.output.longs]&#x000A;    context.shorts = context.output[context.output.shorts]&#x000A;&#x000A;    context.security_list = context.shorts.index.union(context.longs.index)&#x000A;&#x000A;    # Print the 5 securities with the lowest sma_quotient.&#x000A;    print "SHORT LIST"&#x000A;    log.info("\n" + str(context.shorts.sort(['sma_quotient'], ascending=True).head()))&#x000A;&#x000A;    # Print the 5 securities with the highest sma_quotient.&#x000A;    print "LONG LIST"&#x000A;    log.info("\n" + str(context.longs.sort(['sma_quotient'], ascending=False).head()))&#x000A;&#x000A;</pre>
</div>
<h3 id='sample-earnings-risk'>Earnings Announcement Risk Framework</h3>
<p>This example demonstrates how to detect and react to earnings announcements in your algorithm. It uses the <a href="help.html#built-in-data-factors">built-in earnings announcement pipeline data factors</a> to avoid securities 3 days around an earnings announcement</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='data_eventvestor_earnings_calendar'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># For full information on the dataset please visit Quantopian data at&#x000A;# https://www.quantopian.com/data/eventvestor/earnings_calendar&#x000A;&#x000A;from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline import Pipeline&#x000A;&#x000A;# Both Free & Paid versions will be accessed through the same&#x000A;# namespace&#x000A;from quantopian.pipeline.data.eventvestor import EarningsCalendar&#x000A;from quantopian.pipeline.factors.eventvestor import (&#x000A;    BusinessDaysUntilNextEarnings,&#x000A;    BusinessDaysSincePreviousEarnings&#x000A;)&#x000A;import numpy as np&#x000A;&#x000A;def initialize(context):&#x000A;    pipe = Pipeline()&#x000A;    pipe = attach_pipeline(pipe, name='risk')&#x000A;    # EarningsCalendar.X is the actual date of the announcement&#x000A;    # E.g. 9/12/2015&#x000A;    pipe.add(EarningsCalendar.next_announcement.latest, 'next')&#x000A;    pipe.add(EarningsCalendar.previous_announcement.latest, 'prev')&#x000A;    # BusinessDaysX is the integer days until or after the closest&#x000A;    # announcement. So if AAPL had an earnings announcement yesterday,&#x000A;    # prev_earnings would be 1. If it's the day of, it will be 0.&#x000A;    # For BusinessDaysUntilNextEarnings(), it is common that the value&#x000A;    # is NaaN because we typically don't know the precise date of an&#x000A;    # earnings announcement until about 15 days before&#x000A;    ne = BusinessDaysUntilNextEarnings()&#x000A;    pe = BusinessDaysSincePreviousEarnings()&#x000A;    pipe.add(ne, 'next_earnings')&#x000A;    pipe.add(pe, 'prev_earnings')&#x000A;    # The number of days before/after an announcement that you want to&#x000A;    # avoid an earnings for.&#x000A;    pipe.set_screen((ne.isnan() | (ne > 3)) & (pe > 3))    &#x000A;    &#x000A;def before_trading_start(context, data):&#x000A;    # Here, we're updating the pipeline of our securities&#x000A;    # as well as grabbing the stocks that have an upcoming&#x000A;    # earnings announcement date.&#x000A;    context.results = pipeline_output('risk').iloc[:200]&#x000A;    log.info(context.results.iloc[:5])&#x000A;&#x000A;</pre>
<h3 id='sample-fundamentals'>Fundamental Data Algorithm</h3>
<p>This example demonstrates how to use fundamental data in your algorithm. It constructs a SQLAlchemy query to pull securities based on their PE ratio and economic sector. The results are then filtered and sorted. The algorithm seeks equal-weights in its positions and rebalances once at the beginning of each month.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_fundamentals'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>"""&#x000A;Trading Strategy using Fundamental Data&#x000A;&#x000A;1. Filter the top 50 companies by market cap &#x000A;2. Find the top two sectors that have the highest average PE ratio&#x000A;3. Every month exit all the positions before entering new ones&#x000A;4. Log the positions that we need &#x000A;"""&#x000A;&#x000A;import numpy as np&#x000A;&#x000A;def initialize(context):&#x000A;    # Dictionary of stocks and their respective weights&#x000A;    context.stock_weights = {}&#x000A;    # Count of days before rebalancing&#x000A;    context.days = 0&#x000A;    # Number of sectors to go long in&#x000A;    context.sect_numb = 2&#x000A;    &#x000A;    # Sector mappings&#x000A;    context.sector_mappings = {&#x000A;       101.0: "Basic Materials",&#x000A;       102.0: "Consumer Cyclical",&#x000A;       103.0: "Financial Services",&#x000A;       104.0: "Real Estate",&#x000A;       205.0: "Consumer Defensive",&#x000A;       206.0: "Healthcare",&#x000A;       207.0: "Utilites",&#x000A;       308.0: "Communication Services",&#x000A;       309.0: "Energy",&#x000A;       310.0: "Industrials",&#x000A;       311.0: "Technology"&#x000A;    }&#x000A;    &#x000A;    # Rebalance monthly on the first day of the month at market open&#x000A;    schedule_function(rebalance,&#x000A;                      date_rule=date_rules.month_start(),&#x000A;                      time_rule=time_rules.market_open())&#x000A;&#x000A;    schedule_function(record_positions,&#x000A;                      date_rule=date_rules.month_start(),&#x000A;                      time_rule=time_rules.market_close())&#x000A;    &#x000A;"""&#x000A;Called before the start of each trading day.  Runs the&#x000A;fundamentals query and saves the matching securities into&#x000A;context.fundamentals_df.&#x000A;"""&#x000A;def before_trading_start(context, data): &#x000A;    &#x000A;    num_stocks = 50&#x000A;    &#x000A;    # Setup SQLAlchemy query to screen stocks based on PE ratio&#x000A;    # and industry sector. Then filter results based on market cap &#x000A;    # and shares outstanding. We limit the number of results to &#x000A;    # num_stocks and return the data in descending order.&#x000A;    fundamental_df = get_fundamentals(&#x000A;        query(&#x000A;            # put your query in here by typing "fundamentals."&#x000A;            fundamentals.valuation_ratios.pe_ratio,&#x000A;            fundamentals.asset_classification.morningstar_sector_code&#x000A;        )&#x000A;        .filter(fundamentals.valuation.market_cap != None)&#x000A;        .filter(fundamentals.valuation.shares_outstanding != None)&#x000A;        .order_by(fundamentals.valuation.market_cap.desc())&#x000A;        .limit(num_stocks)&#x000A;    )&#x000A;&#x000A;    # Find sectors with the highest average PE&#x000A;    sector_pe_dict = {}&#x000A;    for stock in fundamental_df:&#x000A;        sector = fundamental_df[stock]['morningstar_sector_code']&#x000A;        pe = fundamental_df[stock]['pe_ratio']&#x000A;        &#x000A;        # If it exists add our pe to the existing list. &#x000A;        # Otherwise don't add it.&#x000A;        if sector not in sector_pe_dict:&#x000A;          sector_pe_dict[sector] = []&#x000A;&#x000A;        sector_pe_dict[sector].append(pe)&#x000A;    &#x000A;    # Find average PE per sector&#x000A;    sector_pe_dict = dict([&#x000A;        (sectors, np.average(sector_pe_dict[sectors])) &#x000A;        for sectors in sector_pe_dict &#x000A;        if len(sector_pe_dict[sectors]) > 0&#x000A;    ])&#x000A;    &#x000A;    # Sort in ascending order&#x000A;    sectors = sorted(&#x000A;                  sector_pe_dict, &#x000A;                  key=lambda x: sector_pe_dict[x], &#x000A;                  reverse=True&#x000A;              )[:context.sect_numb]&#x000A;    &#x000A;    # Filter out only stocks with that particular sector&#x000A;    context.stocks = [&#x000A;        stock for stock in fundamental_df&#x000A;        if fundamental_df[stock]['morningstar_sector_code'] in sectors&#x000A;    ]&#x000A;    &#x000A;    # Initialize a context.sectors variable&#x000A;    context.sectors = [context.sector_mappings[sect] for sect in sectors]&#x000A;&#x000A;    # Update context.fundamental_df with the securities (and pe_ratio) &#x000A;    # that we need&#x000A;    context.fundamental_df = fundamental_df[context.stocks]       &#x000A;&#x000A;&#x000A;def create_weights(stocks):&#x000A;    """&#x000A;        Takes in a list of securities and weights them all equally &#x000A;    """&#x000A;    if len(stocks) == 0:&#x000A;        return 0 &#x000A;    else:&#x000A;        weight = 1.0 / len(stocks)&#x000A;        return weight&#x000A;&#x000A;def rebalance(context, data):&#x000A;    # Exit all positions before starting new ones&#x000A;    for stock in context.portfolio.positions:&#x000A;        if stock not in context.fundamental_df and data.can_trade(stock):&#x000A;            order_target_percent(stock, 0)&#x000A;&#x000A;    log.info("The two sectors we are ordering today are %r" % context.sectors)&#x000A;&#x000A;    # Create weights for each stock&#x000A;    weight = create_weights(context.stocks)&#x000A;&#x000A;    # Rebalance all stocks to target weights&#x000A;    for stock in context.fundamental_df:&#x000A;        if data.can_trade(stock):&#x000A;          if weight != 0:&#x000A;              code = context.sector_mappings[&#x000A;                   context.fundamental_df[stock]['morningstar_sector_code']&#x000A;              ]&#x000A;&#x000A;              log.info(&#x000A;                  "Ordering %0.0f%% percent of %s in %s" % &#x000A;                  (weight * 100, stock.symbol, code)&#x000A;              )&#x000A;              &#x000A;          order_target_percent(stock, weight)&#x000A;&#x000A;def record_positions(context, data):&#x000A;    # track how many positions we're holding&#x000A;    record(num_positions = len(context.portfolio.positions))&#x000A;    &#x000A;</pre>
<h3 id='sample-meanreversion'>Mean Reversion Example</h3>
<p>This algorithm shows the basics of mean reversion. It selects a large basket of securities and ranks the securities based on their 5 day returns. It shorts the top-performing securities and goes long the bottom securities, hedging the positions.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_mean_reversion'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>    """&#x000A;This is a sample mean-reversion algorithm on Quantopian for you to test and adapt.&#x000A;This example uses a dynamic stock selector, pipeline, to select stocks to trade. &#x000A;It orders stocks from the top 1% of the previous day's dollar-volume (liquid&#x000A;stocks).&#x000A;&#x000A;Algorithm investment thesis:&#x000A;Top-performing stocks from last week will do worse this week, and vice-versa.&#x000A;&#x000A;Every Monday, we rank high dollar-volume stocks based on their previous 5 day returns.&#x000A;We long the bottom 10% of stocks with the WORST returns over the past 5 days.&#x000A;We short the top 10% of stocks with the BEST returns over the past 5 days.&#x000A;&#x000A;This type of algorithm may be used in live trading and in the Quantopian Open.&#x000A;"""&#x000A;&#x000A;# Import the libraries we will use here.&#x000A;from quantopian.algorithm import attach_pipeline, pipeline_output&#x000A;from quantopian.pipeline import Pipeline&#x000A;from quantopian.pipeline.data.builtin import USEquityPricing&#x000A;from quantopian.pipeline.factors import AverageDollarVolume, Returns&#x000A;&#x000A;&#x000A;def initialize(context):&#x000A;    """&#x000A;    Called once at the start of the program. Any one-time&#x000A;    startup logic goes here.&#x000A;    """&#x000A;    # Define context variables that can be accessed in other methods of&#x000A;    # the algorithm.&#x000A;    context.long_leverage = 0.5&#x000A;    context.short_leverage = -0.5&#x000A;    context.returns_lookback = 5&#x000A;&#x000A;    # Rebalance on the first trading day of each week at 11AM.&#x000A;    schedule_function(rebalance,&#x000A;                      date_rules.week_start(days_offset=0),&#x000A;                      time_rules.market_open(hours=1, minutes=30))&#x000A;&#x000A;    # Record tracking variables at the end of each day.&#x000A;    schedule_function(record_vars,&#x000A;                      date_rules.every_day(),&#x000A;                      time_rules.market_close(minutes=1))&#x000A;&#x000A;    # Create and attach our pipeline (dynamic stock selector), defined below.&#x000A;    attach_pipeline(make_pipeline(context), 'mean_reversion_example')&#x000A;&#x000A;&#x000A;def make_pipeline(context):&#x000A;    """&#x000A;    A function to create our pipeline (dynamic stock selector). The pipeline is used&#x000A;    to rank stocks based on different factors, including builtin factors, or custom&#x000A;    factors that you can define. Documentation on pipeline can be found here:&#x000A;    https://www.quantopian.com/help#pipeline-title&#x000A;    """&#x000A;    # Create a pipeline object.&#x000A;    pipe = Pipeline()&#x000A;&#x000A;    # Create a dollar_volume factor using default inputs and window_length.&#x000A;    # This is a builtin factor.&#x000A;    dollar_volume = AverageDollarVolume(window_length=1)&#x000A;    pipe.add(dollar_volume, 'dollar_volume')&#x000A;&#x000A;    # Create a recent_returns factor with a 5-day returns lookback. This is&#x000A;    # a custom factor defined below (see RecentReturns class).&#x000A;    recent_returns = Returns(window_length=context.returns_lookback)&#x000A;    pipe.add(recent_returns, 'recent_returns')&#x000A;&#x000A;    # Define high dollar-volume filter to be the top 5% of stocks by dollar volume.&#x000A;    high_dollar_volume = dollar_volume.percentile_between(95, 100)&#x000A;&#x000A;    # Define high and low returns filters to be the bottom 10% and top 10% of&#x000A;    # securities in the high dollar-volume group.&#x000A;    low_returns = recent_returns.percentile_between(0,10,mask=high_dollar_volume)&#x000A;    high_returns = recent_returns.percentile_between(90,100,mask=high_dollar_volume)&#x000A;&#x000A;    # Factors return a scalar value for each security in the entire universe&#x000A;    # of securities. Here, we add the recent_returns rank factor to our pipeline&#x000A;    # and we provide it with a mask such that securities that do not pass the mask&#x000A;    # (i.e. do not have high dollar-volume), are not considered in the ranking.&#x000A;    pipe.add(recent_returns.rank(mask=high_dollar_volume), 'recent_returns_rank')&#x000A;&#x000A;    # Add a filter to the pipeline such that only high-return and low-return&#x000A;    # securities are kept.&#x000A;    pipe.set_screen(low_returns | high_returns)&#x000A;&#x000A;    # Add the low_returns and high_returns filters as columns to the pipeline so&#x000A;    # that when we refer to securities remaining in our pipeline later, we know&#x000A;    # which ones belong to which category.&#x000A;    pipe.add(low_returns, 'low_returns')&#x000A;    pipe.add(high_returns, 'high_returns')&#x000A;&#x000A;    return pipe&#x000A;&#x000A;&#x000A;def before_trading_start(context, data):&#x000A;    """&#x000A;    Called every day before market open. This is where we get the securities&#x000A;    that made it through the pipeline.&#x000A;    """&#x000A;&#x000A;    # Pipeline_output returns a pandas DataFrame with the results of our factors&#x000A;    # and filters.&#x000A;    context.output = pipeline_output('mean_reversion_example')&#x000A;&#x000A;    # Sets the list of securities we want to long as the securities with a 'True'&#x000A;    # value in the low_returns column.&#x000A;    context.long_secs = context.output[context.output['low_returns']]&#x000A;&#x000A;    # Sets the list of securities we want to short as the securities with a 'True'&#x000A;    # value in the high_returns column.&#x000A;    context.short_secs = context.output[context.output['high_returns']]&#x000A;&#x000A;    # A list of the securities that we want to order today.&#x000A;    context.security_list = context.long_secs.index.union(context.short_secs.index).tolist()&#x000A;&#x000A;    # A set of the same securities, sets have faster lookup.&#x000A;    context.security_set = set(context.security_list)&#x000A;&#x000A;def assign_weights(context):&#x000A;    """&#x000A;    Assign weights to our long and short target positions.&#x000A;    """&#x000A;&#x000A;    # Set the allocations to even weights for each long position, and even weights&#x000A;    # for each short position.&#x000A;    context.long_weight = context.long_leverage / len(context.long_secs)&#x000A;    context.short_weight = context.short_leverage / len(context.short_secs)&#x000A;&#x000A;def rebalance(context,data):&#x000A;    """&#x000A;    This rebalancing function is called according to our schedule_function settings.&#x000A;    """&#x000A;&#x000A;    assign_weights(context)&#x000A;&#x000A;    # For each security in our universe, order long or short positions according&#x000A;    # to our context.long_secs and context.short_secs lists.&#x000A;    for stock in context.security_list:&#x000A;        if data.can_trade(stock):&#x000A;            if stock in context.long_secs.index:&#x000A;                order_target_percent(stock, context.long_weight)&#x000A;            elif stock in context.short_secs.index:&#x000A;                order_target_percent(stock, context.short_weight)&#x000A;&#x000A;    # Sell all previously held positions not in our new context.security_list.&#x000A;    for stock in context.portfolio.positions:&#x000A;        if stock not in context.security_set and data.can_trade(stock):&#x000A;            order_target_percent(stock, 0)&#x000A;&#x000A;    # Log the long and short orders each week.&#x000A;    log.info("This week's longs: "+", ".join([long_.symbol for long_ in context.long_secs.index]))&#x000A;    log.info("This week's shorts: "  +", ".join([short_.symbol for short_ in context.short_secs.index]))&#x000A;&#x000A;&#x000A;def record_vars(context, data):&#x000A;    """&#x000A;    This function is called at the end of each day and plots certain variables.&#x000A;    """&#x000A;&#x000A;    # Check how many long and short positions we have.&#x000A;    longs = shorts = 0&#x000A;    for position in context.portfolio.positions.itervalues():&#x000A;        if position.amount > 0:&#x000A;            longs += 1&#x000A;        if position.amount < 0:&#x000A;            shorts += 1&#x000A;&#x000A;    # Record and plot the leverage of our portfolio over time as well as the&#x000A;    # number of long and short positions. Even in minute mode, only the end-of-day&#x000A;    # leverage is plotted.&#x000A;    record(leverage = context.account.leverage, long_count=longs, short_count=shorts)&#x000A;&#x000A;</pre>
<h3 id='sample-multiple'>Multiple Security Example</h3>
<p>This example shows how to initialize and trade with multiple securities.  It imports the datetime and pytz libraries and uses the log function to understand the behavior.  You can clone this algorithm from the <a href='https://www.quantopian.com/posts/updated-multi-sid-example-algorithm-1'>community discussion of this example</a>.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_multiple_securities'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This example runs the same momentum play as the first sample &#x000A;# (https://www.quantopian.com/help#sample-basic), but this time it uses more&#x000A;# securities during the backtest.&#x000A;&#x000A;# First step is importing any needed libraries.&#x000A;import datetime&#x000A;import pytz&#x000A;&#x000A;def initialize(context):&#x000A;    # Here we initialize each security.&#x000A;    # AAPL, IBM, and CSCO&#x000A;    context.security_list = [sid(24), sid(3766), sid(1900)]&#x000A;    context.vwap = {}&#x000A;    context.price = {}&#x000A; &#x000A;    # Setting our maximum position size, like previous example&#x000A;    context.max_notional = 1000000.1&#x000A;    context.min_notional = -1000000.0&#x000A;&#x000A;    # Initializing the time variables we use for logging&#x000A;    # Convert timezone to US EST to avoid confusion&#x000A;    est = pytz.timezone('US/Eastern')&#x000A;    context.d=datetime.datetime(2000, 1, 1, 0, 0, 0, tzinfo=est)&#x000A;    &#x000A;    # Rebalance every day at 10:30am&#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open(hours=1))&#x000A;   &#x000A;&#x000A;def rebalance(context, data):&#x000A;    # Initializing the position as zero at the start of each frame&#x000A;    notional=0&#x000A;    &#x000A;    # Gets the 3-day price and volume history of our securities.&#x000A;    hist = data.history(context.security_list, ['price', 'volume'],  3, '1d')[:-1]&#x000A;&#x000A;    # Get the current price and last traded price of each of our securities.&#x000A;    curr = data.current(context.security_list, ['price', 'last_traded'])&#x000A;&#x000A;    # This runs through each security.  It computes&#x000A;    # our position at the start of each frame.&#x000A;    for security in context.security_list:&#x000A;        price = curr['price'][security]&#x000A;        notional = notional + context.portfolio.positions[security].amount * price&#x000A;        &#x000A;    # This runs through each security again.  It finds the price and calculates&#x000A;    # the volume-weighted average price.  If the price is moving quickly, and&#x000A;    # we have not exceeded our position limits, it executes the order and&#x000A;    # updates our position.&#x000A;    for security in context.security_list:   &#x000A;        &#x000A;        vwap = (hist['price'] * hist['volume']).sum() / hist['volume'].sum()&#x000A;        &#x000A;        price = data.current(security, 'price')&#x000A;&#x000A;        if price < vwap * 0.995 and notional > context.min_notional:&#x000A;            order(security,-100)&#x000A;            notional = notional - price*100&#x000A;        elif price > vwap * 1.005 and notional < context.max_notional:&#x000A;            order(security,+100)&#x000A;            notional = notional + price*100&#x000A;&#x000A;    # If this is the first trade of the day, it logs the notional.&#x000A;    if (context.d + datetime.timedelta(days=1)) < tradeday:&#x000A;        log.debug(str(notional) + ' - notional start ' + tradeday.strftime('%m/%d/%y'))&#x000A;        context.d = tradeday&#x000A; &#x000A;</pre>
<h3 id='sample-record'>Record Variables Example</h3>
<p>This example compares Boeing's 20-day moving average with its 80-day moving average and trades when the two averages cross.  It records both moving averages as well as Boeing's share price.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_record_variables'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This initialize function sets any data or variables that you'll use in&#x000A;# your algorithm.&#x000A;def initialize(context):&#x000A;    context.stock = symbol('BA')  # Boeing&#x000A;    &#x000A;    # Since record() only works on a daily resolution, record our price at the end&#x000A;    # of each day.&#x000A;    schedule_function(record_vars,&#x000A;                      date_rule=date_rules.every_day(),&#x000A;                      time_rule=time_rules.market_close(hours=1))&#x000A;    &#x000A;# Now we get into the meat of the algorithm. &#x000A;def record_vars(context, data):&#x000A;    # Create a variable for the price of the Boeing stock&#x000A;    context.price = data.current(context.stock, 'price')&#x000A;    &#x000A;    # Create variables to track the short and long moving averages. &#x000A;    # The short moving average tracks over 20 days and the long moving average&#x000A;    # tracks over 80 days. &#x000A;    price_history = data.history(context.stock, 'price', 80, '1d')&#x000A;    short_mavg = price_history[-20:].mean()&#x000A;    long_mavg = price_history.mean()&#x000A;&#x000A;    # If the short moving average is higher than the long moving average, then &#x000A;    # we want our portfolio to hold 500 stocks of Boeing&#x000A;    if (short_mavg > long_mavg):&#x000A;        order_target(context.stock, +500)&#x000A;    &#x000A;    # If the short moving average is lower than the long moving average, then&#x000A;    # then we want to sell all of our Boeing stocks and own 0 shares&#x000A;    # in the portfolio. &#x000A;    elif (short_mavg < long_mavg):&#x000A;        order_target(context.stock, 0)&#x000A;&#x000A;    # Record our variables to see the algo behavior. You can record up to &#x000A;    # 5 custom variables. Series can be toggled on and off in the plot by&#x000A;    # clicking on labeles in the legend. &#x000A;    record(short_mavg = short_mavg,&#x000A;        long_mavg = long_mavg,&#x000A;        goog_price = context.price)&#x000A;&#x000A;</pre>
<h3 id='sample-csv-1'>Fetcher Example</h3>
<p>This example loads and formats two price series from Quandl. It displays the price movements and decides to buy and sell Tiffany stock based on the price of gold.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_fetcher'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'>import pandas&#x000A;&#x000A;def rename_col(df):&#x000A;    df = df.rename(columns={'New York 15:00': 'price'})&#x000A;    df = df.rename(columns={'Value': 'price'})&#x000A;    df = df.fillna(method='ffill')&#x000A;    df = df[['price', 'sid']]&#x000A;    # Correct look-ahead bias in mapping data to times   &#x000A;    df = df.tshift(1, freq='b')&#x000A;    log.info(' \n %s ' % df.head())&#x000A;    return df&#x000A;&#x000A;def preview(df):&#x000A;    log.info(' \n %s ' % df.head())&#x000A;    return df&#x000A;    &#x000A;def initialize(context):&#x000A;    # import the external data&#x000A;    fetch_csv('https://www.quandl.com/api/v1/datasets/JOHNMATT/PALL.csv?trim_start=2012-01-01',&#x000A;        date_column='Date',&#x000A;        symbol='palladium',&#x000A;        pre_func = preview,&#x000A;        post_func=rename_col,&#x000A;        date_format='%Y-%m-%d')&#x000A;&#x000A;    fetch_csv('https://www.quandl.com/api/v1/datasets/BUNDESBANK/BBK01_WT5511.csv?trim_start=2012-01-01',&#x000A;        date_column='Date',&#x000A;        symbol='gold',&#x000A;        pre_func = preview,&#x000A;        post_func=rename_col,&#x000A;        date_format='%Y-%m-%d')&#x000A;    &#x000A;    # Tiffany&#x000A;    context.stock = sid(7447)&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A; &#x000A;&#x000A;def rebalance(context, data):&#x000A;    # Invest 100% of the portfolio in Tiffany stock when the price of gold is low.&#x000A;    # Decrease the Tiffany position to 50% of portfolio when the price of gold is high.&#x000A;    current_gold_price = data.current('gold', 'price')&#x000A;    if (current_gold_price < 1600):&#x000A;       order_target_percent(context.stock, 1.00)&#x000A;    if (current_gold_price > 1750):&#x000A;       order_target_percent(context.stock, 0.50)&#x000A;&#x000A;    # Current prices of palladium (from .csv file) and TIF&#x000A;    current_pd_price = data.current('palladium', 'price')&#x000A;    current_tif_price = data.current(context.stock, 'price')&#x000A;    &#x000A;    # Record the variables&#x000A;    record(palladium=current_pd_price, gold=current_gold_price, tif=current_tif_price)&#x000A;&#x000A;</pre>
<h3 id='sample-custom-slippage'>Custom Slippage Example</h3>
<p>This example implements the fixed slippage model, but with the additional flexibility to specify a different spread for each stock.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_custom_slippage'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># Our custom slippage model&#x000A;class PerStockSpreadSlippage(slippage.SlippageModel):&#x000A;&#x000A;    # We specify the constructor so that we can pass state to this class, but this is optional.&#x000A;    def __init__(self, spreads):&#x000A;        # Store a dictionary of spreads, keyed by sid.&#x000A;        self.spreads = spreads&#x000A;&#x000A;    def process_order(self, data, my_order):&#x000A;        spread = self.spreads[my_order.sid]&#x000A;&#x000A;        price = data.current(my_order.sid, 'price')&#x000A;&#x000A;        # In this model, the slippage is going to be half of the spread for &#x000A;        # the particular stock&#x000A;        slip_amount = spread / 2&#x000A;&#x000A;        # Compute the price impact of the transaction. Size of price impact is &#x000A;        # proprotional to order size. &#x000A;        # A buy will increase the price, a sell will decrease it. &#x000A;        new_price = price + (slip_amount * my_order.direction)&#x000A;&#x000A;        log.info('executing order ' + str(my_order.sid) + ' stock bar price: ' + \&#x000A;                 str(price) + ' and trade executes at: ' + str(new_price))&#x000A;&#x000A;        return (new_price, my_order.amount)&#x000A;&#x000A;def initialize(context):&#x000A;    # Provide the bid-ask spread for each of the securities in the universe.&#x000A;    context.spreads = {&#x000A;        sid(24): 0.05,&#x000A;        sid(3766): 0.08&#x000A;    }&#x000A;   &#x000A;    # Initialize slippage settings given the parameters of our model&#x000A;    set_slippage(PerStockSpreadSlippage(context.spreads))&#x000A;&#x000A;    # Rebalance daily.&#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;def rebalance(context, data):&#x000A;    # We want to own 100 shares of each stock in our universe&#x000A;    for stock in context.spreads:&#x000A;        order_target(stock, 100)&#x000A;        log.info('placing market order for ' + str(stock.symbol) + ' at price ' \&#x000A;             + str(data.current(stock, 'price')))&#x000A;&#x000A;</pre>
<h3 id='sample-talib'>TA-Lib Example</h3>
<p>This example uses TA-Lib's RSI method. For more examples of commonly-used TA-Lib functions, <a href='help.html#talib-examples'>click here</a>.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_ta_lib_usage'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This example algorithm uses the Relative Strength Index indicator as a buy/sell signal.&#x000A;# When the RSI is over 70, a stock can be seen as overbought and it's time to sell.&#x000A;# When the RSI is below 30, a stock can be seen as oversold and it's time to buy.&#x000A;&#x000A;import talib&#x000A;import numpy as np&#x000A;import math&#x000A;&#x000A;# Setup our variables&#x000A;def initialize(context):&#x000A;    context.max_notional = 100000&#x000A;    context.intc = sid(3951)  # Intel &#x000A;    context.LOW_RSI = 30&#x000A;    context.HIGH_RSI = 70&#x000A;    &#x000A;    schedule_function(rebalance, date_rules.every_day(), time_rules.market_open())&#x000A;&#x000A;def rebalance(context, data):&#x000A;    &#x000A;    #Get a trailing window of data&#x000A;    prices = data.history(context.intc, 'price', 15, '1d')&#x000A;    &#x000A;    # Use pandas dataframe.apply to get the last RSI value&#x000A;    # for for each stock in our basket&#x000A;    intc_rsi = talib.RSI(prices, timeperiod=14)[-1]&#x000A;&#x000A;    # Get our current positions&#x000A;    positions = context.portfolio.positions&#x000A;&#x000A;    # Until 14 time periods have gone by, the rsi value will be numpy.nan&#x000A;    &#x000A;    # RSI is above 70 and we own GOOG, time to close the position.&#x000A;    if intc_rsi > context.HIGH_RSI and context.intc in positions:&#x000A;        order_target(context.intc, 0)&#x000A;        &#x000A;        # Check how many shares of Intel we currently own&#x000A;        current_intel_shares = positions[context.intc].amount&#x000A;        log.info('RSI is at ' + str(intc_rsi) + ', selling ' + str(current_intel_shares) + ' shares')&#x000A;    &#x000A;    # RSI is below 30 and we don't have any Intel stock, time to buy.&#x000A;    elif intc_rsi < context.LOW_RSI and context.intc not in positions:&#x000A;        o = order_target_value(context.intc, context.max_notional)&#x000A;        log.info('RSI is at ' + str(intc_rsi) + ', buying ' + str(get_order(o).amount)  + ' shares')&#x000A;&#x000A;    # record the current RSI value and the current price of INTC.&#x000A;    record(intcRSI=intc_rsi, intcPRICE=data.current(context.intc, 'close'))&#x000A;&#x000A;</pre>
<h3 id='sample-history'>History Example</h3>
<p>This example uses the history function.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_history'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># Standard Deviation Using History&#x000A;# Use history() to calculate the standard deviation of the days' closing&#x000A;# prices of the last 10 trading days, including price at the time of &#x000A;# calculation.&#x000A;def initialize(context):&#x000A;    # AAPL&#x000A;    context.aapl = sid(24)&#x000A;&#x000A;    schedule_function(get_history, date_rules.every_day(), time_rules.market_close())&#x000A;&#x000A;def get_history(context, data):&#x000A;    # use history to pull the last 10 days of price&#x000A;    price_history = data.history(context.aapl, fields='price', bar_count=10, frequency='1d')&#x000A;    # calculate the standard deviation using std()&#x000A;    std = price_history.std()&#x000A;    # record the standard deviation as a custom signal&#x000A;    record(std=std)&#x000A;&#x000A;</pre>
<h3 id='sample-robinhood'>Algorithm Framework For Robinhood Users</h3>
<p>This algorithm contains a framework for backtesting & live trading algorithms to be deployed with Robinhood. It contains measures for cash management and settlement.</p>
<a class='btn btn-primary clone-sample-algo-button clone-sample-algo-link' data-sampletype='sample_robinhood_framework'>
<i class='icon icon-copy'></i>
Clone Algorithm
</a>
<pre class='prettyprint'># This algorithm contains the basic framework for backtesting and&#x000A;# deploying a live algorithm with Robinhood. This does 3 things:&#x000A;# (1) Simulates a T+3 wait while cash is settling, not placing&#x000A;#     any trades in the meanwhile. This should only be used&#x000A;#     for backtesting.&#x000A;# (2) Use the `set_long_only()` trading guard to insure that any&#x000A;#     algorithm deployed with Robinhood only contains long&#x000A;#     positions&#x000A;# (3) Include `do_unsettled_funds_exist` that will replicate the&#x000A;#     functionality found in (1) but only for Live Trading. Once&#x000A;#     you're ready to deploy, you can comment out all mentions of&#x000A;#     `check_last_sale` and `cash_settlement_date` and use&#x000A;#     `do_unsettled_funds_exist` instead!&#x000A;&#x000A;def initialize(context):&#x000A;    # Set a trading guard that will prevent any short positions&#x000A;    # from being placed. This is to insure that algorithms that&#x000A;    # depend on short positions are not accidently deployed.&#x000A;    set_long_only()&#x000A;&#x000A;    # Keeping track of the last sale that you have.&#x000A;    context.last_sale = None&#x000A;    &#x000A;    # Just a simple variable to demonstrate `context.last_sale`,&#x000A;    # `cash_settlement_date`, and `check_last_sale`&#x000A;    context.trading_days = 0&#x000A;&#x000A;    # Reference to AAPL.&#x000A;    context.aapl = sid(24)&#x000A;&#x000A;def handle_data(context, data):&#x000A;    # Because most Robinhood accounts are cash accounts,&#x000A;    # trades(and most other brokerages) settle &#x000A;    # on a T+3 settlement date. This snippet of code prevents&#x000A;    # a trade from happening when you still have unsettled cash&#x000A;    # by checking if total cash (settled & unsettled) matches your&#x000A;    # settled cash amount.&#x000A;&#x000A;    # [IMPORTANT] During backtests, `settled_cash` will always equal&#x000A;    # `cash`. In order to simulate a similar check, please also &#x000A;    # incorporate `simulate_cash_settlement` in handle data as you will&#x000A;    # see in this algorithm.&#x000A;    if do_unsettled_funds_exist(context):&#x000A;        # For live trading only&#x000A;        return&#x000A;&#x000A;    # `cash_settlement_date` simulates a T+3 settlement date. This&#x000A;    # should be used at the beginning of any handle_data or method&#x000A;    # used for schedule_function that places orders. At the end of&#x000A;    # of that method should be `check_last_sale`. Only for&#x000A;    # backtesting purposes!&#x000A;    if cash_settlement_date(context):&#x000A;        log.info("Unsettled Cash Simulated")&#x000A;    elif data.can_trade(context.aapl):&#x000A;        # You can see the simulation in prgoress here.&#x000A;        # On day 0, it will order 5 shares of AAPL&#x000A;        # On day 1, it will order -1 shares and the proceeds&#x000A;        # from the sale will be unsettled till day 4.&#x000A;        # On day 4, you will be able to place another sale.&#x000A;        if context.trading_days == 0:&#x000A;            log.info("Day 0")&#x000A;            order(context.aapl, 5)&#x000A;        if context.trading_days == 1:&#x000A;            log.info("Day 1")&#x000A;            order(context.aapl, -1)&#x000A;        if context.trading_days == 2:&#x000A;            # Day 2 should not log.&#x000A;            log.info("Day 2")&#x000A;            order(context.aapl, -1)&#x000A;        if context.trading_days == 4:&#x000A;            log.info("Day 4")&#x000A;            order(context.aapl, -1)&#x000A;  &#x000A;    context.trading_days += 1&#x000A;    &#x000A;    # `check_last_sale` is what `cash_settlement_date` needs in&#x000A;    # order to work properly. Only for backtesting purposes!&#x000A;    check_last_sale(context)&#x000A;&#x000A;def do_unsettled_funds_exist(context):&#x000A;    """&#x000A;    For Robinhood users. In order to prevent you from attempting&#x000A;    to trade on unsettled cash (settlement dates are T+3) from&#x000A;    sale of proceeds. You can use this snippet of code which&#x000A;    checks for whether or not you currently have unsettled funds&#x000A;    &#x000A;    To only be used for live trading!&#x000A;    """&#x000A;    if context.portfolio.cash != context.account.settled_cash:&#x000A;        return True&#x000A;&#x000A;def check_last_sale(context):&#x000A;    """&#x000A;    To be used at the end of each bar. This checks if there were&#x000A;    any sales made and sets that to `context.last_sale`.&#x000A;    `context.last_sale` is then used in `cash_settlement_date` to&#x000A;    simulate a T+3 Cash Settlement date&#x000A;    &#x000A;    To only be used for backtesting!&#x000A;    """&#x000A;    open_orders = get_open_orders()&#x000A;    most_recent_trade = []&#x000A;    # If there are open orders check for the most recent sale&#x000A;    if open_orders:&#x000A;        for sec, order in open_orders.iteritems():&#x000A;            for oo in order:&#x000A;                if oo.amount < 0:&#x000A;                    most_recent_trade.append(oo.created)&#x000A;    if len(most_recent_trade) > 0:&#x000A;        context.last_sale = max(most_recent_trade)&#x000A;    &#x000A;def cash_settlement_date(context):&#x000A;    """&#x000A;    This will simulate Robinhood's T+3 cash settlement. If the &#x000A;    most recent sale is less than 3 trading days from the current&#x000A;    day, assume we have unsettled funds and exit&#x000A;    &#x000A;    To only be used for backtesting!&#x000A;    """&#x000A;    if context.last_sale and (get_datetime() - context.last_sale).days < 3:&#x000A;        return True&#x000A;&#x000A;</pre>
<div class='spacer'></div>
</div>
</div>
</div>
<script>
  //<![CDATA[
    $(document).ready(function() {
      quanto.instances.help_manager = new quanto.HelpManager();
    })
  //]]>
</script>
<!-- begin olark code for chat box-->
<script data-cfasync="false" type='text/javascript'>/*<![CDATA[*/window.olark||(function(c){var f=window,d=document,l=f.location.protocol=="https:"?"https:":"http:",z=c.name,r="load";var nt=function(){
f[z]=function(){
(a.s=a.s||[]).push(arguments)};var a=f[z]._={
},q=c.methods.length;while(q--){(function(n){f[z][n]=function(){
f[z]("call",n,arguments)}})(c.methods[q])}a.l=c.loader;a.i=nt;a.p={
0:+new Date};a.P=function(u){
a.p[u]=new Date-a.p[0]};function s(){
a.P(r);f[z](r)}f.addEventListener?f.addEventListener(r,s,false):f.attachEvent("on"+r,s);var ld=function(){function p(hd){
hd="head";return["<",hd,"></",hd,"><",i,' onl' + 'oad="var d=',g,";d.getElementsByTagName('head')[0].",j,"(d.",h,"('script')).",k,"='",l,"//",a.l,"'",'"',"></",i,">"].join("")}var i="body",m=d[i];if(!m){
return setTimeout(ld,100)}a.P(1);var j="appendChild",h="createElement",k="src",n=d[h]("div"),v=n[j](d[h](z)),b=d[h]("iframe"),g="document",e="domain",o;n.style.display="none";m.insertBefore(n,m.firstChild).id=z;b.frameBorder="0";b.id=z+"-loader";if(/MSIE[ ]+6/.test(navigator.userAgent)){
b.src="javascript:false"}b.allowTransparency="true";v[j](b);try{
b.contentWindow[g].open()}catch(w){
c[e]=d[e];o="javascript:var d="+g+".open();d.domain='"+d.domain+"';";b[k]=o+"void(0);"}try{
var t=b.contentWindow[g];t.write(p());t.close()}catch(x){
b[k]=o+'d.write("'+p().replace(/"/g,String.fromCharCode(92)+'"')+'");d.close();'}a.P(2)};ld()};nt()})({
loader: "static.olark.com/jsclient/loader0.js",name:"olark",methods:["configure","extend","declare","identify"]});
<!-- * custom configuration goes here (www.olark.com/documentation) */ -->
olark.identify('1854-640-10-4011');/*]]>*/</script><noscript><a href="https://www.olark.com/site/1854-640-10-4011/contact" title="Contact us" target="_blank">Questions? Feedback?</a> powered by <a href="http://www.olark.com?welcome" title="Olark live chat software">Olark live chat software</a></noscript>
<!-- end olark code for chat box -->
<script type="text/javascript">
olark('api.visitor.updateFullName',{fullName: "guest_14625950547960"}); // get the user's name
olark('api.visitor.updateEmailAddress',{emailAddress: "guest_14625950547960@quantopian.com"}); // get the user's email address
olark('api.chat.updateVisitorStatus',{snippet: "572d6deed42b61f8d200072f"});   // get the user's ID
</script>


<div class='modal hide' id='error-modal'>
<div class='modal-header'>
<h4 class='modal-title'>Error</h4>
</div>
<div class='modal-body body-content'>
<p>Sorry, something went wrong.  Try again or contact us by <a class='feedback-link'>sending feedback</a>.</p>
</div>
<div class='modal-footer'>
<button class='btn btn-primary' data-dismiss='modal' href='#'>Close</button>
</div>

</div>

<div class='modal hide' id='confirmation-modal'>
<div class='modal-header'>
<h4 class='modal-title'></h4>
</div>
<div class='modal-body body-content'></div>
<div class='modal-footer'>
<button class='btn btn-default' data-dismiss='modal'>Cancel</button>
<button class='btn btn-primary action-button' data-dismiss='modal'></button>
</div>

</div>

<div class='modal hide' id='feedback-modal'>
<div class='modal-header'>
<h3 class='modal-title'>Send Feedback</h3>
</div>
<div class='modal-body'>
<div class='controls'>
<div class='from'>
<span class='valign-top'>From: </span>
<div class='feedback-inputs'>
<div class='form-group'>
<input autofocus class='form-control' id='feedback-email-box' placeholder='Email address' type='email'>
</div>
<div class='form-group'>
<input class='form-control' id='feedback-name-box' placeholder='Name' type='text'>
</div>
</div>
</div>
<textarea class='form-control input-xxlarge width_100pct' id='feedback-box' rows='10'></textarea>
<div class='feedback-checkbox'>
<div class='checkbox'>
<label>
<input id='anonymous-feedback-checkbox' type='checkbox'>I understand I will not receive a reply without providing a valid email address.</input>
</label>
</div>
</div>
</div>
<div class='success hidden'>
<span>Thank you!  We will be in touch soon.</span>
</div>
</div>
<div class='modal-footer'>
<div class='controls'>
<button class='btn btn-default' data-dismiss='modal'>Cancel</button>
<button class='btn btn-primary' id='send-feedback-button'>Send</button>
</div>
<div class='success hidden'>
<a class='btn btn-primary' data-dismiss='modal' href='help.html#'>Close</a>
</div>
</div>

</div>

<div class='modal hide' id='join-modal'>
<div class='modal-header'>
<h3 class='modal-title'>Join Quantopian.  It's free!</h3>
</div>
<div class='modal-body'>
<p class='large'>Once you join, you can:</p>
<div class='margin_20t'>
<div class='action'>
<i class='icon icon-copy'></i>
Create more algorithms
</div>
<div class='action'>
<i class='icon icon-bar-chart'></i>
Run full backtests, with detailed risk metrics and full transaction reports
</div>
<div class='action'>
<i class='icon icon-comments-alt'></i>
Post and share in our community
</div>
<div class='action'>
<i class='icon icon-trophy'></i>
Submit algorithms to the Quantopian Open
</div>
</div>
<div class='margin_20t margin_20b large'>Don't worry, all your work is already saved.</div>
</div>
<div class='modal-footer'>
<div class='pull-left'>
<a class='btn btn-default btn-large' data-dismiss='modal' href='help.html#'>Close</a>
</div>
<a class='btn btn-primary btn-large font-14' href='users/sign_up.html'>Join Quantopian</a>
<a class='btn btn-default btn-large font-14 login-button' href='users/sign_in.html'>Log In</a>
</div>

</div>

<div class='modal hide' id='message-modal'>
<div class='modal-header'>
<h3 class='modal-title'></h3>
</div>
<div class='modal-body'></div>
<div class='modal-footer'>
<button class='btn btn-primary' data-dismiss='modal' id='message-modal-close'>Close</button>
</div>

</div>

</div>
<div class='footer old-style' id='quanto-footer-container'>
<div class='container'>
<div class='row main-footer'>
<div class='row footer-inner'>
<div class='span3 col-sm-4'>
<div class='footer-item'>
<div class='title h2'>Company</div>
<div class='footer-row'>
<a href='about.html'>About</a>
</div>
<div class='footer-row'>
<a href='academia.html'>Academia</a>
</div>
<div class='footer-row'>
<a href='workshops.html'>Workshops</a>
</div>
<div class='footer-row'>
<a href='about.html'>Careers</a>
</div>
<div class='footer-row'>
<a href='posts.html'>Community</a>
</div>
<div class='footer-row'>
<a href='prospective_investors.html'>Prospective Investors</a>
</div>
</div>
</div>
<div class='span3 col-sm-4'>
<div class='footer-item'>
<div class='title h2'>Learn &amp; Support</div>
<div class='footer-row'>
<a href='tutorials/getting-started.html'>Getting Started</a>
</div>
<div class='footer-row'>
<a href='faq.html'>FAQs</a>
</div>
<div class='footer-row'>
<a href='help.html'>Help &amp; API docs</a>
</div>
<div class='footer-row'>
<a href='tutorials.html'>Tutorials</a>
</div>
<div class='footer-row'>
<a href='lectures.html'>Lectures</a>
</div>
<div class='footer-row'>
<a href='http://status.quantopian.com'>Site Status</a>
</div>
<div class='footer-row'>
<a href='security.html'>Security</a>
</div>
</div>
</div>

<div class='span6'>
<div class='feedback-email pull-right'>
Need Help?
<a class='open-feedback-link' href='help.html#'>Contact Support</a>
</div>
</div>
</div>
<div class='row footer-inner'>
<div class='span3 col-sm-4'>
<div class='footer-item'>
<div class='title h2'>Notices</div>
<div class='footer-row'>
<a href='policies/terms.html'>Terms of Use</a>
</div>
<div class='footer-row'>
<a href='policies/privacy.html'>Privacy Policy</a>
</div>
<div class='footer-row'>
<a href='policies/risks.html'>Trading Risk</a>
</div>
<div class='footer-row'>
<a href='policies/live_trading.html'>Brokerage Terms</a>
</div>
</div>
</div>
<div class='span3 col-sm-4'>
<div class='footer-item'>
<div class='title h2'>Follow Us</div>
<div class='footer-row'>
<a href='http://www.twitter.com/quantopian'>Twitter</a>
</div>
<div class='footer-row'>
<a href='http://www.facebook.com/quantopian'>Facebook</a>
</div>
<div class='footer-row'>
<a href='http://www.linkedin.com/company/quantopian'>LinkedIn</a>
</div>
<div class='footer-row'>
<a href='http://blog.quantopian.com'>Blog</a>
</div>
</div>
</div>

</div>
<div class='row'>
<div class='span12 copyright'>&copy; 2016 Quantopian, Inc.</div>
</div>
</div>
</div>
<div class='mobile-footer'>
<div class='mobile-nav-category main-links'>
<div class='mobile-nav-row'>
<a href='about.html'>About Quantopian</a>
</div>
<div class='mobile-nav-row'>
<a href='about.html'>Careers</a>
</div>
<div class='mobile-nav-row'>
<a href='posts.html'>Community</a>
</div>
<div class='mobile-nav-row'>
<a href='help.html'>Help</a>
</div>
<div class='mobile-nav-row'>
<a href='academia.html'>Academia</a>
</div>
<div class='mobile-nav-row'>
<a href='lectures.html'>Lectures</a>
</div>
<div class='mobile-nav-row'>
<a href='workshops.html'>Workshops</a>
</div>
<div class='mobile-nav-row'>
<a href='http://status.quantopian.com'>Status</a>
</div>
<div class='mobile-nav-row'>
<a href='http://www.facebook.com/quantopian'>Facebook</a>
</div>
<div class='mobile-nav-row'>
<a href='http://www.twitter.com/quantopian'>Twitter</a>
</div>
<div class='mobile-nav-row'>
<a href='http://www.linkedin.com/company/quantopian'>LinkedIn</a>
</div>
<div class='mobile-nav-row'>
<a href='http://blog.quantopian.com'>Blog</a>
</div>
</div>
<div class='mobile-nav-category secondary-links'>
<div class='mobile-nav-row'>
<p>&copy; 2016 Quantopian</p>
</div>
<div class='mobile-nav-row'>
<a href='policies/terms.html'>Terms of Use</a>
</div>
<div class='mobile-nav-row'>
<a href='policies/privacy.html'>Privacy Policy</a>
</div>
</div>
</div>

</div>

</div>
</body>
</html>
<script>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8519877-1']);
    _gaq.push(['_trackPageview']);
    _gaq.push(['_setDomainName', 'quantopian.com']);
    _gaq.push(['_setCustomVar', 1, 'quanto_session_id', 'session_572d6deed42b61f8d200072e']);
    _gaq.push(['_setCustomVar', 2, 'quanto_user_id', '572d6deed42b61f8d200072f']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>


<input id="is_mac" name="is_mac" type="hidden" value="false" />
<script>
  //<![CDATA[
    (function(c,a){window.mixpanel=a;var b,d,h,e;b=c.createElement("script");b.type="text/javascript";b.async=!0;b.src=("https:"===c.location.protocol?"https:":"http:")+'//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js';
    d=c.getElementsByTagName("script")[0];d.parentNode.insertBefore(b,d);a._i=[];a.init=function(b,c,f){function d(a,b){var c=b.split(".");2==c.length&&(a=a[c[0]],b=c[1]);
    a[b]=function(){a.push([b].concat(Array.prototype.slice.call(arguments,0)))}}
    var g=a;"undefined"!==typeof f? g=a[f]=[]:f="mixpanel";g.people=g.people||[];
    h="disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config people.identify people.set people.increment".split(" ");for(e=0;e<h.length;e++) d(g,h[e]);a._i.push([b,c,f])};a.__SV=1.1})(document,window.mixpanel||[]);mixpanel.init("75873953cd404bcc1da88a55ff51e3b4")
  //]]>
</script>

<script>
  //<![CDATA[
    mixpanel.register({"$email": "guest_14625950547960@quantopian.com"})
    mixpanel.people.set({"$email": "guest_14625950547960@quantopian.com", "$name": "guest_14625950547960"})
    mixpanel.identify("572d6deed42b61f8d200072f");
  //]]>
</script>

<script>
  //<![CDATA[
    mixpanel.track("view page", {"page": window.location.pathname})
  //]]>
</script>
<script type="text/javascript">if (typeof NREUMQ !== "undefined") { if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","59252e476d","984851","dAlXTUcKWFpQRBlfXFsWFlBbAVFO",15,182,new Date().getTime(),"","","","",""]);}</script>
